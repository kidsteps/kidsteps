{
  "main": {
    "id": "32f0fc769e5c0004",
    "type": "split",
    "children": [
      {
        "id": "ee093cf76a8d8fdf",
        "type": "tabs",
        "children": [
          {
            "id": "18c4caef5defb071",
            "type": "leaf",
            "state": {
              "type": "markdown",
              "state": {
                "file": "2.经验与教训/我的/微量元素问题.md",
                "mode": "source",
                "backlinks": true,
                "source": false
              }
            }
          },
          {
            "id": "96e8e6d2e6ce8cfc",
            "type": "leaf",
            "state": {
              "type": "empty",
              "state": {}
            }
          }
        ]
      },
      {
        "id": "44555e855e4fb4b3",
        "type": "tabs",
        "children": [
          {
            "id": "6614d600326870ad",
            "type": "leaf",
            "state": {
              "type": "tagfolder-view-scroll",
              "state": {
                "files": [
                  {
                    "path": "1.methodolgy/Business Model Canvas (BMC).md",
                    "content": "---\naliases: [BMC]\n---\n#docs/how-to-guides  #methodolgy \n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221224154301266.qRYqZ.jpg)\n",
                    "title": "Business Model Canvas (BMC)"
                  },
                  {
                    "path": "1.methodolgy/Framework Vs. library.md",
                    "content": "#docs/whatis-why-explanation \nYou call library. Framework calls you.   -- Ian Boyd/[Stack Overflow](http://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library/233765#233765)\n\n\nA library is a tool. A framework is a way of life. -- James Curran/[Stack Overflow](http://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library/148781#148781)\n\n\n",
                    "title": "Framework Vs. library"
                  },
                  {
                    "path": "1.methodolgy/How to learn.md",
                    "content": "#docs/how-to-guides  #methodolgy \n\n[[怎么解决问题]]",
                    "title": "How to learn"
                  },
                  {
                    "path": "1.methodolgy/OKR/OKR 制定.md",
                    "content": "#OKR  #docs/how-to-guides \n \n\nOKR 是关注围绕目标的价值产出而非具体行为。\n\n如果用一句话来快速的总结 OKR，可以用一句填空来实现，即：\n\n```\n I will _______ measured by _________\n```\n\n其中，目标 Objective 记录了我们要达到哪里、向哪个方向努力；而 Key Results 则督促我们通过选择具体的道路向目标迈进，并用来衡量我们在道路上的具体位置和进展。\n\n当然，一切应该基本遵循最基本[[制定目标]]的方法论。 自顶向下，自底向上[[对齐目标]]。\n \n## O\n你需要做到以下三点：\n\n-   1.  方向明确：目标不能太抽象，也不能含混不清，要让每个人都能看得懂。\n-   2.  目标对齐：下级要对齐上级的目标，即向上对齐，平级还要相互对齐，即水平对齐。\n-   3.  时间限制：目标需要有时间边界，不能遥遥无期，而且时间边界要恰到好处。\n\n比如，“做一家成功的企业”这样的 O 就不满足要求，因为它的方向不够明确，也缺乏时间限制，什么是成功？需要多长时间才能成功？还不如改为“做一家 102 年的企业”。\n\n## KR\n你同样需要做到三点：\n\n-   1.  有挑战性：关键结果要有挑战性，拒绝平庸，拒绝不切实际，要做到“跳一跳，就能够得着”。\n-   2.  容易度量：无法度量的关键结果是没有任何意义的，宁可抛弃。\n-   3.  不是任务：关键结果需要对目标产生直接影响，它不是日常任务，也不是行动[[计划|计划]]。\n\n总地来说，制定 OKR 需要遵循“[[SMART|SMART]] 原则”\n\n\n![p-2.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/p-2.png)\n\n一个 OKR 可以包含多个 O，每个 O 又可以包含多个 KR。可见，O 和 KR 之间是“一对多”的关系。既然 OKR 需要考虑时间限制，那么 O 就不应该设置太多，最多不要超过 3 个，否则就容易导致精力有限，不够聚焦。\n\n同样，每个 O 所包含的 KR 也无需太多，最多也不要超过 3 个。如果你需要做到绝对聚焦，那么就使用 1 个 O 吧，因为其他的 O 通常都是多余的。\n\n \n\n## 产研部示例\nObjective:优化产品性能、提升产品稳定性\n优先级：P0（P0 代表火速完成，P1 代表期待完成，P2以外代表延伸目标）\n负责人：Derek、Tupac\nKey Results:\n1. 优化日志监控性能，查询 2 天内数据响应时间小于 x 毫秒\n2. 所有页面响应时间小于 x 秒\n3. 提高产品稳定性，每个新功能初次发布稳定性超过 x %，第二次发布稳定性超过 x %\n3. 浸泡测试确保产品稳定运行，首次浸泡时间不低于 x 个月，平均请求不低于 x 次/秒，功能点覆盖率不低于 x%",
                    "title": "OKR 制定"
                  },
                  {
                    "path": "1.methodolgy/OKR/企业的OKR为什么推不动？.md",
                    "content": "#OKR #docs/whatis-why-explanation \n \n\n------\n\n经历过的企业多了，看到非常多的企业在OKR这件事上踩坑、绕弯路。各位有负责自己公司OKR落地的同学，可以把这些故事当成避坑指南一看。\n\n﻿\n\n## HR来主推\n\n﻿\n\n这是第一号大坑，堪称中国企业落地OKR之路的坑王。\n\n﻿\n\n2018年，我们到摩拜单车去了一趟，当时的人力老大在负责OKR的落地这件事情。障碍重重，困难巨大。摩\n\n拜全球1300多人，国内600多人，由HR盯着业务写OKR，业务像在交作业，因为自己的收入掌控在HR手里。\n\n﻿\n\n显然，这种博弈直接违背了OKR激发内在驱动的核心方法。凡是HR来主推的，我很同情你，你很难，如果你\n\n们是HRBP制度，稍微好点，因为你跟战略和业务走的相对近一些，但是，OKR也不是你的份内工作。硬要\n\n把OKR跟HR线挂起来，能挂的唯一角色只有OD。\n\n﻿\n\nHR应该怎么办？把这件事交给老板来推进。你给他讲李彦宏、刘强东、吴亚军、张一鸣的故事，告诉你的老\n\n板这几个大佬因为OKR的事情做了什么。没错，你要把你的老板洗清楚，让他认识到OKR的价值，让他自己\n\n花精力去做这件事情，你在中间做一些辅助执行的活，拉拉会议，找找外部专家，弄几个培训即可。\n\n﻿\n\n相信我，即使大老板给你站台，你自己也接不住这个活，请即刻甩给老板。然后你再花点时间找找Google的\n\nHR平常干点啥，除了盯着业务团队写OKR啥都干。你就负责你的绩效即可，如果你来干，员工默认认为OKR\n\n是绩效考核工具。\n\n﻿\n\nOKR是老板和业务Leader的工作，你作为一个HR始终是参与不进去的。中国公司的HR主导OKR在公司的落\n\n地我就会默默地为这家公司的OKR之路感到担忧。\n\n﻿\n\n﻿\n\n## 部门负责人来推\n\n﻿\n\n某公司研发总监小A对OKR颇感兴趣，看了几本书，看了一个月知乎，决定采用进来。先跟老板打个招呼：\n\n小A：王总，我想用OKR的方式管理团队。 王总：啥OK了？2.0这么快就上线了？ 小A：不是，老板，我要用一种Google内部的管理方法，OKR，目标导向的。 王总：哦，2.0没上线呢，啥时候上？那个什么OK你自己看着办吧，你们团队试出效果再说。 小A：……\n\n﻿\n\n3个月后，小A试不试得出效果，OKR在这家公司是希望渺茫的。\n\n﻿\n\n第一，部门O的来源是小A自己想出来的，不是基于公司整体和王总心中的目标而来的。 第二，小A去平行部门推OKR根本推不动，他不了解其他部门的业务和战略方向。 第三，其他部门先天认为OKR适用于小A部门，自己部门不一定适用。\n\n﻿\n\n也就是说，小A把部门工作计划和业务目标写成OKR玩了几个周期。没啥实际价值，你写成KPI也没啥不行的。\n\n﻿\n\n## 行政副总推\n\n﻿\n\n某集团大佬一拍桌子，我们要采用OKR这个先进的企业管理方法和制度，管行政那个谁，你去落地吧。结果\n\n管行政那个谁去找各业务线的老大让人家写OKR，人家说咋写，他说你看着写呗，我又不懂你业务，我就打\n\n个杂。反正你下周二下班前给我就行了。\n\n﻿\n\n## 老板要全员推\n\n﻿\n\nOKR落地的成本巨大，大在参与OKR的员工要对这个思想、理念有一个深入的学习和认知过程，大在了员工\n\n的时间成本上。300人的公司，在核心管理层30人落地OKR都需要3-6个月的时间。一上来300人全员推？\n\n﻿\n\n一时间，执行层员工在私下讨论，哎，王爱花，你们部门OKR写完了么？没呢没呢，都不知道要写啥，我们\n\n都写成KPI了，但是网上搜了一下发现OKR不是KPI，我们就变成过程指标了。你们咋写的？我们也不知道\n\n啊，这个自己写的话能不能写的简单点？要不完不成怎么办？扣奖金不？不知道啊，先看看别人怎么写的\n\n吧，我再去问问小A他们……\n\n﻿\n\n乱，是必然的。因为你们没把握好节奏。正确的节奏是核心管理层用一段时间接触、学习、实践，在企业内\n\n部营造出这种氛围。全员看着老板和总监们的OKR看了几个月之后再有选择性地逐步参与进来。\n\n﻿\n\n有一个结论我说过很多次，公司和部门级别的OKR走3到6个周期后，你发个公告，让执行层员工自愿加入公\n\n司OKR体系，为自己创建目标，一段时间之后，老板一般都会告诉我，他们公司最宝贵的15%都在里面。另\n\n外85%怎么办？请为他们制定好KPI，OKR在很长一段时间里都不适合他们。\n\n﻿\n\n﻿\n\n## 自下而上推\n\n民营企业的公司级目标不是民主讨论出来的结果。\n\n﻿\n\n中国企业千差万别，只有这个是比较一致的，你们公司的目标只在1、2个人心里清楚。别指望大家一块讨论\n\n个方向出来。每个人站的高度都是不一样的，视野不同，结论不同。这件事中国的老板别浪费时间去组织大\n\n家投票了。OKR中的O一定是自上而下的，这里不是分解，要先有公司级的O，才能有部门级的O，公司级的\n\nO需要通过草案制定过程的上下沟通反馈，详见：为什么说OKR是沟通工具？\n\n﻿\n\n自下而上推OKR带来什么结果？没结果。这种很少，但是也出现过，各部门把工作计划上报一遍完事。\n\n﻿\n\n以上五类大坑，殊途同归，都让你们公司的OKR走向不了了之。下次再做这事，难上加难。这类烂尾的工程\n\n（往往是一些专家、老师、咨询公司去给你们讲过课，实施过一段时间，后来没有效果，又找到我们），我\n\n们都会放弃，因为现在OKR咨询市场巨大，能真正做好这事的寥寥无几，精力实在有限，除非这家是巨头，\n\n并且老板亲自跟我承诺，有推倒重来的决心。",
                    "title": "企业的OKR为什么推不动？"
                  },
                  {
                    "path": "1.methodolgy/PPT 制作.md",
                    "content": "#docs/how-to-guides  \n### 流程\n1. 明确主题、对象、目标（明确听众目标）\n2. 调查调查听众揣摩听众的心理与目标，迎合听众诉求。\n3. 他应该听哪些内容，他就会同意你想让他干的事。\n\n\n### 标题\n[[../怎样写标题]]\n\n### 页\n1. 第一页为主题和大纲，\n2. 第二页为前言、背景或概括，\n3. 第三页为中心思想，正文为支持中心思想的所有一级结论1、2、3等等。\n4. 第四页标题写一级结论1，正文写支持一级结论1的全部论据。\n5. 第五页、第六页、第七页为一级结论1的全部论据的展开详细说明，如:支持论据1、支持论据2、支持论据3。\n6. 第八页写一级结论2，正文写支持一级结论2的全部论据。\n7. 第九页为一级论据2的全部展开内容。\n\n所有PPT中，第1、3、4、8页最为重要。第三页是重中之重，是金字塔结构的塔尖，客户如若让1分钟讲完，就讲第三页\n\n### 图表\n要正确选用图表，饼图的最大缺点是弱化对比。条形图最大的优点是放大对比与反差，并且为横排版，写英文横排版美观。把数据变为图表的第一步是先选信息，之后选择信息之间的关系，最后再选择用何种图表。饼图体现成分百分比，条形图体现项目对比，柱形图体现项目对比及时间。折线图体现趋势、频率及时间的对比。散点图体现数据的相关性。柱形图和折线图常同时使用，可明确表达增涨与连续增涨。\n\n### 书写及表达\n前言即为开场四要素:背景-冲突-疑问-答案，前言要讲结论与结构。\n标题要有信息，总结要点，提炼精华;\n要用明确、简单、响亮的词汇，要用数字，数字最吸引人的眼球;\n要用主谓宾的陈述句、正装句，不要用倒装句。含有动词的短语要用口号式语言。\n标题要对仗工整，善于运用排比\n标题不要超过15个字。\n",
                    "title": "PPT 制作"
                  },
                  {
                    "path": "1.methodolgy/SWOT.md",
                    "content": "---\naliases: [SWOT 分析,市场分析]\n---\n#methodolgy  #docs/how-to-guides \nSWOT代表优势（strength）、劣势（weakness）、机会（opportunity）和[[威胁]]（threat）。这种分析方法**首先用在市场分析**上，在进入一个新市场之前，有必要问下列问题。\n\n![800](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229153141788.Bo9Gp.jpg)\n\n\n分析方法首先用在市场分析上，在进入一个新市场之前，有必要问下列问题。\n1. 我们的优势是什么？我们怎样利用它们？\n2. 我们的劣势是什么？我们怎样减少它们的影响？\n3. 这个市场为我们提供了什么机会？我们怎样把握它？\n4. 什么威胁着我们的成功？我们怎样有效地对付这些威胁？\n\n[[怎么应对风险]]",
                    "title": "SWOT"
                  },
                  {
                    "path": "1.methodolgy/做事的步骤.md",
                    "content": "#docs/how-to-guides  #methodolgy \n\n1. 理解事情达成的关键要素\n\n    1. 向前人学习\n    2. 看书，自己做实验摸索\n2. SOP ， SOP = 流程化 + 标准化 （ 不用精准）\n3. 优化 SOP\n\n    1. 删除\n    2. 替换（更高效率）\n    3. 合并\n    4. [[Parallel Execution|并行]]\n    ![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654265414136-ba70ced0-ec16-4ce7-8d52-5a42eda4283f.png)​\n4. [[../刻意练习|刻意练习]]\n5. 自动化，工具替代人力\n6. 优化标准化 \n7. 购买生产力\n\n    1. 要按 SOP 分工协作 （资源有限，能力不同，减少切换时间）\n    2. 要 边际收益 ＞ 边际成本    边际：指的多增加一个单位\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654265907963-3316532a-05dd-4486-beeb-b976e7a272eb.png)​\n\n8. 技术进步\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654265956233-36430964-0737-4336-9bc6-8f42ac00adf1.png)​",
                    "title": "做事的步骤"
                  },
                  {
                    "path": "1.methodolgy/写演讲稿.md",
                    "content": "#docs/how-to-guides \n\n利用 [[POP]] 理论\n## 调研受众\n- 找到关注点\n- 揣摩听众心理\n- 穷尽听众可能疑问\n## 标题\n-   有信息,总结要点\n-   简单,量化\n-   主谓宾,正装,动词短讯,口号式语言",
                    "title": "写演讲稿"
                  },
                  {
                    "path": "1.methodolgy/制定目标.md",
                    "content": "#methodolgy  #docs/how-to-guides \n\n1.  定[[目标]]，目标要少\n\t1.  定[[计划]]，计划要细\n\t2.  定沟通机制，沟通要明\n\t3.  定工具，讲方法，工具要简，方法要可重复\n\t4.  定监督机制， 控制要准\n\t5.  定反馈机制，反馈要快\n\t6.  定奖惩机制，奖惩要明\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221224163942133.C3Bdy.jpg)\n\n\n个人工具  ",
                    "title": "制定目标"
                  },
                  {
                    "path": "1.methodolgy/怎么写技术文档？/如何写好技术文档——来自Google十多年的文档经验.md",
                    "content": "#docs/how-to-guides  #docs  #excerpt \n\n\n本文大部分内容翻译总结自《Software Engineering at Google》 第10章节 Documentation。 另外，该书电子版近日已经可以免费下载了  [https://abseil.io/resources/swe_at_google.2.pdf，有兴趣的同学可以下载翻阅下。](https://abseil.io/resources/swe_at_google.2.pdf%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E5%90%8C%E5%AD%A6%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E7%BF%BB%E9%98%85%E4%B8%8B%E3%80%82) 首先声明，本问所说的文档不仅限于纯文本文档，还包含代码注释(注释也是一种特殊形式的文档)。  \n \n\n![如何写好技术文档——来自Google十多年的文档经验_技术文档](https://s2.51cto.com/images/blog/202108/05/23b4ce3043463c1eb95d1b16b9ca2f80.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_750)\n\n \n \n\n## 文档的重要性  \n高质量的文档对于一个组织或团队来说有非常多的益处，比如让代码和API更容易理解、错误更少；让团队成员更专注于目标；也可以让一些手工操作更容易；另外如果有新成员加入的话有文档也会让他们更快融入……\n\n写文档有比较严重的收益滞后性，不像测试，你跑一个测试case，它能立即告诉你是对还是错，它的价值马上就体现出来了。而写一份文档，随着时间的推移，它的价值才会逐渐体现出来。 你可能只写一次文档，将来它会被阅读上百次、上千次，因为一份好的文档可以在未来替你向别人回答类似下面这些问题。\n\n1.  为什么当时是这么决策的？\n2.  为什么代码是这样实现的？\n3.  这个项目里都有哪些概念？\n4.  ……\n\n写文档同样对于写作者也有非常大的收益：\n\n1.  帮你构思规范化API： 写文档的过程也是你审视你API的过程，写文档时会让你思考你API设计是否合理，考虑是否周全。如果你没法用语言将API描述出来，那么说明你当前的API设计是不合理的。\n2.  文档也是代码的另一种展现： 比如你两年后回过头来看你写过的代码，如果有注释和文档，你可以很快速理解代码。\n3.  让你的代码看起来更专业： 我们都有个感觉，只要文档齐全的API都是设计良好的API，虽然这个感觉并不完全正确，但这两者确实是强相关的，所以在很多人眼里，文档的完善度也成为衡量一个产品专业度的指标。\n4.  避免被重复的问题打扰： 有些问题你只需要写在文档里，这样有人来问你的时候你就可以让他直接去看文档了，而不是又给他解释一遍。\n\n## 为什么大多数人都不喜欢写文档？  \n关于文档的重要性，每个技术人或多或少都知道一些，但很多人还是没有写文档的习惯，为什么？ 除了上文中提到的文档的收益滞后性外，还有以下几点原因：\n\n很多工程师习惯将写代码和写作割裂开，不仅仅是在工作上，而且在思想上就认为它们是完全不相关的两项工作，这就导致好多人重代码不重文档。  \n也有很多工程师认为自己不善写作，索性就不写了。 这实际是个偷懒的借口，写文档不需要华丽的辞藻、生动的语言，你只需要将问题讲清楚即可。  \n有时候工具不好用也会影响的文档写作。如果没有一个很好的写作工具将写文档嵌入到开发工作流程中的话，写作确实会增加工作的负担。  \n大多数人将写文档看做是工作的额外负担。 我代码都没时间写，哪有时间写文档！，这其实是错误的观念，文档虽然前期有投入，但能让你代码的后期维护成本大幅降低，磨刀不误砍柴工这个道理相信大家都还是能理解的。\n\n## 如何产出高质量文档  \n既然理解了好文档的重要性，我们如何保证在时间的长河中维护好一份文档，这里有些相关的方法论，大家可以参考下。\n\n## 像管理代码一样管理文档  \n对于如何写出好代码，整个技术圈已经有好多经验的总结了，比如书籍《重构》《代码简洁之道》…… 针对各种编程语言，也有相关的规范，比如国外的Google C++规范，国内的阿里Java开发规范等…… 但对于文档 似乎相关的资料却很少。但实际上，不应该把文档和代码割裂开来，你可以简单粗暴地认为文档其实就是用一种特殊语言书写的代码，这种语言就是人类的语言。这么想的话，实际上我们很多在代码和工程中总结出来的经验，也可以直接用在文档中，比如：\n\n1.  有统一的规范\n2.  有版本控制\n3.  有明确的责任人维护\n4.  有变更Review机制\n5.  有问题的反馈和更新机制\n6.  定期更新\n7.  有衡量的指标(比如准确性，时效性)\n\n## 明确你的读者是谁  \n写文档有一个很常见的错误，那就是很多人文档都是写给自己看的，这种情况下就会导致你的文档只有自己或者和你有相似知识背景的人才能看懂，团队较小时这种问题还好，你们都做着类似的工作，所以也都能看懂文档。但当团队逐渐壮大后，问题就会凸显出来，新人有时候有着和你不同的工作背景，甚至现在都做着不同的工作内容，这时候你之前写的文档他们就很难读懂了。\n\n所以在写文档之前请明确你文档可能的读者会是哪些人，然后针对他们的特点着重关注如何才能让他们理解。当然，文档也不一定要非常严肃和完美，只要能向你潜在的读者说明问题即可。 记住文档是写给别人看的，不是给自己看的。\n\n根据专业水平可以大致将读者分为三种 新手、老手和专家，针对不同水平的人写作需要有侧重点。比如针对新手，你需要重点介绍下里面涉及到的术语和概念，然后详细讲解具体的的实现。相反，针对专家 你可以省去这些额外的信息。注意，这里没有严格的标准，因为有些文章新手会看，专家也会看， 这里还是需要具体情况具体分析。\n\n另外一种对读者分类的方式就是根据读者阅读文档的目的来分类，比如有人知道自己遇到了什么问题，就是来找解决方案的。还有一批人只有一个简单的想法，但不知道具体的问题。举个例子，以读数据库慢为例，前者已经知道数据库慢可能是因为数据量巨大且没有加索引，解决方案很简单 加索引，这时候他可能需要知道的是如何正确地加索引。而后者可能着重关注的是为什么读数据库会慢，这时候你可能需要额外重点介绍下数据库相关的原理。\n\n## 清晰的分类  \n文档大致可以分为以下几种类型，每种类型也有自己不同的特点和写作侧重点。\n\n### 参考文档  \n参考文档也是大部分开发人员日常会使用和书写的文档，比如我们使用某个框架或者工具，都会有API说明文档，这就属于参考类文档。 它并没有太多的要求，只要能向读者展示清楚如何使用即可，但无需向读者讲明具体的实现。\n\n注：参考文档并不仅限于API文档，还包括文件注释、类注释、方法注释，要求都是能准确说明其用法。\n\n### 设计文档  \n很多公司或者团队在项目开始前都要求有设计文档，设计是项目实施的第一步，所以在设计文档书写的过程中要求尽可能考虑周全，例如该项目的存储、交互、隐私……\n\n好的设计文档应该包含以下几个部分：\n\n1.  设计目标\n2.  实现的策略\n3.  各种利弊权衡和具体决策\n4.  替代方案\n5.  各种方案的优缺点\n\n写设计文档的过程也你对整个项目做规划、思考可能出现问题的过程，设计的越详细、思考的越多，未来遇到问题的可能性就会越小。\n\n### 引导类文档  \n引导类文档也很常见，一般都是Step by Step的形式。比如我们在使用某个框架或者工具的时候，一般都会有个引导类的文档一步一步帮助你快速上手。 大家写引导类文章大家非常容易犯的一个错误就是预设了很多背景知识。 一般使用文档都是有开发者写的，他们都非常了解这个工具的相关的知识，所以习惯性的会认为，啊 这个知识点很简单 用户也肯定会吧，实际上用户不一定会。这本质上就是一种认知偏差，这种现象在跨团队协作 尤其是多端协作的时候也非常明显。\n\n这类型的文档写作中，要求写作者尽可能站在用户的视角上思考，极力避免出现和用户的认知偏差，力争每个步骤做到明确无歧义，每两个步骤之间做到紧密衔接。\n\n### 概念性文档  \n当参考文档无法解释清楚某些东西的时候，就需要概念性文档了，比如某个API的具体实现原理。其主要是为了扩充参考文档，而不是替代参考文档。有时候这和参考文档会有些内容重复，但主要还是为了更深层次的说明某些问题、解释清楚某个概念。\n\n概念性文档也是所有文档中写作最难的，也是被阅读最少的，所以很多情况下工程师最容易忽视。而且还有另外一个问题，没合适的地方放，参考文档可以写代码里，落地页可以写项目主页里，概念性文档似乎也只能在项目文档里找个不起眼的角落存放了。\n\n这类文档的受众会比较广，专家和新手都会去看。另外，它需要强调概念清晰明了，因此可能会牺牲完整性(可以由参考文档补齐)，也有可能会牺牲准确性，这不是说一定要牺牲准确性，只是应当分清主次，不重要的就没必要说了。\n\n### Landing pages(落地页)  \nLanding pages就先简单翻译成落地页了，没想到啥恰当的翻译词。比如一个团队或者项目的导航页，虽然没啥具体的内容，但应该包含其他页面的链接。 比如你新入职一个团队，比较成熟的团队都会扔给你一个文档，这个文档里包含常用的工具、文档链接，这就是这个团队的落地页。  \n落地页的问题就是随着时间的推移，页面可能会变的越来越乱，而且有些内容会失效，不过这些问题都好解决，做好定期的维护和整理就行。  \n落地页的技术难度不高，但要求内容的有效性、完整性和分类清晰。\n\n## 文档Review  \n在一个组织内，光靠个人去维护文档是不行的，必须得借助群体的智慧。在一个组织内部，文档的变更也应该像代码的变更一样，需要被其他人Review，以提前发现其中的问题并提升文档的质量。\n\n如何Review文档：\n\n1.  专业的视角来保证准确性： 一般由团队里比较资深的人负责，他们关注的核心点是文档写的对不对，专不专业。如果Code Review做的好的话，文档的Review也属于Code Review的一部分。\n2.  读者视角保证简洁性： 一般由不熟悉这个领域的人来Review，比如团队的新人，或者文档的使用者。这部分主要是关注文档是否容易被看懂。\n3.  写作者视角保证一致性： 由写作经验丰富或者相关领域比较资深的人承担，主要是为了保证文档前后是否一致，比如对同一个专业术语的使用和理解是否有歧义。\n\n## 写文档的哲学  \n上面部分站在组织和团队的视角来看如何提高文档质量，我们接下来看看站在个人写作者的视角上如何写出高质量的文档。\n\n5W法则  \n5W法则相信大家已经听的多了，分别是Who What When Where Why，这是一个广泛被用在各行各业的法则，写文档当然也能用（5W法则堪称万金油，啥地方都能用）。\n\n1.  WHO： 前面已经说过了，文档是写给谁看的，读者是谁。\n2.  WHAT： 明确这篇文档的用途，有时候，仅仅说明文档的用途和目的就能帮你搭建起整个文档的框架。\n3.  WHEN： 明确文档的创建、Review和更新日期。因为文档也有时效性，明确相关日期可以避免阅读者踩坑。\n4.  WHERE： 文档应该放在哪！ 建议一个组织或者团队有统一的永久文档存放地址，并且有版本控制。最好是方便查找、使用和分享。\n5.  WHY： 为什么要写这篇文档， 你期望读者读完后从文档中获得什么！\n\n### 三段式写作  \n写文章一般都会有三个部分，专业写作者也讲究凤头、猪肚、豹尾，这三个词概括出了好文章三部分应有的特点。技术文档也算是文章的一种，所以一般也都会有这三部分，每个部分有其自己的作用，比如第一部分阐述问题，中间部分介绍具体的解决方案，第三部分总结要点。 但这也并不以为着文档应该有三个部分，如果文档内容比较多，可以将其做更细致的拆解，可以适当增加一些冗余的信息帮助读者理解文档内容。虽然很多工程师都讨厌冗余 极力追求简洁，但写文档和写代码不同，适当的冗余反而可以帮助读者理解，很简单，举个例子，比如写作中经常举例子，举的例子本质上就是冗余信息，生动的例子肯定是能帮助读者理解抽象内容的（我想这就是自举 吧）。\n ",
                    "title": "如何写好技术文档——来自Google十多年的文档经验"
                  },
                  {
                    "path": "1.methodolgy/怎么写技术文档？/如何编写技术文档.md",
                    "content": "#docs/how-to-guides  #docs  #excerpt \n\n文档维护人员必须处理的最大问题是：没有清楚地了解他们应该做什么。 他们不断修订文档，但发现很难让它以令人满意的方式融合在一起。以象限的方式结构化文档，是通过分离文档功能来解决这些问题。这样，文档更易于编写和维护，更易于使用并且可以找到解决方法。\n\n以功能分离结构编写文档，让文档的内容、如何编写、以及如何组织文档更加的清晰。它更好地为用户服务，对于与软件交互的周期中的所有不同阶段，用户将找到适合当时需求的正确文档。\n\n我们有针对对四个象限中的每一个的编写文档有助于吸引和留住更多的用户，他们将更有效地使用如软件，这也是软件提供商最想要的东西之一。\n\n## 技术文档\n文档需要围绕四种不同功能组织：教程、指南、解释和技术参考。每一个都需要不同的写作模式。不同的时间、不同的环境下，我们要用到不同的文档，所以4种文档都需要编写。\n [[../../templates/t-Tutorials]]\n[[../../templates/t-Ho-to Guides]]\n[[../../templates/t-Explanation]]\n[[../../templates/t-Reference]]\n\n按照这样划分，用户有很清晰意识到如何对信息进行组合。作者也知道 怎么写， 写哪些内容 ，写作的导向。同时，为了让这些信息显得更有意义，作者可以花费更多时间在如何挖掘信息上，而不是收集每一类信息。\n\n每一类文档只有一个职能。\n\n事实上，如果我们没有明确或者有意识的识别出文档应用领域，很难编写、维护好一份文档。在文档编写时，任何不区分对象和应用领域的尝试都将事与愿违。\n\n一旦我们接受这种方法(按照职能进行分类)，它变成了一个非常有用的工具：用于分析现有的文档,以及如何做去改进它们。\n\n \n\n>你也许有这样疑问：像变更记录、发布策略、以及其他关于项目的信息应该放在哪里？从严格意义上讲，这些内容要放在项目文档中，而不是软件文档中。  \n>只要不把它们和软件文档混在一起，它们就可以被保存在同一文档里。让我们探索这4类文档编写方法。\n\n### 教程\n\n教程一门课程。它通过一系列步骤“手把手”的帮助读者完成某种类型的项目。对项目而言，它是向初学者展示项目的功能。\n\n教程完全以学习为导向，具体来说，它倾向于教授如何学习(learning how)，而不单单是传授学习知识（learning that）。\n\n教程就如同老师，它教授学生以后要怎么做。在教程指导下，学生通过执行一系列的动作来达成某些目标。\n\n教程决定了结果，用户以后的行为。`确定结果和行为包含的内容，可能是一项艰巨的工作。因为`对初学者而言，结果不但是“有意义的”，而且也是“可实现的”、可操作的。\n\n如果以教授孩子做饭为例。教授做饭并不重要。真正重要的是让孩子发现其中的乐趣，获取自信，并且期待再一次尝试。\n\n孩子们通过这样的形式，学到关于烹饪的重要知识。孩子们会了解厨房是什么样子的，如何使用餐具和处理食物。\n\n使用软件，就像做饭一样 是一项技巧。它也是知识——但它是实用的知识，而不是理论的知识。当我们学习一门新手艺或技能时，我们总是从实践中开始学习。\n\n教程的目的是：在学习完成之后。学习者理解应用，以及软件本身。大多数软件项目都有非常糟糕的(或者根本没有)教程。教程引导学习者变成用户。而一个糟糕或缺失的教程将让这部分客户流失。\n\n好的教程很难写好。它即要对初学者非常友好、又容易学习、也要非常健壮。\n\n#### 如何写好教程\n\n##### 让用户通过实践学习\n\n一开始，我们通过实践来学习——就像我们如何学会说话或走路的方式。  \n软件教程就是让用户进行操作和实践。所不同的是教程包含一些工具和由浅入深的操作步骤。\n\n##### 用户实践\n\n初学者开始实践是像婴儿学步一样发自习惯。教程关键点是让学习者* 开始他们的旅程 *，而不是以成功完成所有步骤为目的。\n\n##### 确信教程有效\n\n教程的目的和责任是：是激发、培养初学者的信心:对软件、教程和对他们完成要求的信心。\n\n很多东西有助于达成这个目标。如：友好的语调，语言的连贯使用，以及材料的逻辑合理性。但是最重要的是，你要求初学者做的事情必须是可行的。学习者需要看到你让他们采取的行动有你所说的效果。\n\n如果用户行为产生错误或者不可预料的结果，即使不是教程本身的问题，那么教程也是不合理。当用户和你在一起时，你可以帮助他们;但如果他们是自己阅读文档，你就不能帮助他们—所以你必须提前防止不可预期的问题发生。毫无疑问，这说起来容易做起来难。\n\n##### 让用户立刻看到效果\n\n无论多么琐碎的操作，用户做的每件事都是可理解的。如果用户在看到结果之前必须做很多奇怪的操作或不可理解的事情，那么这一步教程就太长了。每一个实践的结果越快看到越好，和实践和结果的联系也需是明确的。\n\n教程从整体和局部来看，都必须是一个有意义的。\n\n##### 实践过程具备重复性\n\n教程必须是能可靠地重复操作。这很难实现：人们使用不同的操作系统，拥有不同的经验和使用工具能力存在差异。 更重要的是，他们使用任何软件或资源很可能发生变化。所有这些教程都必须支持这些变化。因此，教程需要定期和详细的测试，以确保它们正确。\n\n##### 关注具体步骤，而非抽象概念\n\n教程需要把特定的、特殊的行为和结果具体化。当然，引入抽象的诱惑是巨大的; 毕竟抽象能够解决和解释很多问题。 但是学习过程是从特定和具体到一般和抽象，并且学习者让他们掌握具体内容之前，能够理解抽象层次。这是不好教学例子。\n\n##### 提供最低解释\n\n仅向用户解释为了完成教程需要的知识。扩展讨论很重要 - 只是不在教程中。 对用户而言，解释是理解教程的障碍。 只有最低限度是合适的。 合理的做法是：在需要的地方适度解释。\n\n##### 关注用户需要的实践\n\n教程需要专注于当前的任务。也许您引入的命令有许多其他选项，或者可能有不同方法来访问某个API。 那些都是不必要的。现在，学习者取得进步不需要了解那些无关的内容。\n\n### 操作指南\n\n指南给读者解决实际问题提供所需的步骤。它们就像食谱用来实现特定目标 - 例如：如何创建Web表单; 如何绘制三维数据集; 如何启用LDAP身份验证。这部分说的指南是操作指南。\n\n指南完全是以目标为导向。\n\n如果你想要一个比喻，想想一个要准备食谱。食谱上有清晰明确的菜单，用户明白今天的 菜单列表。指南是在假设用户拥有一些基本知识前提下，来说明如何实现这些目标。\n\n指南与教程完全不同。 它无法解决真正的初学者的问题，不适合初学者。在指南中，假定用户有一些知识 -- 假定用户已经知道如何执行基本操作并使用基本工具。软件文档中的指南可以写的很好， 它们很有趣且易于编写。\n\n#### 如何编写优秀的指南哪？\n\n##### 提供一系列步骤\n\n指南必须包含一系列步骤，需要按顺序执行（就像教程一样）。 你不必从一开始进行操作，只是要在合理的起点。 指南需要可靠的，但它们不需要具有教程的那样严谨的可重复性。\n\n##### 关注结果\n\n操作指南必须注重如何获得结果，其它都是次要的。 与教程一样，它不需要有详细的解释。\n\n##### 解决问题\n\n指南必须解决特定问题。与教程不同的在于：当涉及到操作指南时，可以假设读者知道他们应该实现什么但是还不知道如何做 - 而在教程*负责决定读者需要了解的内容。\n\n##### 不要解释概念\n\n指南不应解释和操作无关内容。不应该在指南进行解释; 解释只会妨碍用户的理解。 如果解释很重要，请在其它地方进行。\n\n##### 适度的灵活性\n\n操作指南允许稍微不同的方式来实现相同的功能。 它需要足够的灵活性，用户看到它将如何应用于与您描述的示例略有不同的示例，或者了解如何使其适应与您假设的略有不同的系统或配置。 除非你想到的确切目的，否则不要具体化。\n\n##### 不要面面俱到\n\n实用性比完整性更有价值。教程需要是完整的，端到端的指南; 指南则没有这样的限制。 它可以在适合地方开始和结束，它也不需要提及所有的内容，只涉及相关联的内容即可。 臃肿的指南无法帮助用户快速获得解决方案。\n\n##### 切题的标题\n\n文档标题要告诉用户它的确切功能。 如何创建基于类的视图是一个很好的标题。但 创建基于类的视图或，基于类的视图则表达文档的功能。\n\n### 解释文档\n\n解释用于澄清和阐明特定主题。 为了让用户理解软件和原理，它*延伸文档对主题说明范围。\n\n解释同样可以描述为讨论。 它从更广的视角，从更高层次甚至从不同角度阐明软件。 解释文档可以在闲暇时阅读，而不用关注代码和实现。\n\n软件解释文档很少明确占据文档的章节，而是作为片段分散在文章中。 有时，解释文档存在于如背景或其他注释，且没有明确解释文档的功能。\n\n解释、讨论不像看起来那样容易编写。当你从问题出发直接解释原因，或者在白纸上，直接写出问题答案的时候，也不是件容易的事情。\n\n解释主体不是根据特定的任务去设定，例如操作指南，或者您希望用户学习的内容，例如教程。 它不是讲原理，比如参考指南。 它是由你认为是一个合理的区域来定义的，因此，解释有时包含主观色彩。\n\n#### 如何编写优秀的解释文档\n\n##### 提供上下文\n\n解释一般在说明背景和连接上下文 - 例如，* Web表单以及如何在Django 或 Search和django CMS 中处理它们。它们解释为什么*事情是如此 - 设计决策，历史原因，技术限制。\n\n##### 讨论替代方案和意见\n\n解释提供替代方案，或问题的不同解决方案。 例如，在关于Django部署的文章中，考虑和评估不同的Web服务器选项是合适的，讨论甚至可以考虑并权衡相反的意见 - 例如，测试模块是否应该在包目录中。\n\n##### 不要指导或提供技术参考\n\n解释包含文档的其他部分没有的功能。这不提供用户如何做某事的解释。 它也不提供技术描述。 这些功能已在其他部分中处理。\n### 参考文档\n\n参考指南是条理性的技术说明及其如何操作的方法。\n\n参考指南唯一的作用就是：叙述。它描述的是：关键类，函数，API等等。所以它列出函数，字段，属性和方法等内容，并说明用法。\n\n参考指南是信息导向，也就是传递信息。参考参考包含示例来说明如何使用，但不应该尝试解释基本概念，或者如何实现通用任务。\n\n参考指南是严肃而中肯(austere and to the point)。\n\n和烹饪做类比，参考指南是百科全书，说明其来源，其行为，其化学成分，如何被烹制等。\n\n参考指南提供一些基本功能：如何使用这种机制 - 如何实例化特定类，或调用某种方法，或者传递给函数时采取的预防措施。 然而，这是其作为技术参考部分功能，它不要与操作指南混淆。\n\n对于一些开发人员而言，参考指南是他们唯一想得到文档。 他们已经了解软件，知道如何使用它。 参考指南是他们认为是提供关于软件的技术信息。\n\n参考材料往往写得很好。 它甚至可以在某种程度上自动生成，只是还做的不够好。\n\n#### 如何编写优秀的参考文档\n\n##### 围绕代码构建文档\n\n参考指南与代码库保持相同的目录结构，以便用户能够代码和文档相互对照。 这也将有助于维护人员查看参考文档缺少的部分或需要更新部分。\n\n##### 一致性\n\n在参考指南中，布局，笔调，格式 与要与同类百科全书或字典的保持一致。\n\n##### 只进行阐述\n\n参考指南的唯一目标是尽可能清楚，完整地描述。 其他任何事情（解释，讨论，指导，推测，意见）不仅会影响阅读，而且会使其更难以使用和维护。 在适当时候，参考可以提供示例用以说明。\n\n如下情况要避免发生：使用参考指南来指导如何进行实现；关于软件使用之外的介绍；不允许对主题的概念或讨论进行解释。 当然，在需要的地方，可链接到操作指南，说明和入门教程。\n\n##### 准确性\n\n文档描述必须准确且保持最新状态。 实现和描述之间的任何差异都将不可避免地导致用户\"误入歧途\"。* *\n\n\n\n关于文档结构\n\n##  文档功能的重叠\n\n以上提到的4个部分，这样的结构清晰而有效，但存在一个问题：文档每个功能(象限)特征与相邻象限特征重叠。如下\n\n ![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221228154917590.VcRSd.jpg)\n\n\n教程和操作指南类似，因为它们都关注描述实际步骤，而操作指南与技术参考交集是我们在工作层面，编码。 参考指南和说明是相似的，因为它们关注理论知识，最后，教程与解释的共同之处在于它们在我们学习时最有用 ，但却不是实际应用：\n因为这些重叠，不同类型文档变得混淆甚至相互混合也就不足为奇了。\n\n大量文档呈现四个象限中一个，按照4个象限完全区分开很难找到，虽然很难找到例子。Django是符合文档结构的例子：[Django](https://docs.djangoproject.com/en/1.11/#how-the-documentation-is-organized) , and [django CMS](http://docs.django-cms.org/en/release-3.4.x/).\n \n \n\n\n\n",
                    "title": "如何编写技术文档"
                  },
                  {
                    "path": "1.methodolgy/怎么写技术文档？/研发过程中的文档.md",
                    "content": "#excerpt  #docs/whatis-why-explanation \n\n \n- 部门文档\n  - 规范制度\n  - 流程标准\n  - 战略规划\n  - 工作总结\n  - 绩效管理\n  - 会议管理\n  - 招聘计划\n  - 新人手册\n  - 知识产权\n  - 文档模板\n- 项目文档\n  - 排期规划\n  - 项目立项\n  - 进度管理\n  - 风险预控\n  - 复盘总结\n- 开发文档\n  - [[../../架构图#系统架构 | 系统架构]]\n  - [[../../架构图#应用架构 | 应用架构]]\n  - 版本排期\n  - 版本设计\n  - 测试用例\n  - 运维手册\n  - [[版本管理]]\n  - 开发规范\n  - 第三方对接\n  - 解决方案\n  - 设计文档\n- 产品文档\n  - 产品矩阵\n  - [[../../架构图#业务架构 | 业务架构]]\n  - 业务线划分\n  - 需求规划\n  - 需求文档\n  - 市场文档\n  - 产品原型\n  - 产品设计\n  - 调研分析\n  - 操作手册\n  - 宣传文档 \n- 运营文档\n  - 运营方案\n  - 产品运营\n  - 用户运营\n  - 活动运营\n  - 私域运营\n  - 內容运营\n  - 媒体运营\n  - 数据分析\n![](https://static001.geekbang.org/infoq/ce/ce6f653cd2884dc7bea4279bee69a0c6.png)\n\n",
                    "title": "研发过程中的文档"
                  },
                  {
                    "path": "1.methodolgy/怎么制定任务.md",
                    "content": "---\naliases: [how to create task]\n---\n#methodolgy  #docs/how-to-guides \n\n利用 [[SMART]] 原则制定.",
                    "title": "怎么制定任务"
                  },
                  {
                    "path": "1.methodolgy/怎么布置任务.md",
                    "content": "---\naliases: [how to assign task]\n---\n#docs/how-to-guides \n\n \n一个[[任务]]，要想布置的很清晰，需要按五步法来进行。 \n\n1.  要有一个能胜任的人 🕺 \n2.  要有明确的完成时间 ⏱️ \n3.  要有明确的完成标准 🚩 \n4.  布置完任务，让员工复述一遍🗣️ \n5.  做好汇报要求，检查进展✅\n\n  \n\n[[目标]]是老板要的。[[计划]]是管理人员定的。[[任务]]是工作人员干的。\n",
                    "title": "怎么布置任务"
                  },
                  {
                    "path": "1.methodolgy/怎么获得权力.md",
                    "content": "#docs/how-to-guides \n\n想有多少[[权力]]，才能有多少权力。 如果你总是在等待别人赋予你权力，你永远都不会拥有它，因为你还没来得及证明你能够运用它。\n先斩后奏获得谅解总是比事先获得批准容易。\n--- [[项目计划，进度与控制]]",
                    "title": "怎么获得权力"
                  },
                  {
                    "path": "1.methodolgy/怎么解决问题.md",
                    "content": "---\naliases: [how to solve problems,解决方案]\n---\n#methodolgy  #docs/how-to-guides \n \n![[怎么解决问题 2022-12-28 12.16.16.excalidraw | 600]]\n\n\n逻辑上 3 步:\n1. 定义问题\n2. 找到方法\n3. 动手去做\n\n## 定义问题\n解决[[问题]]的前提是能够准确的定位问题\n追问为什么导致了这个[[问题]].  直到追问到再也无法追问为止. 形成问题的分层定位.\n当下层无解时，当向上一层寻求答案。 可以采用 [[NLP]] \n\n## 找到方法\n问题清晰了, 接下来就是找方法. \n1. 参考历史最佳实践方法.\n2. 如果历史实践方法不满足需求, 采用 [[第一性原理]] 从本质出发. 找到新方法.\n\n## 动手去做\n1. 根据[[模块]]化的原理分解了同子问题. \n2. 解决问题要尽量解目标层的根本问题. 并采取措施预防当前问题可能带来的重大问题.  \n\n\n\n\n \n\n\n",
                    "title": "怎么解决问题"
                  },
                  {
                    "path": "1.methodolgy/文化影响力.md",
                    "content": "#methodolgy #docs/whatis-why-explanation \n定义一下什么叫文化。\n\n文化，广义指人类在社会实践过程中所获得的物质、精神的生产能力和创造的物质、精神财富的总和，狭义指精神生产能力和精神产品，包括一切社会意识形式：自然科学、技术科学、社会意识形态，有时又专指教育、科学、艺术等方面的知识与设施。\n\n  \n\n什么又叫影响力呢？ 影响力是一种能力，\n\n影响力是用一种别人所乐于接受的方式，改变他人的思想和行动的能力。 影响力又被解释为战略影响、印象管理、善于表现的能力、目标的说服力以及合作促成的影响力等。",
                    "title": "文化影响力"
                  },
                  {
                    "path": "1.methodolgy/有什么能震住场子的脏话.md",
                    "content": "#docs/how-to-guides #social\n \n \n1.别说当面骂你了，你要是听不清，我还能刻你碑上。\n\n2.说话挺脏啊，上厕所没擦嘴吗？\n\n3.别想这么多了，国家不也给你发了身份证吗？\n\n4.你要是真的这么闲的话，找个厂吧。\n\n5.天冷了，多盖点土吧，冻着你了我会心疼。\n\n6.你以为这是菜市场呢？搁这儿挑三拣四。\n\n7.会说话就好好说，不会说话就跟狗一桌。\n\n8.什么牌的塑料袋这么能装呢？\n\n9.你是二维码吗？不扫一下都不知道是什么东西？\n\n10.敦煌来的？壁画这么多。\n\n11.大家都是贵族，为什么就你有病？\n\n12.你家都是你做饭吧，这么会添油加醋呢？\n\n13.最近这么嚣张，认了二郎神当主人了？\n\n14.我知道你是个直肠子但也不能用嘴拉吧。\n\n15.真是乌龟掉盐缸里给你这小王八闲完了。\n\n16.喝了[开塞露](https://www.zhihu.com/search?q=%E5%BC%80%E5%A1%9E%E9%9C%B2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2361623229%7D)吗？怎么张口就拉？\n\n17.真是面子给多了，你都以为自己像个人了。\n\n18.人类进化的时候你躲起来了吗？\n\n19.奇了怪了屎也会说话？\n\n20.我拿你当人看，你却学狗叫？\n\n21.我不是草船，你的箭别往我这发。\n\n22.你脖子上那东西是用来凑身高的吗？\n\n23.钥匙三块钱一把，你配几把？你配吗？\n\n24.子不教父之过，你骂我我的错。\n\n25.你真的是小刀拉屁股，开了眼了。\n\n26.你这是拿棺材板当滑雪板，准备上天了呗。\n\n27.祖上是干厨子的呗？这么会甩锅。\n\n28.狗窜棺材，看给你急的。\n\n绝大多数网上看的，个别几条家乡的俗话，打字出来好像没啥韵味。\n\n补几个网上看到的。\n\n29.小东西，长得挺随机。\n\n30.长得好看的才叫海王，你这顶多叫水鬼。\n\n31.希望你吃饭有人喂，走路有人推。\n\n32.真羡慕你脸上的皮肤，保养的真厚。\n\n33.你真的浪费了你爸妈一晚上的时间。\n\n34.你当初是智商跟脐带一起剪了吗？\n\n35.有空一起吃鱼，你挺会挑刺的。\n\n36.你这样想也正常。（任何时候怼人，当面从上扫到下，效果奇佳）\n\n37.你[山海经](https://www.zhihu.com/search?q=%E5%B1%B1%E6%B5%B7%E7%BB%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2361623229%7D)哪一页啊？\n\n38.咋的？人家裹脚，你裹脑呗？\n",
                    "title": "有什么能震住场子的脏话"
                  },
                  {
                    "path": "1.methodolgy/演讲.md",
                    "content": "#docs/how-to-guides  \n\n## 准备阶段\n- [[写演讲稿]]\n- 预演，控制时间节奏\n\n## 演讲阶段\n- 新的一页停3秒\n- 尊重听众权利\n- 问题无法解答的, 记下\n\n让听众\n-   学一下\n-   乐一下\n-   哇一下",
                    "title": "演讲"
                  },
                  {
                    "path": "1.methodolgy/短的时间里了解并分析一个行业.md",
                    "content": "#docs/how-to-guides  #business \n \n对于一个新手来说照着思维导图上的内容按图索骥分析下来，还没分析完外部环境估计人已经晕了\n\n**对着密密麻麻的内容，按部就班地分析就和从a开始背单词背到abandon就结束了一样，有用但不实用**\n\n而真正实用的方法应该是可以让新人在一个极其简单的方法论的基础上最终能自发地建立出一整套完整的分析框架的\n\n**而这方法论非常的简单，就是思考及分析的时候要“由低维到高维，由小及大，由点及面”**\n\n而对于行业分析，其实就是这样的一个思考框架\n\n**Part 1 由小及大（代入式思考：业内人士视角）**\n\n*环节1：分析行业内的一家头部公司（关键词：收入&成本）*\n\n*环节2：分析整个行业（关键词：竞品对标）*\n\n**Part 2 由点及面（跳出式思考：外部人士视角）**\n\n*环节3：分析行业的目前的趋势（关键词：自我对标）*\n\n*环节4：分析整个行业的周期（关键词：发展&波动）*\n\n任何一个人认识一个事物都是需要一个循序渐进的过程的，行业分析也不例外\n\n**上来连这个行业里的一家公司是怎么赚钱的都搞不明白，就直接分析趋势及周期基本就是在痴人说梦了**\n\n**当然，只分析和了解公司挣钱的逻辑，完全不考虑大方向即趋势和周期，这对于整个行业分析来说也是不完整且缺乏思考深度与高度的**\n\n接下来，我们来分别聊聊每个环节具体该怎么思考\n\n---\n\n## **Part 1 由小及大（代入式思考：业内人士视角）**\n\n这部分最关键的就是你需要学会代入式思考\n\n**很多人做不好公司及行业层面的分析，最关键的一点原因就是分析的时候永远都置身事外，从外部者的角度去分析**\n\n但事实上你不真正地把自己代入进去成为这一行业的一个玩家，你很难切身去体会这个行业关键点在哪里？\n\n**环节1：分析行业内的一家头部公司（关键词：收入&成本）**\n\n为什么选一家头部公司呢，道理很简单，头部公司的信息最容易收集，方便自己做分析\n\n好了，现在把自己想象成为这一行业的一个头部玩家，你开这家公司的原因很简单，就是为了赚钱\n\n**而赚钱的核心是买卖，你需要把你生产的东西卖给需要它的人，当然你生产的东西是需要成本的，因此在这一环节，你只需要弄清楚4个问题**\n\n> *问题1：你的产品是什么？*  \n> *问题2：你卖给谁？*  \n> *问题3：每个产品的价格是多少？*  \n> *问题4：你的成本是什么？*\n>\n\n其中123与收入有关，4则与成本有关\n\n举个例子，假设你是一家新式茶饮公司的老板，想一想你的产品是什么？Emmm，茶饮和面包\n\n那卖给谁呢？如果从销售渠道分的话那就是点外卖的人和路过店的人，如果按照年龄来分那又是巴拉巴拉，再按照性别来分那又是巴拉巴拉\n\n价格多少呢？一杯茶25-35元，一个面包大概15-30元\n\n那你的成本是什么呢？租金、员工费用、原材料成本等等\n\n**作为老板，你一定想赚更多的钱，想赚更多的钱，无非就是提高收入或减少成本，那针对之前的4个问题，又演变为以下4个问题。**\n\n> *问题1：我是否要新增产品或者减少产品？*  \n> *问题2：我如何扩展我的消费群体和对象 ？*  \n> *问题3：我是否要调整定价？*  \n> *问题4：我怎么节省我的成本？*\n>\n\n**那在解决这4个问题之前一定需要知道我收入与成本的构成是什么，才能针对性地去提升，简单说就是搞细致，go to detail**\n\n因此关于收入你需要将你的产品拆分详细，拆得不能再拆了，然后再看每一个产品的运营效率究竟如何\n\n例如，茶饮分为奶茶、果茶、奶盖茶等等，面包又分为现制烘焙和预制烘焙，现制烘焙又分为A类面包、B类面包等等\n\n那它们又分别都是卖给谁的，定价分别又是多少？销量如何？客户满意度怎么样？\n\n而成本上最常见的拆分方法法就是固定成本与[可变成本](https://www.zhihu.com/search?q=%E5%8F%AF%E5%8F%98%E6%88%90%E6%9C%AC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)，固定成本包括租金，设备，员工等，可变成本则包括原材料成本，制造成本，物流成本等\n\n最后再两者结合起来看看自己每一类业务的利润情况，评估自己赚钱的情况，什么是容易赚的，什么又是辛苦钱\n\n等你把以上这些问题都了解清楚了即搞懂了我钱怎么来，我钱又花到哪里去，哪些钱容易挣，那基本上你算是对这个公司入门了\n\n**通常来说，分析这些可以从这家公司的三张表出发，对于业务层面的理解最高效的方式就是阅读[招股说明书](https://www.zhihu.com/search?q=%E6%8B%9B%E8%82%A1%E8%AF%B4%E6%98%8E%E4%B9%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)**\n\n如果这个行业没有一家公司上市，咨询公司通常的做法是进行专家访谈、Cold Call以及实地调研，来帮助自己了解以上的问题\n\n**环节2：分析整个行业（关键词：竞品对标）**\n\n搞清楚了前面的4个问题，你对自己有了一个比较基本的了解，但依旧很难解决之前的那个问题，我怎么去赚更多的钱？\n\n这是因为行业里并不只有你一个玩家，你需要对标才能帮助你去做决策。\n\n**那对标什么呢？依旧是前面分析的4个问题，只是对象变了，你需要弄清楚你的竞争对手是怎么做的，成功的地方“比学赶帮超”，失败的地方引以为鉴就对了**\n\n> *问题1：竞争对手的产品是什么？产品线是比我多，还是产品更精简？*  \n> *问题2：竞争对手的用户是谁？有没有挖掘出我之前没想到过的用户群体？*  \n> *问题3：竞争对手的定价策略是什么？是不是走高端线，或者都是低端线？*  \n> *问题4：竞争对手的成本是什么情况？成本多少，又是如何削减成本的？*\n>\n\n在分析完以上这些问题，你对整个行业开始有了相对清楚的认知，你知道玩的最好的玩家好在哪里，你也知道玩的最差的玩家差在哪里\n\n**但此时的你还是站在公司的维度，而分析到这里你需要提升一个维度了，你需要把所有在这个行业的玩家捏合起来进行总结**\n\n把他们看成一个整体进行分析，这时候你最需要知道什么呢？\n\n你需要了解自己——弄清已知，了解外界——弄清未知\n\n**总结来看依旧是4个问题，2个内部问题，2个外部问题**\n\n> **内部问题：**  \n> *问题1：这行的关键成功因素是什么？*  \n> *问题2：这行自身最大的风险是什么？*  \n> **外部问题：**  \n> *问题3：这行的市场规模有多大？还能再大吗？这关系到增量*  \n> *问题4：这行的护城河是什么？新玩家进来会轻松分我的蛋糕吗？这关系到存量*\n>\n\n关于这环节，建议从阅读媒体新闻开始入手，有了一个基础认识之后再去阅读专业机构的报告，例如咨询公司的报告以及券商的行业分析报告\n\n弄清楚以上这些，第二环节也算是入门了\n\n## **Part 2 由点及面（跳出式思考：外部人士视角）**\n\n到了这阶段的你，对自己的公司和行业已经有了一个基本的认识了，而这时候你需要切换自己的思考方式，从代入式思考转变为跳出式思考\n\n因为在接下去的两个环节，你将更多地关注大方向上的东西，如果依旧采用代入式思维，很容易陷在纯粹的买卖之中\n\n**环节3：分析行业目前的趋势（关键词：自我对标）**\n\n前面两个环节，都是专注于一个时间点由小及大地进行分析，接下去的两个环节，则需要加入时间维度，由点及面地进行分析\n\n第3环节其实非常简单，是一个启发环节，为第4环节做铺垫\n\n**这一环节主要做的就是自我对标，自己和自己比，总结来看是以下3个问题**\n\n> *问题1：这个行业目前和过去3-5年比，怎么样了？*  \n> *问题2：行业是增长了还是下滑了？*  \n> *问题3：导致这一现象的原因是什么？*\n>\n\n举个例子，2009年钢铁价格史无前例的高，基本达到5000元/吨，而到了2015年，钢铁价格只有之前的三分之一都不到行业下滑了\n\n原因是2008年大搞基建，钢铁需求空前绝后的高，但之后由于“[凯恩斯主义](https://www.zhihu.com/search?q=%E5%87%AF%E6%81%A9%E6%96%AF%E4%B8%BB%E4%B9%89&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)”的后遗症，导致产能过剩严重，钢铁价格只能一降再降\n\n**自我短时间段的对标分析，会让你发现除去上一阶段最后提到的从自身角度去思考的内外部分析外，事实上还会有其他的因素来影响行业**\n\n这环节的分析则需要更多地参考专业机构的报告以及经济学家的观点了，收集数据并对数据做一些处理分析\n\n**环节4：分析整个行业的周期（关键词：发展&波动）**\n\n为了弄明白第三环节的问题，我们需要再拉大维度来看这个问题，你需要弄清楚以下3个问题\n\n> *问题1：这个行业究竟是靠什么来驱动发展的？（这涉及到行业未来的发展趋势）*  \n> *问题2：是否会受到经济周期或政策的影响？（这涉及到发展时会被经济和政策影响的程度）*  \n> *问题3：目前处于生命周期的哪个阶段（了解目前所处的发展阶段）*\n>\n\n**行业靠什么来驱动发展，可以分为两类，技术驱动与马斯洛需求驱动。**\n\n> *技术驱动：即核心竞争力是靠自己的技术，例如医药、高新科技、人工智能等*  \n> *马斯洛需求驱动：即核心竞争力是为了满足人们那5层需求的，例如现在大家更加追求精神层面的需求，因此很多满足人们精神世界满足的产品未来会发展的更快*\n>\n\n而从经济周期的角度来看，行业可以分为经济周期性行业和非经济周期性行业。\n\n> *经济周期性行业：通常不是生活必须的，例如汽车、钢铁、旅游业等等*  \n> *非经济周期性行业：通常是必需品，例如水电煤等行业*\n>\n\n除了会受经济周期的影响，还会受到政策的影响，例如近期的电子烟以及线上教育\n\n以上这些都是会打断趋势发展的因素\n\n当然，政策和经济周期是最为常见，也是通常必须考虑的发展波动因素，但依旧还有其他的因素，例如环境因素等等\n\n**但一事一议，你需要做的是根据你在前两个环节研究得到的关于行业的特点来进行针对性的思考，而非什么行业都来把所有的外部因素都研究一遍**\n\n好了，终于到最后一步，分析目前处于生命周期的什么阶段，即导入期、成长期、[成熟期](https://www.zhihu.com/search?q=%E6%88%90%E7%86%9F%E6%9C%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)、衰退期，这一步相对来说也是最简单的一步了\n\n这环节在分析时需要更多地参考创投行业的报告，还要对经济周期的波动历史有一定了解并在这一过程中补充自己欠缺的经济学知识\n\n通过以上4个环节的分析，对于一个行业的分析基本上来说是算入门了\n\n**当然以上每个环节所列举的问题仅仅是核心问题，以启发为主，更重要的是顺着这个思路分别站在业内人士和外部人士的角度去问自己更多的问题来帮助自己完善对于行业的理解**\n\n---\n\n那前面提到的这些信息我去哪里获取呢？\n\n**这里我和大家分享一下咨询公司一般获取数据和信息的途径，通常对于咨询公司来说，一般分为一手研究信息和二手研究信息**\n\n**一手研究通常会采用以下几种方式：**\n\n> *方式1：问卷*  \n> *方式2：专家访谈*  \n> *方式3：Cold Call*  \n> *方式4：Focus Group*  \n> *方式5：实地走访*  \n> *方式6：网站数据爬虫*\n>\n\n二手研究通常就是在公开渠道的各种网站来获取信息了\n\n关于这一块，我为了方便以后自己在做案头研究的时候找资料，我花了一整天的时间梳理了自己常用的网站\n\n用Excel做了一个小工具，把所有靠谱的渠道搜集起来然后做一个dashboard方便使用，我根据自己的使用习惯，将自己要找的信息分为了三类，分别是找数据、找报告以及找资讯\n\n\n\n例如在专业机构报告下，有查询投行/券商行研报告、咨询公司报告以及其他机构及文献的网站\n\n![](https://pic1.zhimg.com/50/v2-578786144898dd92ae76c14aebc12a1b_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n为了方便自己找各类细分行业的报告，我还设立了细分行业报告子类，方便自己查询各个细分行业的资料，**细分行业包括TMT、汽车与出行、零售及消费品、教育、工业等14大行业**\n\n![](https://pic3.zhimg.com/50/v2-8a96b781bce0c00b93aa51edff35e738_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n**当然，这个工具肯定是在没法使用Bloomberg、Wind、Capital IQ等付费数据库或无法在这些数据库上找到自己想要的信息的时候使用的**\n\n如果你或你的公司有这些靠谱的付费数据库，那肯定还是优先使用数据库查询\n\n**但一般来说，二手研究的数据信息会被做一些处理和加工，一手数据的质量通常还是会比二手研究的高不少**\n\n尤其是专家访谈，当然前提是专家靠谱且愿意说\n\n商业的东西其实真的很简单，有时候告诉你，你就是知道，不告诉你你就是不知道\n\n**而这些信息就是高质量信息，懂得人几句话就给你讲透了，这样的信息通常只掌握在少数的大佬手里，而一旦有了这些信息，你对行业就会有更深刻的理解**\n\n**这也就是通常所说的混圈子，随着你的级别与能力越来越高，高质量的信息获取就会更简单**\n\n最后，说实话即便像[咨询公司](https://www.zhihu.com/search?q=%E5%92%A8%E8%AF%A2%E5%85%AC%E5%8F%B8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)那样一整个团队做到了以上所有的这些，也不能说自己摸清了这个行业\n\n只能说帮助你尽可能地了解一个行业，毕竟这世上不可能存在任何人能100%摸清一个行业\n\n**作为一个非行业内人士，能做到以上这些已经尽全力了，接下去再提升对某个行业的认知只能靠时间积淀来提升自己了**\n\n注：关于如何查报告的内容引用自本人文章《[一个工具搞定行业研究](https://www.zhihu.com/search?q=%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E6%90%9E%E5%AE%9A%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D) | 实用工具.03》，欢迎移步搜索\n",
                    "title": "短的时间里了解并分析一个行业"
                  },
                  {
                    "path": "1.methodolgy/笔记管理.md",
                    "content": "#docs \n \n\n## 笔记的目标\n1. 学过的东西不想再学第二遍。忘了能借助笔记快速捡起。\n\t1. 能快速找到。\n2. 结构化自己的知识体系，\n## 分类方式\n本质是组织信息结构的方式。是一对多，还是多对多。\n### 文件夹\n物理分类\n\n\n### 标签\n逻辑分类\n有从这个维度管理笔记的需求。\n\n # 技术产品名称\n\n\n\n\n",
                    "title": "技术产品名称"
                  },
                  {
                    "path": "1.methodolgy/获取流量.md",
                    "content": "#docs/how-to-guides  #marketing/webflow \n\n\n> Learn to sell. Learn to build. If you can do both, you will be unstoppable.\n\n开发人员擅长开发，身边很多开发的朋友，经常开发一些有意思的 App 或者网站，小程序之类的，开发完了放到线上自生自灭，靠天吃饭，其实这种思路是不对的，辛辛苦苦开发了这么久，如果不搞点流量过来试一下，多可惜啊。\n\n## 买流量\n\n其实获取流量最快的方法是买流量，现在流量越来越不好买，我介绍一下我经常买流量的地方，以我自己的经验，我喜欢做面向海外的产品，海外流量主要集中在 Google、Facebook 、Apple 手上，最近 Tiktok 也不错，但是他的流量非常不稳定，有时效果很好，有时效果很差，我的首选还是 Google，Facebook，Apple(主要是app)。\n\n## Google Ads\n\nGoogle Ads 开广告户比较容易，门槛非常低，并且有强大的工具支持，我最喜欢用的是 keywords 选取工具，有时候网站或者 App 的 keywords不知道怎么填写，我也会用这个工具去筛选。\n\n![](https://tutu-1252436247.cos.ap-beijing.myqcloud.com/2021/10/20211023wdJJEr.png)\n\n如我用睡衣(pajamas)去查找相关的 keywords，他就能找到与 pajamas相关的关键词，并且还可以下载下来分析，也可以直接保存到 google 表格。\n\n![](https://tutu-1252436247.cos.ap-beijing.myqcloud.com/2021/10/20211023kFdOnn.png)\n\n可以看到每一个关键词的竞争指数，还有相对的价格，对我来说足够用了。\n\n买流量其实是一个迭代活，就是选择不同的素材，关键词去试效果，预算前期可以少做一些，比如我测试产品的时候，我每天就设 $10 的预算，通过一个月的迭代，我基本上能找到几个不错的词。\n\n## 免费的流量\n\n免费的流量经常去一些专业或者创业相关的论坛里面宣传，国外我用的最多的是 [YC](chttps://news.ycombinator.com/)，有时一个帖子能引来千个试用用户，记得 gitlab 上线后，也是在 YC 发贴，好像第一天就获得了 300 个用户，国内的 [v2ex](https://www.v2ex.com/) 也越来越受人关注了，我看里面就有一个板块是专门用来发布有意思的项目的。",
                    "title": "获取流量"
                  },
                  {
                    "path": "1.methodolgy/追问.md",
                    "content": "#docs/how-to-guides  #dao  \n\n1. 什么导致了这个问题？\n2. 什么导致了问题的原因？\n3. 什么导致了问题的原因的\n\n\n少问引导式回答，要问中立问题。",
                    "title": "追问"
                  },
                  {
                    "path": "1.methodolgy/道法术器.md",
                    "content": "\n#dao  #docs/reference \n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223130305988.nzZ5t.jpg)\n\n\n道， 天道，价值观，主观，抽象，规则束人\n法， 大环境，趋势，人约规则\n术， 方法，最佳实践，无形的方法\n器， 工具，有形的资源。\n\n \n从道到器，每一层都在追求上一层的保护，或者说要受到上一层约束，才能吉。\n\n按道约法，以法生术，循术用器。 才可无利不往。\n\n  \n\n在不同的参考系里，道法术器都可有指向。\n\n  \n\n比如，做人参考系，\n\n搞技术参考系： \n\n道： 逻辑学，数学，模电，数据结构算法\n\n法： 计算机原理，网络原理，\n\n术： 编程思想，面向对象，架构\n\n器： Spring，Intellij 。。。\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223130316276.BezAA.jpg)\n\n\n<span style=\"font-size:100px\">道</span>： 天道，道的力量很微弱，但持久，不以意志为转移，道就是原则，就是不会以外力所左右的，它是自然法则，也是生存状态，它也是事物的发展原理，比如，原子弹没有发生制造出来之前，它的原理3000年是如此，3000年之后也是如此。就像是研究元素周期表的[门捷列夫](https://www.zhihu.com/search?q=%E9%97%A8%E6%8D%B7%E5%88%97%E5%A4%AB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1685864090%7D)，元素周期表，没有出现之前，都是有规律的，但是他把规律找出来了，那么这就是道。也就是说新陈代谢，DNA，这些都是道，生老病死，万事万物的发展规律，自然演变，春夏秋冬，都是道。\n\n道包含主观价值观，也包含客观物理规律。\n\n  \n\n<span style=\"font-size:80px\">法</span>： 法律，规章，社会制度。 人为的多数人规则，可改变，但阻力很大，能借力最好，不能得有足够的理由与实力去改变。\n\n  \n\n<span style=\"font-size:60px\">术</span>： 个人的方法，策略。 可加速效率， 只要你肯学肯用。人人平等。\n\n  \n\n<span style=\"font-size:50px\">器</span>： 工具，可加速效率， 只要你肯学肯用。人人平等。\n\n\n\n简而言之，可总结为：遵循事物的发展规律，确定自身的发展方向、 愿景和战略；策划制定符合事物规律、规避风险和实现愿景的目标、方法、方案、行动路线；在“道法”的统御下，具体策划制定具体实施的技术层面的方法、技巧，以有效的做好每一件事；并在做事时使用适宜的工具器具，以保证达到“术”的结果，提高“术”的效率。\n\n",
                    "title": "道法术器"
                  },
                  {
                    "path": "3.读书笔记 /任务太多，时间不够怎么办.md",
                    "content": "---\naliases: [fota]\n---\n#docs/how-to-guides \n\n1. Focus 聚焦要事\n2. Ordering 梳理日程\n3. Three timelines 三线并进\n4. Adapt to change  随机应变\n\n## 聚焦要事\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654266203326-19acd37e-8d72-4e6e-a8b0-79e66c06ed97.png)​\n\n每天大部分时间要做重要但不紧急的事， 这样紧急的事就会越来越少\n\n不重要的任务应该授权他人做，或者直接放弃。\n\n重要的事（任务）的定义：具有累计效应，对未来影响深远。\n\n任务分类：\n\n1. 建设任务， 0 到 1的过程\n2. 运营任务， 1 到 n 的过程\n\n建设任务的拆解：\n\n战略层，架构层，模块层，功能层，表现层\n\n运营类任务是基于建设性任务的运营工作\n\n此时，系统已存在，运营的任务就是要保证这个系统正常甚至更好的运行。\n\n首先要找出系统的关键点， 比如系统运营简化成如下的图\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654268092089-c8eacee4-db09-42b2-8b47-b80c7824c1e8.png)​\n\n比如运营的主要任务就是要增加客户量。 \n\n怎么找出关键任务：\n\n1. 推动增强回路，比如上面的“宣传量”与“客户量”\n2. 消除风险因素，比如降低管理复杂度\n\n总结一下就是：\n\n所谓重要任务：\n\n1.  建设任务，前2-3层 战略层，架构层，模块层。\n2. 运营任务，增强回路任务，风险消除任务。\n\n把时间放在这个上面。\n\n## 梳理日程\n\n使用 [[GTD]]\n\n人的精力有限，尽量顺应自己的生物钟。\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654270881361-6e3af055-57d2-4e13-aef8-93d9f85938d0.png)​\n\n## 三线并进\n\n1. 主线任务处理，独占时间，全力以赴\n2. 支线任务处理，可以与其他事并行， 如吃饭时回复好友信息。\n3. 购买处理能力，约定截止时间，与交付质量标准。\n\n    1. 购买价值， 如 app UI 设计，我自己不会， 但我找人设计\n    2. 购买效率，如 app 开发， 我自己也会， 但找别人开发\n\n## 随机应变，定期回顾\n\n正处于任务中的你， 要随时回顾你得目标是否还清晰。有没有跑偏。 要时刻校准。\n\n有可能目标消失，环境变了，支撑原来的目标价值前提条件没了， 要懂得放弃。",
                    "title": "任务太多，时间不够怎么办"
                  },
                  {
                    "path": "3.读书笔记 /如何判断一件事是否正确.md",
                    "content": "#methodolgy #docs/how-to-guides \n\n1. 对方的利益。 要记住， 成功是别人给的。\n2. 我的利益， 才能坚持\n3. 时机\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654236739280-37bd7a86-f2c0-4bf5-a08e-2df4b29dfb97.png)​",
                    "title": "如何判断一件事是否正确"
                  },
                  {
                    "path": "3.读书笔记 /如何成为一个顶尖的高手.md",
                    "content": "#docs/how-to-guides  \n\n设计让自己进入[[../心流|心流]]的回路，[[../刻意练习|刻意练习]]\n\n---\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654236194366-299ad634-f214-45c2-892d-bbf8fffa7404.png)​",
                    "title": "如何成为一个顶尖的高手"
                  },
                  {
                    "path": "4.架构设计/IO Basics.md",
                    "content": "#linux #docs/whatis-why-explanation \n我一直想写一篇关于  IO 的文章. 来厘清现在各种形容词组合搭配的 IO 关系(同步/异步,阻塞/非阻塞).也帮助自己记住这些概念. \n\n搜了一下网上相关的文章.直接扔定义的比较多.还是值得写一写.\n\n要讲清楚 IO 这坨东西. 将按如下章节说明.\n1. user space & kernel space \n2. multiplexing\n   1. select \n   2. epoll\n   3. aio\n      1. reactor & proactor\n3. 各种 IO 的名称\n4. 结语\n\n> poll 是对 select 的改进, kqueue 与 epoll 类似.   \n\n# arch-io-基本\n这两跟 IO 有很密切的关系。\n中文翻译为用户空间与内核空间，啥意思呢？\n\n内核空间：系统管理的内存。用户可以通过 system call 操作内核空间。\n用户空间：用户自己写的代码管理的内存。\n\n你把 linux 想像成一个超大的类，它暴露了 api 给你操作它的数据。但你是不能直接修改它的数据。 \n\n而对 IO 的操作一般为分两步，比方说 Input。\n1. 内核将输入放入kernel space。\n2. 用户从kernel space。 获得输入数据到 user space。\n\n\n> 除非你有非常特殊的原因，你也可以使用 mmap。直接操作 kernel space。 \n\n# multiplexing\n啥意思？multiplexing 翻成中文技术术语叫多路复用。plex 是堆叠的意思。维基这张图很能说明概念\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-06-09-54-17.png)\n就是 n 个信息打包成一个信息，这一个信息还不会丢失 n 个信息的数据。\n举个代码的例子：\n我们经常用的比特操作，（0001 | 0010 | 0100）  = 0111 = 7 \n那这算是 3 路复用，得到 7. 而 7 又能还原成 0001，0010 ，0100。 \n\n而在网络里.一台服务器,有两个客户 socket 要进来.如果你与其中一个客户建立了连接, 在普通情况下,你没法在不断开前一个客户连接的情况下，与另一个客户也建立连接. 让 1 个 socket 能够同时为多个 socket 服务.就是网络的 multiplexing。解决的方法有很多:\n比如:\n1. 你可以为每一个连接开一个线程. 缺点是连接一多，内存压力太大.\n2. 不用线程,也可以在非阻塞的 socket 上一直轮询,\b\b缺点是连接一多,cpu 压力太大.\n\n\n上面两种方法,在不改 linux kernel 的情况下都能达到 multiplexing 目的. \n而为了解决譬如以上的提到某些缺点，select 出来了.  \n\n\n## select \n它在 application 与 kernel 之间放了一块空间\n1. application 将 IO 设备写到这，然后阻塞。 IO 设备的状态也会被清空。\n2. kernel 也会在某个 IO 设备可读可写,或出错时,在这块空间上扫一遍，看有没有相同的 IO 设备。有的话将事件写上，并给一个 syscall 让 application 等的这个线程醒来。\n3. application醒了也需要再扫一遍这块空间，看哪个 IO 设备有新事件了。 \n4. 如此循环。。\n\n\n所以,两边都瞎.都要扫描。\nselect 最多 FD_SETSIZE 个 fd（fd 是一个数字，当它是一个 key，关联着对应的 value，通常是一个 file）. FD_SETSIZE 是一个编译器的常量，是在 glibc/bits/typesizes.h 里定义的，描述了能放多少 个 fd 到 fd_set。在 32位下,FD_SETSIZE 通常是 1024. 我们看它的这块 buffer 的数据结构.\n\n``` c\nstruct fd_set {\n    int count;\n    struct fd_record {\n        int fd;\n        bool check;\n    } fds[FD_SETSIZE];\n};\n```\n看一下 c 里的接口方法\n``` c\n# nfds： 你要监控的最大的 fd 号。作用是扫描时，可以确定最大值。 从0 到 ndfs，能少则少点。。\n# readfds writefds exceptfds：  分别为需要监控的 fd们（读，写，异常）。\n# timeout： select 为阻塞函数，timeout可指定阻塞超时时间。\n# 返回值为发生事件的 fd值。\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n           fd_set *exceptfds, struct timeval *timeout); \n```\n\n其他语言的封装也大同小异，看一下python\n```python\n# 返回值略微不同，是 3 个数组。可以同时返回多个相同事件的 list。\ndef select(self, rlist:list, wlist:list, timeout:list)->(list,list,list):\n```\n\n我们写个 demo，用 python 3写一个微缩版的 EventLoop\n``` bash\n# 先在命令行起一个简单的服务器\n# nc 命令一般自带，没有的话安装一下 netcat\nnc -l -k 1234\n```\n运行以下 python 代码\n``` python\nimport socket\nimport select\nimport sys\nconnection = socket.socket()\nconnection.connect(('localhost',1234))\n\nwhile True:\n    readers, _ ,_ = select.select([sys.stdin,connection],[],[])\n    for reader in readers:\n        if reader is connection:\n            print(connection.recv(1000).decode('utf8'))\n        else:\n            msg = sys.stdin.readline()\n            connection.send(msg.encode('utf8'))\n```\n就能实现全双工的聊天了，再多点代码，就能多用户跟服务器聊了。。\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/d.gif)\nselect 缺点很明显:\n1. 连接数量支持有限.\n2. 连接越多,性能越差.性能为 O(n).\n3. 而且每次都得重置这块空间.\n4. 需要用户自己读数据。\n\n \n\n而 poll 跟 select 很像,解决了 select 的第 1 个缺点（连接数量限制）. 其他两个缺点依旧. \nselect/poll 的性能是 O(N),能不能到 O(1)呢?\n\n\n## epoll \n 要规避 select 的第 2 个缺点.就差一个通知了.某个 IO 设备可读可写或出问题,kernel 你直接通知 application 是哪个 IO 设备不就好了! 而且顺带着能优化第 3 个缺点。\n\n我们看 epoll 的 python 关键使用代码.\n```  python\n# server_socket 是服务器监听的 socket \n# server_socket.fileno() 代表 IO 设备号,或者更准备点叫文件描述符\n# select.EPOLLIN 代表当有数据可读时通知你\n# select.EPOLLET 代表只通知一次. 不读下次就可能没了. （ET 表示 Edge Trigger。相对的还有 Level Trigger。搞信号的同学应该很懂这个）\nepoll.register(server_socket.fileno(),select.EPOLLIN | select.EPOLLET)\n\nwhile True:\n# poll()当 poll 有任何 io 事件时,就会返回 fd_events. 这是一个list.\n# 每个 item 是一个 fd 与 event 事件. \n    fd_events = epoll.poll()\n    for fd,events in fd_events:\n        ...\n\n```\nepoll 与 select/poll 用起来其实差不太多。只不过内部实现 epoll 做到了 O(1)。\n\nepoll 有哪些缺点呢?\n1. 性能在某些时候也会有问题.如果有 100 个fd 需要更新的话,则需要 100 次系统调用. \n2. epoll 只能用在 file 上. 然后并不是所有的东西在 unix/linux 是文件.定时器不是文件,信号也不是文件,在 linux 上.网络设备也不是文件. 当然你可以将这些模拟成一个文件.但带来了复杂度.\n3. 对磁盘文件支持不好.epoll / select /poll 都是基于 `readiness model`. epoll 可以很好的监控 socket 的可读性.以便接下来的操作不会 block .但磁盘文件只有在内存中不存在缓存时才会 block. 模型不匹配.\n4. 需要用户自己读数据。\n\nkqueue 相对的解决上面的问题。\n\n那相对 select/poll 来说,就一定选 epoll 么.\n也不是,epoll 也带来了新的问题,  见 [linus Torvalds的邮件列表](http://lkml.iu.edu/hypermail/linux/kernel/0010.3/0003.html)\n怎么权衡看官自己决定喽. \n\n\n## aio\nIO 发展滚滚向前。aio 出现了。因为前面说的  select / poll / epoll 都有一个共同的缺点。\n\n**需要用户自己读数据。**\n而 aio 可以看起来像是要解决这个问题。为什么这么说。\n现在的 async IO 是 IO 在`看起来像是内核`里增加 async 功能后的一个名称，但其实是在 glibc 里实现的。 glibc 并不属于内核，但做为普通用户来说，也只是用 glibc 的接口而已。 \baio 的实现可以有很多种，可以使用信号，可以通过线程，也可以通过回调。\n\n我们看 wiki 上一个例子：\n``` c\nios = IO.IOService()\ndevice = IO.open(ios)\n\ndef inputHandler(data, err):\n    \"Input data handler\"\n    if not err:\n        print(data)\n// readSome 直接返回\ndevice.readSome(inputHandler)\nios.loop() # wait till all operations have been completed and call all appropriate handlers\n```\n假如说这段代码是线程 a 在执行，那在 aio 加持下，inputHandler 一定不是由线程 a 执行的。\n> 如果是由线程 a 执行的inputHandler，那说明这就是 non-blocking sync IO.\n\n讲 aio 不能不讲一下 reactor & proactor pattern \n\n### reactor & proactor pattern\nreactor 和 proactor  它们都是 multiplexing 的架构模型。\n它们的最大的区别在于，在于系统是否支持 aio。\n在上面我们写微缩版的 EventLoop， 就是基于 select 实现的 reactor 模型。\n\n所以 aio 到底带来了啥好处？以致于可以多一个 multiplexing 模型命名出来。我们复习一下\n\n前面说的 IO 的操作一般为分两步，比方说 Input：\n1. 内核将输入放入kernel space。\n2. 用户从kernel space。 获得输入数据到 user space。\n\n第 1 步由内核完成。\n第 2 步是要占用用户（application）时间的！ 如果第 2 步要用很久，select 实现的 reactor 模型虽然可以支持 multiplexing，但一样很慢。但如果把第 2 步也交给内核。是不是就会快很多！内核帮你把数据都写好了，你直接用就行了。\n\n> 前面也说了 aio 现在是 glibc 实现的。最大区别在于它占用的不是 application 的时间。而并不是整机性能就比 select/ poll/ epoll 强多少。但对于 application 来说，那可是性能强了很多。 \n\n关于 reactor & proactor pattern 最初的定义可看看这个 [Proactor.pdf](https://www.dre.vanderbilt.edu/~schmidt/PDF/Proactor.pdf)，这里面作者就有 ACE 的贡献者，靠谱点。拿几张图。\n\n我们先看一下 reactor client 连接的图：\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-06-16-32-25.png)\n\n对比一下 proactor client 连接的图：\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-06-16-31-53.png)\n\n \n\n> 总结一把：\n> 1. multiplexing 是一种功能\n> 2. reactor & proactor 是功能的架构\n> 3. select / poll / epoll / aio ... 是架构的具体实现用到的技术\n\n# 各种 IO 的名称\n现在，我们来看一下，因为上面的技术出现的各种花哨的名字!\n\nsync blocking  \nsync non-blocking\nasync blocking \nasync non-blocking\n\n我一直觉得这 4 个组合好牵强.对它们的来源有些好奇。查阅网上资料,维基里有[解释](https://en.wikipedia.org/wiki/Asynchronous_I/O#Forms),然后IBM developerworks也有篇[解释](http://www.ibm.com/developerworks/library/l-async/index.html),然后 stackoverflow 上也各种解释.百花齐放.然而各自精彩.. \n这是wiki的\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-05-22-10-46.png)\n这是 ibm 的文章\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-05-22-11-02.png)\n\n明显矛盾啊.\n在 linux 官网我也没找到有关这 4 个组合的解释.\nblocking ，  non-blocking 的意思还比较没有岐义。等不等。\n但 sync async io 官方的定义在哪？\n\n目录我觉得靠谱的描述就是这本书《The Sockets Networking API: UNIX® Network Programming Volume 1》  这本书作者是 Richard Stevens，参与过很多网络标准的定制，话还是很有份量的。\n\n书里 6.2 章节的图\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-05-22-53-52.png)\n\n书里说在 POSIX 里对 async io 和 sync io 有明确定义。定义啊！\n下图是书里引用的 POSIX 的定义。\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-05-23-09-02.png)\n\n然后我搜了一圈 POSIX 文档。由于这本书是 2003 年出版的。\n找到 [POSIX 2001-2004年](http://pubs.opengroup.org/onlinepubs/009695399/)定义如下\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-06-13-35-46.png)\n\n找到 [POSIX 2001-2018年](http://pubs.opengroup.org/onlinepubs/9699919799/)是这样.\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-05-23-08-30.png)\n\n我们组合看一下。\n一开始 async 和 sync io 的意思跟 blocking  non-blocking 很类似，可以说是一样的。\n后来定义改了，重点在 `process and the I/O operation may be running concrrently`.\n\n我猜个原因。 因为单线程也能够non-blocking，比如 c 里的蝇程， 但它是同步的。\n\n那我们来总结个现在的白话定义。\nsync IO:`process 与 在内核空间的 IO 能够同时运行`。\nnon-blocking IO:`process 调用内核空间的 IO 函数，能立即返回`。\n之所以加上`内核空间`，因为在用户空间，你完全可以自己模拟 non-blocking 与 async IO的功能啊。。只是慢啊。\n\n\n这样再看那 4 个组合，就好理解了。\n\n而我个人也认为 wiki 的图只能说相对更加正确。\n\n\n# 结语\n看完这篇文章，我想大家应该可以对各种语言的 IO 亮点有个所以然的了解了。因为它们或多或少就是 select poll epoll aio 语言层面的封装或者模拟。\n\n# 参考\nhttps://topic.alibabacloud.com/a/about-asynchronous-synchronous-blocking-and-non-blocking_8_8_31087473.html\nhttps://idea.popcount.org/2016-11-01-a-brief-history-of-select2/\n\nhttp://scotdoyle.com/python-epoll-howto.html\nhttps://beesbuzz.biz/code/5739-The-problem-with-select-vs-poll\n\nhttps://notes.shichao.io/unp/ch6/\n\n[底层好文](https://my.oschina.net/editorial-story/blog/3052308)",
                    "title": "arch-io-基本"
                  },
                  {
                    "path": "4.架构设计/redis as MQ.md",
                    "content": "#docs/how-to-guides  #redis #kafka  #excerpt \n\nkafka多牛啊，老少通吃，风光无限，从业务服务到[大数据](https://cloud.tencent.com/solution/bigdata?from=10680)，无所不能。\n\n但，即使它这么牛x，在不少项目中，依然能看到很多的替代品，比如RabbitMQ、RocketMQ、Pulsar等。\n\n等等，先不说这些同质的竞争品。在我见到的很多项目里，经常有一只乱入的[消息队列](https://cloud.tencent.com/product/cmq?from=10680)，那就是Redis。还别说，使用还挺广泛的。\n\n是他们傻？还是单纯的水平不够？\n\n![](https://ask.qcloudimg.com/http-save/yehe-5790360/05e312b63269f1d010d033ecad0a055a.png?imageView2/2/w/1620)\n\n## **Redis很强**\n\n因为Kafka的对手是Redis！\n\nredis很强，满身的肌肉，几乎是万能的。如果你的内存足够大，你甚至可以把所有的数据放到内存中。\n\n除了常见的5种常见的数据结构，Redis还支持非常多的扩展数据结构，其中就有“借鉴”Kafka所实现的Stream类型。\n\nStream就是低配版的Kafka，有Kafka经验的，玩起它来自然不在话下。相对于比较老旧的LPUSH/BRPOP、PUB/SUB模式，Stream在这个场景中完胜。\n\n![](https://ask.qcloudimg.com/http-save/yehe-5790360/7499b644d66c2d7622b005d74134409b.png?imageView2/2/w/1620)\n\n可以看到，Streamn的生产消费模式，几乎和Kafka是一个模子出来的，竟然还有消费组的概念。但Stream并没有Partition的概念，所以它是个低配版的Kafka。\n\n我们来看看官网的说明。\n\nConsumer groups were initially introduced by the popular messaging system Kafka (TM). Redis reimplements a similar idea in completely different terms, but the goal is the same: to allow a group of clients to cooperate in consuming a different portion of the same stream of messages.\n\n## **Redis Can up**\n\n在很多软件开发中，尤其是把软件部署到甲方的机器上，引入一个新的组件，成本是巨大的。这方面，众多外包和OD们应该比较清楚它的凶残。\n\n对于这类系统，甚至是发展势头还不错的中小公司来说，对于消息的需求并没有那么大的要求。与其引入一个新的Kafka组件，不如直接用项目中所存在的Redis组件来完成工作。\n\n我们还是来回顾一下消息队列的作用。\n\n-   **削峰** 用于承接超出业务系统处理能力的请求，使业务平稳运行。这能够大量节约成本，比如某些秒杀活动，并不是针对峰值设计容量。\n-   **缓冲** 在服务层和缓慢的落地层作为缓冲层存在，作用与削峰类似，但主要用于服务内数据流转。比如批量[短信](https://cloud.tencent.com/product/sms?from=10680)发送。\n-   **解耦** 项目尹始，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。\n-   **冗余** 消息数据能够采用一对多的方式，供多个毫无关联的业务使用。\n-   **健壮性** 消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。\n\n不好意思，除了内存容量小一点，上面说的这些需求，Redis的Stream全部能够完成，包括对于缓存系统来说比较难得的持久化，它一样支持。\n\n那还犹豫个毛！怎么简单怎么玩！\n\n## **还有好处**\n\nKafka为了增加吞吐量，可以说用尽了心思。比如，使用Filesystem Cache PageCache缓存来减少与磁盘的交互；使用顺序写来增加写入的吞吐量；使用Zero-copy和MMAP来减少内存交换；使用批量，以流的方式进行交互，直顶网卡上限；使用拉模式进行消息的获取消费，与消费端处理能力相符。\n\n这么一优化下来，虽然功能很强大，但同时膨胀的还有代码加上软件的体积。\n\n对于Redis来说，领域就在内存里玩，不需要这么多花架子就可以达到比Kafka更高的速度。就连partition这个特性，也可以使用不同的Key划分来实现，性能自然是比Kafka高的。\n\n再一个，就是使用简单。\n\n比如XADD指令、XLEN、XRANGE、XREAD等，指令少且好理解，远比Kafka使用简单。\n\n这些优点一汇聚，就不能抵挡它成为MQ中的香馍馍。\n\n## **End**\n\n简单、够用好维护，这么多优点，为什么不选Redis呢？给客户上个又笨又重的Kafka、Pulsar，来给自己添麻烦，何必呢？\n\n当然，以上的评价是对于外包、项目类公司来说的。如果你的公司产品是持续迭代的，持续优化的，又有量，一次性到位选择成熟的额消息队列才是正确的选择。\n\n所以，把Redis的Stream用在正确的项目，正确的地方的人，根本就不傻，他们大智若愚，堪负重任！",
                    "title": "redis as MQ"
                  },
                  {
                    "path": "4.架构设计/怎么拍马屁.md",
                    "content": "#docs/how-to-guides  #social \n\n四字决：一路走来\n例句: xxx， 你这**一路走来**，事业做这么大，一定经历了很多，\n\n鲁豫三连：\n真的吗\n我不信\n后来呢？",
                    "title": "怎么拍马屁"
                  },
                  {
                    "path": "4.架构设计/手写乾坤.md",
                    "content": "#docs/how-to-guides  #handwritten \n \nhttps://www.bilibili.com/video/BV1H34y117fe?spm_id_from=333.337.search-card.all.click\n \n \nhash， 用onhashChange \n \nhistory  监控变化，要用一下方式。\n\n![image-20220530221026889](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220530221026889.png)\n\n\n\n\n\n\n\n沙箱3种实现\n\n\n\nhttps://www.bilibili.com/video/BV1M5411U7GK?spm_id_from=333.337.search-card.all.click\n\n",
                    "title": "手写乾坤"
                  },
                  {
                    "path": "4.架构设计/权限系统设计模型分析（DAC，MAC，RBAC，ABAC）.md",
                    "content": "#docs/reference \n  \n\n> 好久没有更新文章了……这一年过得太忙。\n> 准备一篇个人认为值得拿出来分享的文章真的需要很多时间，如果你喜欢，请评论、点赞让我知道，我会抽更多的时间来更新一些分享给大家，谢谢！\n\n此篇文章主要尝试将世面上现有的一些权限系统设计做一下简单的总结分析，个人水平有限，如有错误请不吝指出。\n\n## 术语\n\n这里对后面会用到的词汇做一个说明，老司机请直接翻到**常见设计模式**。\n\n### 用户\n\n发起操作的主体。\n\n### 对象（Subject）\n\n指操作所针对的客体对象，比如订单数据或图片文件。\n\n### 权限控制表 (ACL: Access Control List)\n\n用来描述权限规则或用户和权限之间关系的数据表。\n\n### 权限 (Permission)\n\n用来指代对某种对象的某一种操作，例如“添加文章的操作”。\n\n### 权限标识\n\n权限的代号，例如用“ARTICLE_ADD”来指代“添加文章的操作”权限。\n\n## 常见设计模式\n\n### 自主访问控制（DAC: Discretionary Access Control）\n\n系统会识别用户，然后根据被操作对象（Subject）的权限控制列表（ACL: Access Control List）或者权限控制矩阵（ACL: Access Control Matrix）的信息来决定用户的是否能对其进行哪些操作，例如读取或修改。\n\n而拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为“自主（Discretionary）”控制。\n\n这种设计最常见的应用就是文件系统的权限设计，如微软的NTFS。\n\nDAC最大缺陷就是对权限控制比较分散，不便于管理，比如无法简单地将一组文件设置统一的权限开放给指定的一群用户。\n\n![img](https://upload-images.jianshu.io/upload_images/594774-6d77f13cc568797f.png?imageMogr2/auto-orient/strip|imageView2/2/w/698/format/webp)\n\nWindows的文件权限\n\n### 强制访问控制（MAC: Mandatory Access Control）\n\nMAC是为了弥补DAC权限控制过于分散的问题而诞生的。在MAC的设计中，每一个对象都都有一些权限标识，每个用户同样也会有一些权限标识，而用户能否对该对象进行操作取决于双方的权限标识的关系，这个限制判断通常是由系统硬性限制的。比如在影视作品中我们经常能看到特工在查询机密文件时，屏幕提示需要“无法访问，需要一级安全许可”，这个例子中，文件上就有“一级安全许可”的权限标识，而用户并不具有。\n\nMAC非常适合机密机构或者其他等级观念强烈的行业，但对于类似商业服务系统，则因为不够灵活而不能适用。\n\n![img](https://upload-images.jianshu.io/upload_images/594774-f9ce520635dc31b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/319/format/webp)\n\nRedHat MLS\n\n> [Red Hat: MLS](https://link.jianshu.com/?t=https://www.centos.org/docs/5/html/Deployment_Guide-en-US/sec-mls-ov.html)\n\n### 基于角色的访问控制（RBAC: Role-Based Access Control)\n\n因为DAC和MAC的诸多限制，于是诞生了RBAC，并且成为了迄今为止最为普及的权限设计模型。\n\nRBAC在用户和权限之间引入了“角色（Role）”的概念（暂时忽略Session这个概念）：\n\n![img](https://upload-images.jianshu.io/upload_images/594774-b220fc093138a2c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/509/format/webp)\n\nRBAC核心设计\n\n> 图片来自[Apache Directory](https://link.jianshu.com/?t=http://directory.apache.org/fortress/user-guide/1.3-what-rbac-is.html)\n\n如图所示，每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说RBAC就是：用户关联角色，角色关联权限。另外，RBAC是可以模拟出DAC和MAC的效果的。\n\n例如数据库软件MongoDB便是采用RBAC模型，对数据库的操作都划分成了权限（[MongoDB权限文档](https://link.jianshu.com/?t=https://docs.mongodb.com/manual/reference/privilege-actions/)）：\n\n| 权限标识  | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| find      | 具有此权限的用户可以运行所有和查询有关的命令，如：aggregate、checkShardingIndex、count等。 |\n| insert    | 具有此权限的用户可以运行所有和新建数据有关的命令：insert和create等。 |\n| collStats | 具有此权限的用户可以对指定database或collection执行collStats命令。 |\n| viewRole  | 具有此权限的用户可以查看指定database的角色信息。             |\n| …         |                                                              |\n\n基于这些权限，MongoDB提供了一些预定义的角色（[MongoDB预定义角色文档](https://link.jianshu.com/?t=https://docs.mongodb.com/manual/reference/built-in-roles/)，用户也可以自己定义角色）：\n\n| 角色      | find | insert | collStats | viewRole | …    |\n| --------- | ---- | ------ | --------- | -------- | ---- |\n| read      | ✔    |        | ✔         |          | …    |\n| readWrite | ✔    | ✔      | ✔         |          | …    |\n| dbAdmin   | ✔    |        | ✔         |          | …    |\n| userAdmin |      |        |           | ✔        | …    |\n\n最后授予用户不同的角色，就可以实现不同粒度的权限分配了。\n\n目前市面上绝大部分系统在设计权限系统时都采用RBAC模型。然而也有的系统错误地实现了RBAC，他们采用的是判断用户是否具有某个角色而不是判断权限，例如以下代码：\n\n\n\n```php\n<?php\n\nif ($user->hasRole('hr')) {\n    // 执行某种只有“HR”角色才能做的功能，例如给员工涨薪…\n    // ...\n}\n```\n\n如果后期公司规定部门经理也可以给员工涨薪，这时就不得不修改代码了。\n\n以上基本就是RBAC的核心设计（RBAC Core）。而基于核心概念之上，RBAC规范还提供了扩展模式。\n\n#### 角色继承(Hierarchical Role)\n\n![img](https://upload-images.jianshu.io/upload_images/594774-386977fee82f6152.png?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp)\n\nRBAC 1\n\n> 带有角色继承的RBAC。图片来自[Apache Directory](https://link.jianshu.com/?t=http://directory.apache.org/fortress/user-guide/1.3-what-rbac-is.html)\n\n顾名思义，角色继承就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。\n\n#### 职责分离(Separation of Duty)\n\n为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的RBAC被提出。\n\n职责分离有两种模式：\n\n- 静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。\n- 动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。\n\n![img](https://upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip|imageView2/2/w/509/format/webp)\n\nRBAC 2\n\n> 静态职责分离。图片来自[Apache Directory](https://link.jianshu.com/?t=http://directory.apache.org/fortress/user-guide/1.3-what-rbac-is.html)\n\n![img](https://upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip|imageView2/2/w/397/format/webp)\n\nRBAC 3\n\n> 动态职责分离。图片来自[Apache Directory](https://link.jianshu.com/?t=http://directory.apache.org/fortress/user-guide/1.3-what-rbac-is.html)\n\n讲了这么多RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。例如华中区域的销售没有权限查询华南区域的客户数据，虽然他们都具有销售的角色，而销售的角色拥有查询客户信息的权限。\n\n那么我们应该怎么办呢？\n\n#### 用户和对象的权限控制\n\n在RBAC标准中并没有涉及到这个内容（RBAC基本只能做到对一类对象的控制），但是这里讲几种基于RBAC的实现方式。\n\n首先我们看看PHP框架[Yii 1.X的解决方案](https://link.jianshu.com/?t=http://www.yiiframework.com/wiki/136/getting-to-understand-hierarchical-rbac-scheme/)（2.X中代码更为优雅，但1.X的示例代码更容易看明白）：\n\n\n\n```php\n<?php\n\n$auth=Yii::app()->authManager;\n \n$auth->createOperation('createPost','create a post');\n$auth->createOperation('readPost','read a post');\n$auth->createOperation('updatePost','update a post');\n$auth->createOperation('deletePost','delete a post');\n\n// 主要看这里。\n// 这里创建了一个名为`updateOwnPost`的权限，并且写了一段代码用来检验用户是否为该帖子的作者\n$bizRule='return Yii::app()->user->id==$params[\"post\"]->authID;';\n$task=$auth->createTask('updateOwnPost','update a post by author himself',$bizRule);\n$task->addChild('updatePost');\n \n$role=$auth->createRole('reader');\n$role->addChild('readPost');\n \n$role=$auth->createRole('author');\n$role->addChild('reader');\n$role->addChild('createPost');\n$role->addChild('updateOwnPost');\n \n$role=$auth->createRole('editor');\n$role->addChild('reader');\n$role->addChild('updatePost');\n \n$role=$auth->createRole('admin');\n$role->addChild('editor');\n$role->addChild('author');\n$role->addChild('deletePost');\n```\n\n实现效果：\n\n![img](https://upload-images.jianshu.io/upload_images/594774-fb67d571497fb0b2.gif?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp)\n\nYii 1.X权限图\n\n> 图片来自[Yii官方WiKi](https://link.jianshu.com/?t=http://www.yiiframework.com/wiki/136/getting-to-understand-hierarchical-rbac-scheme/)\n\n在这个Yii的官方例子中，`updateOwnPost`在判断用户是否具有`updatePost`权限的基础上更进一步判断了用户是否有权限操作这个特定的对象，并且这个判断逻辑是通过代码设置的，非常灵活。\n\n不过大部分时候我们并不需要这样的灵活程度，会带来额外的开发和维护成本，而另一种基于模式匹配规则的对象权限控制可能更适合。例如判断用户是否对Id为123的文章具有编辑的权限，代码可能是这样的：\n\n\n\n```php\n<?php\n\n// 假设articleId是动态获取的\n$articleId = 123;\n\nif ($user->can(\"article:edit:{$articleId}\")) {\n    // ...\n}\n```\n\n而给用户授权则有多种方式可以选择：\n\n\n\n```php\n<?php\n\n// 允许用户编辑Id为123的文章\n$user->grant('article:edit:123');\n\n// 使用通配符，允许用户编辑所有文章\n$user->grant('article:edit:*');\n```\n\n虽然不及Yii方案的灵活，但某些场景下这样就够用了。\n\n如果大家还有更好的方案，欢迎在评论中提出。\n\n### 基于属性的权限验证（ABAC: Attribute-Based Access Control）\n\nABAC被一些人称为是权限系统设计的未来。\n\n不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性来是否满足某种条件来进行授权判断（可以编写简单的逻辑）。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。\n\n例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。XACML（eXtensible Access Control Markup Language）是ABAC的一个实现，但是该设计过于复杂，我还没有完全理解，故不做介绍。\n\n总结一下，ABAC有如下特点：\n\n1. 集中化管理\n2. 可以按需实现不同颗粒度的权限控制\n3. 不需要预定义判断逻辑，减轻了权限系统的维护成本，特别是在需求经常变化的系统中\n4. 定义权限时，不能直观看出用户和对象间的关系\n5. 规则如果稍微复杂一点，或者设计混乱，会给管理者维护和追查带来麻烦\n6. 权限判断需要实时执行，规则过多会导致性能问题\n\n既然ABAC这么好，那最流行的为什么还是RBAC呢？\n\n我认为主要还是因为大部分系统对权限控制并没有过多的需求，而且ABAC的管理相对来说太复杂了。[Kubernetes便因为ABAC太难用，在`1.8`版本里引入了RBAC的方案](https://link.jianshu.com/?t=http://blog.kubernetes.io/2017/04/rbac-support-in-kubernetes.html)。\n\n> ABAC有时也被称为PBAC（Policy-Based Access Control）或CBAC（Claims-Based Access Control）。\n\n## 结语\n\n权限系统设计可谓博大精深，这篇文章只是介绍了一点皮毛。\n\n随着人类在信息化道路上越走越远，权限系统的设计也在不断创新，但目前好像处在了平台期。\n\n可能因为在RBAC到ABAC之间有着巨大的鸿沟，无法轻易跨越，也可能是一些基于RBAC的微创新方案还不够规范化从而做到普及。不过在服务化架构的浪潮下，未来这一块必然有极高的需求，也许巨头们已经开始布局了。\n\n## 参考文档\n\n[NTFS文件系统权限](https://link.jianshu.com/?t=https://support.microsoft.com/en-us/help/949608/changes-to-the-default-ntfs-discretionary-access-control-list-dacl-set)\n\n[Solaris权限模型](https://link.jianshu.com/?t=https://docs.oracle.com/cd/E56344_01/html/E53956/rbac-28.html#scrolltoc)\n\n[百度百科：访问控制](https://link.jianshu.com/?t=https://baike.baidu.com/item/访问控制/8545517)\n\n[Red Hat: Multi-Level Security (MLS)](https://link.jianshu.com/?t=https://www.centos.org/docs/5/html/Deployment_Guide-en-US/sec-mls-ov.html)\n\n[冰云：An Introduction To Role-Based Access Control](https://link.jianshu.com/?t=http://files.cnblogs.com/files/Wenzy/an_introduction_to_rbac.pdf)\n\n[NIST: Role-Based Access Control](https://link.jianshu.com/?t=https://csrc.nist.gov/projects/role-based-access-control)\n\n[MongoDB RBAC](https://link.jianshu.com/?t=https://docs.mongodb.com/manual/core/authorization/)\n\n[Stackoverflow: Group vs role Any real difference?](https://link.jianshu.com/?t=https://stackoverflow.com/questions/7770728/group-vs-role-any-real-difference)\n\n[Yii: Getting to Understand Hierarchical RBAC Scheme](https://link.jianshu.com/?t=http://www.yiiframework.com/wiki/136/getting-to-understand-hierarchical-rbac-scheme/)\n\n[Role-Based Access Control in Computer Security](https://link.jianshu.com/?t=http://www.informit.com/articles/article.aspx?p=782116)\n\n[(Syracuse University: Role-Based Access Control (RBAC)](https://link.jianshu.com/?t=http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/RBAC.pdf)\n\n[Yii 2.0 Guide](https://link.jianshu.com/?t=http://www.yiiframework.com/doc-2.0/guide-security-authorization.html)\n\n[WIKIPEDIA: Computer access control](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Computer_access_control)\n\n\n\n127人点赞\n\n\n\n[Laravel开发实践](https://www.jianshu.com/nb/1207266)",
                    "title": "权限系统设计模型分析（DAC，MAC，RBAC，ABAC）"
                  },
                  {
                    "path": "4.架构设计/知乎 100个简短而深刻的回答.md",
                    "content": "#docs/reference   #excerpt \n\n**1、怎么定义「想清楚了」？**\n\n“想清楚了”就是以后出了什么问题你只能找个没人的地方抽自己，再也不能抱怨别人了。\n\n**2、你交朋友的标准是什么？**\n\n出世的智者，入世的强者，或者正常而阳光的普通人。\n\n**3、男性更看重女性的身材、脸蛋，还是思想？**\n\n脸蛋和身材决定了我是否想去了解她的思想。\n\n思想决定了我是否会一票否决掉她的脸蛋和身材。\n\n**4、「别让孩子输在起跑线上」有道理吗？**\n\n一辈子都要和别人去比较，是人生悲剧的源头。\n\n**5、做哪些事情可以提升生活品质？**\n\n定期扔東西。\n\n**6、结婚以后两个人在一起最重要的是什么？**\n\n就当这婚还没结。\n\n**7、怎么判断乞丐的真假？**\n\n乞丐無論真假，當他向你乞討時，他就真的是乞丐了。\n\n**8、为什么文章写出来是为了给别人看的，可是写作的时候却很讨厌旁边有人看？**\n\n因为有了观察者之后，无限可能的状态就塌缩了。\n\n**9、怎么反驳「你行你上啊」的逻辑？**\n\n天涯名句「我评论个电冰箱，难道自己还得会制冷啊？」\n\n**10、你最希望你年轻的时候本该知道哪些道理或者懂得哪些事情？**\n\n内心的感受比外面的大道理重要。\n\n**11、把学费拿来念书还是环游世界更合适？为什么？**\n\n读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。\n\n**12、为什么部分人会产生「聪明智慧的姑娘都被憨憨的小伙儿搞定了」的印象？**\n\n严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨。\n\n**13、你为什么进入媒体？你为什么至今依然留在媒体？**\n\n我进媒体，是因为我不会干别的；我至今还留在媒体，是因为我还不会干别的。\n\n**14、你心中的完美爱情是怎么样的？**\n\n可以有不完美。\n\n**15、对于爱情，放下的瞬间是什么样的？**\n\n“在离别的车站，她上了车，我没有像以往那样目送那班车到消失，而是头也不回的走向家的方向。”\n\n**16、你最深刻的错误认识是什么？**\n\n以为自由就是想做啥做啥。后来才发现自律者才会有自由。\n\n当一个人缺乏自律的时候，他做的事情总是在受习惯和即时诱惑的影响，要么就是被他人的思想观念所扰，几乎永远不可能去做内心真正渴望的事。\n\n**17、为什么德国，这个贡献了如此多知识精英的国家，在国家决策上面如此愚蠢，卷入了两场打不赢的世界大战？**\n\n上次看欧洲杯，一个朋友对德国做出了评价：用哲学忽悠别人，用科学发展自己。\n\n**18、为什么有些事对别人来说只是举手之劳可他们却不愿帮忙？**\n\n我去做一件事并不是因为它简单，而是因为它值得。\n\n**19、如何成为有想法的人？**\n\n你们有没有发现，很有想法的人往往“厚脸皮”。\n\n我是说：他们不害怕说出一个想法后，被人认为二逼。\n\n有想法的人太多了，敢说出来的人太少了。\n\n**20、你为何下定决心离开某一公司？**\n\n有种说法，看你想不想留在一个公司，只要看看你的同事们的生活，如果他们的生活不是你想要的，就可以离开了，第一家公司离开的原因，就是我需要换一种生活。\n\n**21、异国长期生活，改变了你的哪些「是非观」？**\n\n很多事情只是不同，并无是非。\n\n**22、是不是一个人越成熟就越难爱上一个人？**\n\n不是越成熟越难爱上一个人。\n\n是越成熟，越能分辨那是不是爱。\n\n**23、如何让这个世界变得美好？**\n\n把你自己变得更美好。\n\n**24、苦难有什么价值？**\n\n永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。\n\n苦难不值得追求，磨练意志是因为苦难无法躲开。\n\n**25、国外哪些事物让你感觉还不如待在国内舒服？**\n\n“得到了天空，失去了大地”。\n\n**26、如何把无聊变为有趣？**\n\n须知才高于志，方是快乐的本源。以苍鹰搏兔之势逮耗子，架起导弹高射炮来打蚊子，越是「大材小用」，越有喜剧效果。\n\n越是用一本正经的态度，去做无聊的事情，越能悦人悦己。反正闲着也是闲着，不为无益之事，何以遣有涯之生呢。\n\n**27、你打天下的方法论是怎样的？**\n\n以正合以奇胜。\n\n不向静中参妙理，纵然颖悟也虚浮。\n\n**28、怎么确定对方是能一辈子和我在一起的人？**\n\n钱钟书先生对杨绛女士有这样一段评价，被社会学家视为理想婚姻的典范：\n\n1、在遇到她以前，我从未想过结婚的事。\n\n2、和她在一起这么多年，从未后悔过娶她做妻子。\n\n3、也从未想过娶别的女人。\n\n**29、如何反驳「现实点，这个社会就是这样」？**\n\n“你是怎样，你的世界就是怎样。”\n\n**30、你对自由的理解是什么？**\n\n说“不”的能力。\n\n**31、有哪些产品体现了 less is more 的设计理念？**\n\n围棋。\n\n**32、如何区分善良和懦弱？**\n\n面对敌人，有能力伤害别人，而不愿意伤害，谓之善良。\n\n面对敌人，有能力伤害别人，不敢去伤害，谓之懦弱。\n\n**33、跟朋友聊天问问题被回你猜时该回复什么可以做到戳瞎双眼的效果呢？**\n\n朋友：“你猜？”\n\n答：“猜完了。”\n\n朋友：“猜的啥？”\n\n答：“你猜。”\n\n**34、我们是否应该抵制日货？**\n\n我们要抵制日货，并不是要砸自己的日货。我们应该在自己的各行各业都比它做得好。\n\n我们的官员比他们的清廉，我们的街道比他们的干净，然后我们的桥也比它结实。\n\n还有我们的年轻人，比他更有未来，更有希望。\n\n**35、为什么成功学书籍看多，不仅没起到多少励志的作用，反而带来了很多负面的影响？**\n\n上士闻道，勤能行之；中士闻道，若存若亡；下士闻道，大笑之。---《老子》\n\n**36、怎么看待励志的书籍？**\n\n看再多，那都是别人的人生。\n\n**37、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？**\n\n远的崇拜，近的嫉妒。\n\n够不着的崇拜，够得着的嫉妒。\n\n有利益冲突的嫉妒，没利益冲突的崇拜。\n\n**38、室友都是热衷于看韩剧看星座爱陆琪的女孩，我在她们面前总是有一种优越感，而且总想卖弄一番自己每天逛知乎学来的知识，我该怎么办？**\n\n人之患在好为人师。\n\n**39、有些人特别喜欢发很简短的状态，这是一种什么心理？**\n\n可能性如下：\n\n1.简为美。\n\n2.不希望别人看懂，希望自己记录。\n\n3.不希望别人看懂，希望某人看懂。\n\n4.不希望别人看懂，希望别人关心。\n\n5.装。\n\n6.懒。\n\n**40、编程的乐趣是什么？**\n\n人的成就感来源于两样东西，创造和毁灭。\n\n**41、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机？”，当看到烂照片时，则往往笑话拍摄者水平很臭？**\n\n人习惯性的将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。\n\n**42、怎样面对同事对你的指责？**\n\n1. 你有错么？\n\n有错跳到4，没错跳到2\n\n2. 他有病么？\n\n如果指责别人是他的癖好，跳到3，否则跳回1反思\n\n3. 不管他，做好你自己的事\n\n4. 知错就改，虚心接受\n\n**43、刚刚交往的男朋友郑重的跟我说：＂将来你能不能不要跟我说你的过去，我不想知道也不会问，我怕有心理阴影。你能答应我么？＂他是什么意思？**\n\n“和妹子相处，要义就是：若她涉世未深，就带她看尽人间繁华；若她心已沧桑，就带她坐旋转木马。”\n\n只是，对男人来说若他心已沧桑，则只想安静的有个人一起生活！\n\n**44、怎样有效提出推荐或建议同时，避免给人灌输和强迫的感觉？**\n\n说服他人不要诉诸理性，应求于利益。\n\n**45、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？**\n\n夸奖他人。\n\n**46、为什么很多程序员、Geek 都喜欢熬夜，而且在后半夜工作效率异常高？**\n\n一个姑娘问我，搞学术的为什么都睡得那么晚，难道只有到晚上才有灵感？不是，姑娘，搞学术不靠灵感，靠的是碌碌无为的白天引发的愧疚心。\n\n**47、你是如何走出人生的阴霾的？**\n\n多走几步。\n\n**48、怎样做到“不****抱怨”？**\n\n自知者不怨人，知命者不怨天。\n\n**49、如何开导一个内心阴暗的女孩？**\n\n方法什么的不重要，最重要的是：\n\n一旦你决定走近她，就千万不要主动远离她\n\n一旦她开始靠近你，就永远不要试图推开她\n\n**50、26岁，工作三年却将留学三年，值得吗？**\n\n普通玩家选择标准配置，高端玩家选择自定义配置。\n  \n\n**51、坚持看新闻联播真的能致富？**\n\n看新闻联播的目的不是为了了解什么，学习什么，而是让你知道政府想让人们知道什么，而在中国这样一个政府力量巨大的社会里，对政府意图更好的解读对于经商确实是非常有益的。\n\n**52、什么样的人活得最幸福？**\n\n牌好、技术高且懂得悲天悯人之人。\n\n**53、为什么有些事对别人来说只是举手之劳可他们却不愿帮忙？**\n\n部分人是因为不够爱这个世界和世界上的人。部分人是因为不够信任这个世界和世界上的人。\n\n**54、如何看待「年轻时就释怀与淡泊，是没有希望的」这句话？**\n\n试图用一句话就来总结复杂的人生，是没有希望的。\n\n**55、如果没有月亮的话，人类文明会有何不同？**\n\n没有人类。\n\n**56、如何征服全宇宙？**\n\n征服自己。\n\n**57、能写出非常优秀的段子的赖宝为什么会得抑郁症？**\n\n因为喜剧演员都是把自己当做了祭品奉献给观众。\n\n**58、是否真的有天道酬勤？**\n\n成功需要运气，天赋，背景，人脉等等。勤奋可能只是不起眼的一个条件。\n\n但这并不意味着，如果你放弃勤奋，你就可以拥有其他条件。\n\n对于大部分人来说，他们只能勤奋，别无选择。\n\n世界本不公平，但不公平不是不努力的理由。\n\n**59、人这一生为什么要努力？**\n\n最痛苦的事，不是失败，是我本可以\n\n**60、要怎样努力，才能成为很厉害的人？**\n\n如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。\n\n**61、业余和专业最大的区别是什么？**\n\n高手都是跟自己玩的，水货都是陪别人玩的。\n\n**62、在一个足够小的星球上行走，我们是在上坡还是下坡？**\n\n你感觉累就是上坡，感觉轻松就是下坡。\n\n**63、你经历过的最神奇的事情是什么？**\n\n我一同学，某天指灯发誓自己没说谎，结果刚说完，灯罩掉下来了，正砸头顶上。\n\n**64、前半生与后****半生的分界线是在哪里？**\n\n此时此刻。\n\n**65、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？**\n\n天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。\n\n**66、听过最落寞的一句话或诗句是什么？**\n\n不如意事常八九，可与言者无二三。\n\n**67、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？**\n\n怕什么真理无穷，进一寸有一寸的欢喜。---胡适\n\n**68、30 岁才开始学习编程靠谱吗？**\n\n种一棵树最好的时间是十年前，其次是现在。---CaunDerre\n\n**69、怎么修身养性？**\n\n年轻时就释怀与淡泊，是没有希望的。---王石\n\n**70、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？**\n\n也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。---邵鸽\n\n**71、省钱的好办法有哪些？**\n\n在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。---费妮妮\n\n**72、和不熟的女生去吃饭应该怎么聊？**\n\n有人觉得交际困难或者比较累，是因为他们总是试图表现出自己所不具备的素质。---秦春山\n\n**73、王阳明的「知行合一」到底如何理解？又怎样运用到实际生活中？**\n\n知道做不到，等于不知道。---星光居士\n\n**74、什么叫见过大世面？**\n\n能享受最好的，能承受最坏的。---张亮\n\n**75、科学和迷信的分界点是哪里？**\n\n我错了。---陳浩\n\n**76、当初 Android 刚火的时候，为什么 Nokia 不采用，却依旧钟情于塞班？**\n\n人不会死在绝境，却往往栽在十字路口。---李楠\n\n**77、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么 Facebook 上线后没被其他大公司抄走？**\n\n保护创意的最好方法，就是将其最好地执行。---黄继新\n\n**78、哪些行为容易得罪别人，自己却不容易察觉？**\n\n太把别人当自己人。\n\n**79、怎样变得坦率和温柔？**\n\n一想到大家总有天要死，就觉得该对喜欢的人好一点，就这样啊。\n\n**80、员工辞职最主要的原因是什么？**\n\n钱少事多离家远，位低权轻责任重。\n\n**81、你在生活中得到过的最好的建议是什么？**\n\n“永远不要问你不想知道答案的问题。”\n\n“过度自我关注是万恶之源。”\n\n“永远不要为尚未发生的事儿拧巴。\n\n恩宜自淡而浓，先浓后淡者，人忘其惠；威宜自严而宽，先宽后严者，人怨其酷。\n\n觉得为时已晚的时候，恰恰是最早的时候。\n\n**82、热爱生活是什么样子的？**\n\n每天都有很强大的起床的动力，用心去拥抱每个时刻，珍惜美好的人与物。\n\n**83、肥是什么感觉？**\n\n肥就是人间失格。\n\n**84、有什么瞬间让你觉得世界真小？**\n\n48个相亲对象，竟然40个认识，世界太小了。\n\n**85、哪些行为是浪费时间？**\n\n思而不学+犹豫不决。\n\n**86、最能燃起你学习激情的一句话是什么？**\n\n你不能把这个世界，让给你所鄙视的人。\n\n夏酷暑，冬严寒，春也不死吾心，心所向，将所成。\n\n**87、和比自己家境富裕的人交友、来往（包括恋爱、同学、职场），需要注意什么？**\n\n其实和任何人交往都是一个道理，如果做不到，要事先说，不要中途或者事后说。\n\n**88、「装逼」跟「选择自己想要」的分界线在哪里？**\n\n牛逼和装逼的区别是，你究竟是对「做这件事」本身乐在其中，还是对「让其他人知道我做了这件事」乐在其中。\n\n如果有一件事，就算做了也决不能向任何人提起，还会毫不犹豫去做的，那才叫「选择自己想要的」。\n\n**89、如果好人没好报，我们为什么还要做好人？**\n\n我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。---哈维尔\n\n**90、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？**\n\n一直认为，所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。\n\n**91、有哪些我们熟知的名言其实还有后半句？**\n\n「人是生而自由的」\n\n下一句是：\n\n「但无往不在枷锁之中。」\n\n再下一句是：\n\n「自以为是其他一切主人的人，反而比其他一切更是奴隶。」\n\n**92、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？**\n\n“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在 你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”---龙应台\n\n**93、情商不高的例子有哪些？**\n\n对陌生人毕恭毕敬，对亲近的人随意发怒。\n\n**94、好人是如何变成坏人的？**\n\n他觉得不公平的时候。\n\n**95、如何看待「年轻的时候需要的是朋友而不是人脉」？**\n\n沒有目的之交往，才能感動人。\n\n**96、如何解读“伊能静宣布收小贩夏俊峰之子为义子与其妻结拜”？**\n\n所有利他行为都应该被鼓励，即使布施者最后也得利。\n\n**97、理工科人士如果在相关知识和背景了解不多的情况下以肯定性的语气跨界讨论社科类问题，是否与科学精神相悖？**\n\n一千个人眼里有一千个哈姆雷特，但这个世界上只有一个勾股定理。\n\n**98、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？**\n\n不要低估你的能力，不要高估你的毅力。\n\n**99、为什么周围有的女生嘴里喊着男女平等，但是到了很多事上又会理所当然的享受女生特权？**\n\n因为任何个人或团体都不会主动放弃既得利益或优势。\n\n**100、怎样才可以当学霸？**\n\n没有学到死，就往死里学。",
                    "title": "知乎 100个简短而深刻的回答"
                  },
                  {
                    "path": "5.轮子索引/0.计算机语言/python/Testing REST APIs easily in Python with pyhttptest.md",
                    "content": "#docs/how-to-guides  #python #test\nhttps://hackernoon.com/testing-rest-apis-easily-in-python-with-pyhttptest-1d2x328d\n``` bash\npip install pyhttptest\n```\n- Create a JSON file, for example, data/requests.json\n```json\n\t[\n  {\n    \"name\": \"TEST: List all users\",\n    \"verb\": \"GET\",\n    \"endpoint\": \"api/v1/users\",\n    \"host\": \"http://localhost:8085/\",\n    \"headers\": {\n      \"Accept-Language\": \"en-US\"\n    },\n    \"query_string\": {\n      \"limit\": 1\n    }\n  },\n  {\n    \"name\": \"TEST: Add a new user\",\n    \"verb\": \"POST\",\n    \"endpoint\": \"api/v1/users\",\n    \"host\": \"http://localhost:8085/\",\n    \"payload\": {\n      \"username\": \"pyhttptest\",\n      \"email\": \"admin@pyhttptest.com\"\n    }\n  },\n  {\n    \"name\": \"TEST: Modify an existing user\",\n    \"verb\": \"PUT\",\n    \"endpoint\": \"api/v1/users/XeEsscGqweEttXsgY\",\n    \"host\": \"http://localhost:8085/\",\n    \"payload\": {\n      \"username\": \"pyhttptest\"\n    }\n  },\n  {\n    \"name\": \"TEST: Delete an existing user\",\n    \"verb\": \"DELETE\",\n    \"endpoint\": \"api/v1/users/XeEsscGqweEttXsgY\",\n    \"host\": \"http://localhost:8085/\"\n  }\n]\n\t\t\n```\n- Run command and gain report\n\t```python \n\tpyhttptest execute data/test_server_status.json\n\t\t\n\t```",
                    "title": "Testing REST APIs easily in Python with pyhttptest"
                  },
                  {
                    "path": "5.轮子索引/0.计算机语言/python/python 多版本包共存问题.md",
                    "content": "#python #docs/how-to-guides \n\n简单说.. 没有. 只能有一个版本. 最好的办法就是*一个工程一个环境*。\n\n```bash\n# python-best-practice\npython3 -m venv env\n. env/bin/activate\n\n# 关闭环境\ndeactive\n\n```\n\n \n实在想多版本共存的方法(极不推荐):\n\n1. 下载下来,后到工程里,重命名.引用的时候用的新的名字.",
                    "title": "python 多版本包共存问题"
                  },
                  {
                    "path": "5.轮子索引/0.计算机语言/yaml rules.md",
                    "content": "#yaml #docs/tutorials \n \n- 只能空格\n- 只要对齐，空格多少无关系\n\n```\n  abc1: \n  -  a: c\n  -  b: d\n  \n  abc2: \n    - a: c\n    - b: d\n  \n  \n  abc3: \n  - a: c\n    b: d\t\n```\n\n对应\n\n```\n{ \n  abc1: [ { a: 'c' }, { b: 'd' } ],\n  abc2: [ { a: 'c' }, { b: 'd' } ],\n  abc3: [ { a: 'c', b: 'd' } ] \n  }\n```\n\n",
                    "title": "yaml rules"
                  },
                  {
                    "path": "5.轮子索引/1.后端库/@import  Vs. @Bean.md",
                    "content": "#spring #docs/whatis-why-explanation \n \n\n实用 @Bean 和 @Import 的示例\n```java\n@Configuration\n@Import({Dog.class, Cat.class})\npublic class DemoConfig {\n    @Bean(\"tom\")\n    public Person getPerson3(){\n        System.out.println(\"没有添加@condition的普通bean：tom\");\n        return new Person(1,\"tom\",12);\n    }\n}\n```\n\n运行结果：\n```java\ndemoConfig\ncn.enjoy.bean.Dog\ncn.enjoy.bean.Cat\ntom\n```\n\n从这里可以看出@import和@bean的区别\n1、@import的id为全类名\n2、@import使用更多功能\n\nImportSelector的使用，可以更加灵活加载bean\n```java\npublic class HonryImportSeletor implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        return new String[]{\"cn.enjoy.bean.Tiger\",\"cn.enjoy.bean.Fish\"};\n    }\n}\n```\n\n加入到配置类中\n```java\n@Configuration\n@Import({Dog.class, Cat.class,HonryImportSeletor.class})\npublic class DemoConfig {\n    @Bean(\"tom\")\n    public Person getPerson3(){\n        System.out.println(\"没有添加@condition的普通bean：tom\");\n        return new Person(1,\"tom\",12);\n    }\n}\n```\n\n执行结果：\n```\ndemoConfig\ncn.enjoy.bean.Dog\ncn.enjoy.bean.Cat\ncn.enjoy.bean.Tiger\ncn.enjoy.bean.Fish\ntom\n```\n\n\n\nImportBeanDefinitionRegistrar接口的使用，可以通过条件控制想要加载的bean\n```java\npublic class HonryImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        boolean b = registry.containsBeanDefinition(\"cn.enjoy.bean.Dog\");\n        boolean b1 = registry.containsBeanDefinition(\"cn.enjoy.bean.Fish\");\n//通过判断dog和fish在IOC容器中，才加载pig\n        if(b && b1){\n            RootBeanDefinition definition = new RootBeanDefinition(Pig.class);\n            registry.registerBeanDefinition(\"cn.enjoy.bean.Pig\",definition);\n        }\n    }\n}\n```\n\n配置@import加上\n```java\n@Configuration\n@Import({Dog.class, Cat.class,HonryImportSeletor.class,HonryImportBeanDefinitionRegister.class})\npublic class DemoConfig {\n    @Bean(\"tom\")\n    public Person getPerson3(){\n        System.out.println(\"没有添加@condition的普通bean：tom\");\n        return new Person(1,\"tom\",12);\n    }\n}\n```\n\n输出结果：\n```\ndemoConfig\ncn.enjoy.bean.Dog\ncn.enjoy.bean.Cat\ncn.enjoy.bean.Tiger\ncn.enjoy.bean.Fish\ntom\ncn.enjoy.bean.Pig\n```\n",
                    "title": "@import  Vs. @Bean"
                  },
                  {
                    "path": "5.轮子索引/1.后端库/RabbitMQ.md",
                    "content": "#MQ/rabbitMQ #docs/tutorials \n\n \n## 原理\n\n### connection\n\n真实的 tcp 连接\n\n### channels\n\ntcp 太昂贵，channels 是 tcp 中的虚拟连接，一个 connection 里可以有多个 channels。以复用 tcp 链接。\n\n### messsage \n\n里面包含路由 key和消息主体。\n\n### exchange \n\n消息会事先发送到 exchange，判断里面的路由 key 对应哪个 queue。 有不同的 exchange 类型\n\n1. direct 默认   \n\n2. fanout  将忽略 message 里的路由 key，将消息转发到所有 binding 到它的 queue\n\n3. topic (regex)。可以对 message 里路由 key，与绑定的 queue 的 binding key 做一些简单的匹配。只要匹配就会发到相应 queue 上。 匹配就 3 条规则：\n\n   1. 只能匹配单词，**以'.' 分割单词**\n\n   2. '#' 匹配 0 或多个单词\n\n   3. '*' 匹配 1 个单词\n\n   ![image-20190817132954617](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190817132954617.png)\n\n4. headers\n\n### binding\n\n绑定路由exchange 与 queue。指定绑定时的 路由规则。注意，只有一根线。\n\nFrom exchange: 来自于哪个 exchange \n\nRouting key: 很重要\n\n![image-20190817145313040](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190817145313040.png)\n\n\n\n### queue\n\nqueue 的名字不重要，有名字就行。\n\n![image-20190817145152193](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190817145152193.png)\n\n### consumer\n\n### virtual host\n\n相当另一个 rabbitmq 实例，默认的在 / 路径。可以创建其他路径的 rabbitmq 主机。它们是隔离的。 有各自的 exchange, queue 等。\n\n\n![image-20190817132108100](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190817132108100.png)\n\n\n\n## 安装\n\n### docker 安装\n\n``` sh\n#!/bin/bash\ndocker rm -f rabbit\ndocker run -d  --name rabbit --hostname rabbit -p 15671:15671 -p 15672:15672 -p 5672:5672  rabbitmq:3-management\n```\n\n用带 management 后缀的 doker image，带有管理界面。\n\n默认 5672 是客户端与 rabbit 通信的端口\n\n默认 15672 是网页管理界面的端口\n\n\n\n \n\n## 登陆管理界面\n\nhttp://localhost:15672/\n\n账号密码： guest / guest \n\n\n\n### 配置\n\n可以在管理界面里面配置exchange binding  queue\n\n也可以在代码里动态创建。\n\n\n\n\n\n## 注解\n\n@RabbitListener  可以标在类或方法上\n\n@RabbtiHandler   只能标在方法上\n\n那为何不只用 @RabbitListener呢? \n\n因为有时一个 queue 里有不同的消息. 则可以通过 @RabbitListener 标注一个类关注的 queue.\n\n使用 @RabbtiHandler 去标注方法监听不同的消息,如下\n\n![image-20220202230140011](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202230140011.png)\n\n\n\n\n\n## 消息确认机制\n\n![image-20220202230704926](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202230704926.png)\n\n### 手动确认发送成功\n\n![image-20220202231315404](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202231315404.png)\n\n![image-20220202234056815](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202234056815.png)\n\n### 手动确认投递成功\n\n![image-20220202234211816](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202234211816.png)\n\n![image-20220202234255463](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202234255463.png)\n\n![image-20220202234350498](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202234350498.png)\n\n### 手动确认消费成功\n\n![image-20220202234910149](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220202234910149.png)\n\n必须开启手动确认. 自动回复在服务宕机时,会丢消息.\n\n![image-20220203000354471](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220203000354471.png)\n\n![image-20220203001333074](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220203001333074.png) \n",
                    "title": "RabbitMQ"
                  },
                  {
                    "path": "5.轮子索引/1.后端库/intellij  JPA 提示.md",
                    "content": "#jpa  #intellij  #docs/how-to-guides \n先要写类型名\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1656516761425-c528a06e-19f3-4120-9564-d77cc2274fd3.png)",
                    "title": "intellij  JPA 提示"
                  },
                  {
                    "path": "5.轮子索引/1.后端库/knife swagger 自动设置 token.md",
                    "content": "#swagger  #docs/how-to-guides \n\n```//ke = knife4jenvironment\nvar code=ke.response.data.code;\nif(code=='0'){\n//获取token\nvar token=ke.response.data.token;\n//设置token到请求头\nke.global.setHeader(\"token\",token);\nalert(\"已自动设置请求头\")\n}\n```\n\n\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1658570219197-3255a4e4-7212-41c2-991b-cc45dcb15181.png)",
                    "title": "knife swagger 自动设置 token"
                  },
                  {
                    "path": "5.轮子索引/1.后端库/spring 环境启动最佳实践.md",
                    "content": "#spring  #docs/how-to-guides \n## 运行时指定( 通过 main 方法)\n\n通过 main 函数传入, 这会影响 spring 选择哪个配置文件. 同时会影响resources 里的 bootstrap.yml 与 application.yml\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1649845042824-16b0a71e-b43c-4637-b0e0-b5041c324fba.png)\n\n```\n--spring.profiles.active=local\n```\n\n  \n\n则会生效以下几个配置文件\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1649845182806-b0b30cc1-82bc-426b-8dc2-701470836be1.png)\n\n  \n\n如果通过 mvn 启动,则这样传\n\n```\n-Dspring-boot.run.profiles=local\n```\n\n  \n\n通过 `mvn <activation>`\n \n``` xml\n<profile>\n\t<id>sit</id>\n\t<properties>\n\t\t<gm.jar.profile>sit</gm.jar.profile>\n\t\t<gm.jar.version>${project.version}</gm.jar.version>\n\t</properties>\n\t<activation>\n\t\t<property>\n\t\t\t<name>gm.build.type</name>\n\t\t\t<value>sit</value>\n\t\t</property>\n\t</activation>\n</profile>\n```\n  \n\n## 编译时指定\n\n一般也就是通过 mvn 做启动\n\n如果你是多 module 项目, 可以配在最外层的 pom\n\n  ``` xml\n<!--profiles-->\n    <profiles>\n        <profile>\n            <id>default</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n\n        </profile>\n        <profile>\n            <id>local</id>\n            <properties>\n                <!--mvn.my.profile 是自己定义的名字，可以在 spring 的 yml，或 properties 里通过 @mvn.my.profile@ 访问到，这样就能控制 spring 激活哪个spring 配置-->\n                <mvn.my.profile>local</mvn.my.profile>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>com.h2database</groupId>\n                    <artifactId>h2</artifactId>\n                </dependency>\n            </dependencies>\n        </profile>\n\n        <profile>\n            <id>mysql</id>\n            <properties>\n                <mvn.my.profile>mysql</mvn.my.profile>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>mysql</groupId>\n                    <artifactId>mysql-connector-java</artifactId>\n                </dependency>\n            </dependencies>\n        </profile>\n\n        <profile>\n            <id>prod</id>\n            <properties>\n                <mvn.my.profile>prod</mvn.my.profile>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>mysql</groupId>\n                    <artifactId>mysql-connector-java</artifactId>\n                </dependency>\n            </dependencies>\n        </profile>\n    </profiles>\n```\n\n那么, 可以通过 -P 参数传给 mvn , 比如 -Plocal, mvn 会找到 对应的 local > properties > mvn.my.profile 去替换 application.yml 里的 @mvn.my.profile@\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1649845481617-92770e72-b075-4a7a-8a72-77cc37320f93.png)\n\n替换后\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1649845727065-c70174e3-f9d8-4202-b5f7-6fff78762715.png)",
                    "title": "spring 环境启动最佳实践"
                  },
                  {
                    "path": "5.轮子索引/3.前端库/react/Hooks.md",
                    "content": "#react/hooks  #docs/how-to-guides \n \n[https://www.youtube.com/playlist?list=PLZlA0Gpn_vH8EtggFGERCwMY5u5hOjf-h](https://www.youtube.com/playlist?list=PLZlA0Gpn_vH8EtggFGERCwMY5u5hOjf-h)\n\n\n\nhooks 简而言之就是为了解决 function 不带状态的问题。hook 不能在 class 里使用。\n\n16.8 加入。 \n\n### useState\n\n声明\n\n```javascript\n// 一定要记得初始值，\n// ✅ 不要为空\n   let [v,setv] = useState(1);\n\n// ❌\n   let [v,setv] = useState();\n```\n\n使用\n\n```javascript\n// ✅ 推荐这样写\n   setv( s=> s+1)\n\n// ❌ 而不是这样写, 因为如果连续  setv ，会导致状态混乱\n   setv(v+1)\n```\n\n\n\n>  要注意： setState 时，不要只更新部分 state。不支持。 所以\n\n### useMemo\n\nhttps://www.youtube.com/watch?v=qySZIzZvZOY&list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A&index=27&ab_channel=Codevolution\n\n\n\n![image-20220821054323967](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821054323967.png)\n\n```js\n   let [name,setName] = useState('zk');\n   let [age ,setAget] = useStage(30);\n   let [theme,setTheme] = useState('dark');\n\n// 如果将上面状态组成一个对象，希望达成一种 watch 的效果。\n// ❌ 不要这样写, 你会发现，如果你调用了 setTheme，也会导致下面 useEffect 执行\n   let user = {name,age} \n\n// ✅ 而应该这样\n   let user = useMemo(()=> return {name,use},[name,user]);\n   这样，theme 改变时，user 不会在 useEffect 里重新执行\n// 😀   \n   userEffect(()=>{console.log(user),[user]}\n```\n\n### useCallbak\n\n主要是为了性能。如果你使用了 React.memo 包裹组件，因为函数组件每次都会重新执行函数。 而你的组件又用了这个函数，哪还是会认为 props 每次都有改变而会发生 rerender。[案例](https://www.youtube.com/watch?v=IL82CzlaCys&list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A&index=26&ab_channel=Codevolution)\n\n其实就是将函数变成一个引用。这样在函数组件里才有复用的可能。\n\n![image-20220821053830741](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821053830741.png)\n\n### useMemo vs useCallback\n\n\n\nuseMemo(function,...) 缓存返回值\n\nuseCallback(function,...) 缓存函数\n\n### useEffect\n\n没参数时 相当于 componentDidMount componentDidUpdate  的合集\n\n每次渲染后调用，这个函数是**异步的**，如果对 dom 做操作。有可能看到中间过程。\t\n\n其实跟上面的 useMemo useCallback 也差不多。只不过没返回值。\n\n\n\n带参 [] 时， 相当于 componentDidMount，只会调用一次 \n\n而带参[count]时，是为了替换以下写法\n\n![image-20220820004946686](../../../../../../../Application Support/typora-user-images/image-20220820004946686.png)\n\n\n\n带返回函数时， 相当于componentDidunMount  \n\n\n\n\n\n如果是 useEffect 要调用函数，最好是定义在 useEffect 里。 这样，要监听的 props 比较容易识别。\n\n![image-20220820220911600](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220820220911600.png)\n\n\n\n也支持写成多个 useeffect\n\n![image-20220820221059907](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220820221059907.png)\n\n\n\n### useLayoutEffect\n\n与 useEffect 的区别在于，这个函数是同步的。 它的时机一定在dom 计算完后与 render 之间。此时，dom 已经确定了。[demo](https://youtu.be/wU57kvYOxT4?list=PLZlA0Gpn_vH8EtggFGERCwMY5u5hOjf-h&t=203)\n\n### useRef\n\nhttps://www.youtube.com/watch?v=LWg0OyZQffc&list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A&index=29&ab_channel=Codevolution\n\n定义好你的组件\n\n注意这里要用 React.createRef 不要使用 hook 的 useRef， 不通用。\n\n```js\nimport React from 'react'\nimport logProps from './LogProps'\nexport  class Input2 extends React.Component {\n  constructor(props){\n    super(props);\n    this.ref = React.createRef()\n  }\n  focus(){\n     this.ref.current.focus();\n  }\n  render(){\n    return (\n      <input ref={this.ref} defaultValue=\"input 2\"/>\n    )\n  }\n}\nexport default logProps(Input2);\n\n```\n\n\n使用方法\n\n```js\nimport {useRef} from 'react'\nimport Input2 from './componentes/Input2'\n\nfunction App() {\n  let inputRef2 = useRef();\n  return (\n    <div className=\"App\">\n      <Input2 ref={inputRef2}/>\n      <button onClick={e => inputRef2.current.focus()}>focus</button>\n    </div>\n  )\n}\n\nexport default App\n\n```\n\n\n### \n\n### useRef\n\nuseRef 与 useState 很像， 但 useRe f它不会触发render\n\n```js\n// ✅ 这样\nfunction App() {\n  const [number, setNumber] = useState(0)\n  const rtimes = useRef(1);\n\n  useEffect(()=>{\n    rtimes.current +=1;\n  })\n\n  return (\n    <div >\n      <input value={number}  readOnly/>\n      <button onClick={e=>setNumber(n=>n + 1)} >add</button>\n      render times {rtimes.current}\n    </div>\n  )\n}\n\n// ❌  不要这样做，会死循环\nfunction App() {\n  const [number, setNumber] = useState(0)\n  const [rtimes,setRtimes] = useState(1);\n\n  useEffect(()=>{ setRtimes(r=>r+1})\n\n  return (\n    <div >\n      <input value={number}  readOnly/>\n      <button onClick={e=>setNumber(n=>n + 1)} >add</button>\n      render times {rtimes}\n    </div>\n  )\n}\n```\n\n另一个场景，记录历史\n\n```js\nfunction App() {\n  const [name, setName] = useState('');\n  const previousName = useRef('');\n  useEffect(() => {\n    previousName.current = name;\n  }, [name]);\n\n  return (\n    <div >\n      <input onChange={e => {setName(e.target.value)}} />\n      <div>\n        previousName is: {previousName.current}\n      </div>\n    </div>\n  )\n}\n```\n\nuseRef 还可以用来引用真实的 ref dom element\n\n```js\nfunction App() {\n  const inputRef = useRef();\n  const focus = ()=>{\n    inputRef.current.focus()\n  }\n  return (\n    <div >\n      <input ref={inputRef} />\n      <button onClick={focus}>focus</button>\n    </div>\n  )\n}\n```\n\n\n### ForwardRef\n\n#### 函数组件\n\n当你的父组件需要操作子组件 **html element** 的 ref 时。有一个问题。你能直接在子组件上写个 ref={xxx} , 这就变成拿到这个子组件的 ref 了。而不是拿到子组件里  **html element** 的 ref。 \n\n子组件只能当一个传递者。传递 ref 给 render 里的 **html element** 。\n\n这就带来了两种处理方式\n\n**普通写法**\n\n不使用组件上的 ref\n\n```js\n// App.jsx\nimport {useRef} from 'react'\nimport Input from './componentes/Input'\n\nfunction App() {\n  let inputRef = useRef();\n  return (\n    <div className=\"App\">\n      <Input myref={inputRef} />\n      <button onClick={e => inputRef.current.focus()}>focus</button>\n    </div>\n  )\n}\n\nexport default App\n \n\n// Input.jsx\nfunction Input(props) {\n  return <input ref={props.myref}/>\n}\nexport default List;\n```\n\n\nforwardRef 写法\n\n注意点：\n\n1. 只需要在你的子组件里写上 forwardRef。\n2. ref 不\b在 props 里传递\n\n```js\nimport {useRef} from 'react'\nimport Input from './componentes/Input'\n\nfunction App() {\n  let inputRef = useRef();\n  return (\n    <div className=\"App\">\n      <Input ref={inputRef} />\n      <button onClick={e => inputRef.current.focus()}>focus</button>\n    </div>\n  )\n}\n\nexport default App\n\n\n// Input.jsx\nimport React from 'react'\nfunction Input(props,ref) {\n  return <input ref={ref}/>\n}\nexport default React.forwardRef(List);\n\n```\n\n\n思考一下：\n\n第一种写法简单。 但导致了一个小问题。 父组件必须不能以 ref 的 key 传递。但好处是可以传递多个 ref。\n\n第二种方式看上去统一，但只能传递一个 ref。\n\n在源码层面：ref 并没有任何特殊的处理。多一个 forwardRef，仅仅是为了统一组件的使用方式。\n\n只要你的组件里有 ref 需要传递出去，就应该用 React.forwardRef 把组件包裹起来 export \n\n#### HOC 组件包住了要引用的组件\n\n有点麻烦。\n\n先定义好你的 HOC 组件\n\n```js\n// LogProps.jsx\nimport React from 'react';\n\nexport default function logProps(Component) {\n  class LogProps extends React.Component {\n\n    componentDidUpdate(prevProps) {\n      console.log('old props:', prevProps);\n      console.log('new props:', this.props);\n    }\n\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n```\n\n\n\n### useContext\n\n为了规避以下情况，不再需要通过 props 一层层的传递参数,\n\n![image-20220821022405966](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821022405966.png)\n\ncreateContext 相当于一个全局存值的地方。\n\n```js\n//父组件 App.jsx\nimport React,{useState} from 'react'\nimport ThemeBoard from './ThemeBoard'\n\nexport const ThemeContext = React.createContext()  // 1. 声明 context，并 export\nfunction App() {\n  const [theme, setTheme] = useState('red');\n  const toggleTheme = ()=>{\n      theme === 'red'\n      ?setTheme('green')\n      :setTheme('red')\n  }\n  return (\n    <ThemeContext.Provider value={theme}>   // 2. 用 context 包裹起组件，注意，这里只能写 value \n      <div>\n        theme: <ThemeBoard/> \n        <button onClick={toggleTheme}>toggle</button>\n      </div>\n    </ThemeContext.Provider>\n  )\n}\nexport default App\n\n\n// ✅ 推荐在 function compoent 里这种写法\nimport React,{useContext} from 'react';\nimport {ThemeContext} from './App';\n\nexport default function ThemeBoard() {\n  const theme = useContext(ThemeContext)   //3.1 使用 context\n  return <div style={{backgroundColor:theme}}> {theme} </div> \n}\n\n\n// ❌ 子组件 ThemeBoard.jsx， 不推荐这种写法，一般只用在 Class Componet 里。非常繁琐\nimport React from 'react';\nimport {ThemeContext} from './App';\n\nexport default function ThemeBoard() {\n  return (\n    <ThemeContext.Consumer>     //3.2 使用 context\n      {\n        (theme) => {   // value 会传到这里来\n          return <div style={{backgroundColor:theme}}> {theme} </div>\n        }\n      }\n    </ThemeContext.Consumer>\n  )\n}\n\n\n```\n\n使用 class 会非常繁琐\n\n![image-20220821022951958](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821022951958.png)\n\n![image-20220821022937144](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821022937144.png)\n\n\n\n### useReducer vs useState\n\n相对于 useState useReducer 多了个 action 参数。为复杂状态的变更提供了便利。 action 就随你组织了。通常就是 一个 type，一个 payload。 \n\n不是说 useState 不能用来管理 Object 与 Array ，只不过如果用 useState ，逻辑会散落在文件各个地方。不好管理。\n\n![image-20220821045614212](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220821045614212.png)\n\n```js\n// App.js\nimport React, {useReducer, useState} from 'react'\nimport Todo from './Todo'\n\nexport const ACTIONS = {\n  TODO_ADD: 'TODO_ADD',\n  TODO_DELETE: 'TODO_DELETE',\n  TODO_TOGGLE: 'TODO_TOGGLE'\n}\nfunction reduce(state, action) {\n  switch (action.type) {\n    case ACTIONS.TODO_ADD:\n      return [...state, {id: Date.now(), content: action.content || 'default', complete: false}]\n    case ACTIONS.TODO_DELETE:\n      return state.filter(t => t.id != action.id);\n    case ACTIONS.TODO_TOGGLE:\n      return state.map(t => {\n        if (t.id === action.id)\n          t.complete = !t.complete\n        return t;\n      });\n\n    default:\n      return state;\n  }\n}\nfunction App() {\n  const [todos, dispatch] = useReducer(reduce, [{id: Date.now(), content: 'default', complete: false}]);\n  const [content, setContent] = useState('');\n\n  return (\n    <div>\n      <input placeholder=\"input todos here\" value={content} onChange={e => setContent(e.target.value)} />\n      <button onClick={\n        e => dispatch({type: ACTIONS.TODO_ADD, content: content})\n      }>add</button>\n      {\n        todos.map(todo => {return <Todo key={todo.id} todo={todo} dispatch={dispatch} />})\n      }\n    </div>\n  )\n}\n\nexport default App\n\n```\n\n\n```js\n// Todo.js\nimport {ACTIONS} from './App'\nexport default function Todo({todo, dispatch}) {\n  return (\n    <div>\n      <input type=\"checkbox\" readOnly checked={todo.complete} />\n      <span>{todo.content}</span>\n      <button onClick={e => dispatch({type: ACTIONS.TODO_DELETE, id: todo.id})}>x</button>\n      <button onClick={e => dispatch({type: ACTIONS.TODO_TOGGLE, id: todo.id})}>toggle</button>\n    </div>\n  )\n}\n\n\n```\n\n\n\n### useReducer + useContext\n\nhttps://www.youtube.com/watch?v=BCD2irXaVoE&list=PLC3y8-rFHvwisvxhZ135pogtX7_Oe3Q3A&index=22&ab_channel=Codevolution\n\n\n\n",
                    "title": "Hooks"
                  },
                  {
                    "path": "5.轮子索引/3.前端库/react/react-教程.md",
                    "content": "#react  #docs/how-to-guides \n \n\n```bash\ncreate-react-app  <projectName>\n或者\nnpx create-react-app my-app\n\n\nyarn eject \nyarn start \n```\n\n 报任何错，直接去 google。每个版本都不太一样 \n\n\n\n![image-20220903143401378](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220903143401378.png)\n\n# react 80% 功能\n\n## 基本要求\n\n1. All React components must act like pure functions with respect to their props. [link](https://reactjs.org/docs/components-and-props.html)\n\n   \n\n## 创建组件\n\n### 函数直接创建\n\n####  \n\n``` js\nfunction Comp1(props){\n    return <div>hello  {props.name}</div>\n}\n```\n\n \n\n\n\n### 通过类创建\n\n```js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass User extends React.Component {\n    render(){\n        return  <div>User compoent {this.props.name}</div>\n    }\n}\nexport default User;\n```\n\n\n\n使用\n\n```js\nimport User from \"./comp/user\"\n```\n\n\n\n## 路由\n\n不使用 a 的原因是为了防止全部刷新。\n\n### 安装\n\n```bash\nyarn add react-router-dom\n```\n\n\n\n### 使用\n\n```js\nimport {BrowserRouter as Router, Route, Link} from 'react-router-dom'\n```\n\n### 解释\n\n[参考]([http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu](http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu))\n\nRouter  路由的容器，所有的 Link Route 都要写在里面\n\nLink  显示链接，想当于 a 标签。\n\nRoute  相当于视图。内容会在这里切换。\n\nSwitch 只渲染第一个匹配的\n\n \n\n如果要嵌套路由。那子视图就不要再写 Router了。见示例\n\n### 示例\n\n```js\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nfunction App() {\n    return (\n        <div>\n\n            <Router>\n                <div>\n                    <Header />\n                    <Route exact path=\"/\" component={Home} />\n                    <Route path=\"/about\" component={About} />\n                    <Route path=\"/topics\" component={Topics} />\n                </div>\n            </Router>\n        </div>\n    );\n}\n\nfunction Home() {\n    return <h2>Home</h2>;\n}\n\nfunction About() {\n    return <h2>About</h2>;\n}\n\nfunction Topic({ match }) {\n    return <h3>Requested Param: {match.params.id}</h3>;\n}\n\nfunction Topics({ match }) {\n    return (\n        <div>\n            <h2>Topics</h2>\n\n            <ul>\n                <li>\n                    <Link to={`${match.url}/components`}>Components</Link>\n                </li>\n                <li>\n                    <Link to={`${match.url}/props-v-state`}>Props v. State</Link>\n                </li>\n            </ul>\n\n            <Route path={`${match.path}/:id`} component={Topic} />\n            <Route\n                exact\n                path={match.path}\n                render={() => <h3>Please select a topic.</h3>}\n            />\n        </div>\n    );\n}\n\nfunction Header() {\n    return (\n        <ul>\n            <li>\n                <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n                <Link to=\"/about\">About</Link>\n            </li>\n            <li>\n                <Link to=\"/topics\">Topics</Link>\n            </li>\n        </ul>\n    );\n}\n\nexport default App;\n```\n\n\n\n## 通信 \n\n### 直接通信\n\n```js\nfunction Comp1(props){\n    return <div>hello  {props.gender},{props.name}</div>\n}\n```\n\n使用时\n\n```js\n<Comp1 gender=\"male\" arg={this.state.name}/>\n```\n\n\n\n### redux\n\n原理见  `~/git/jsPrj/react/zk-redux`\n\n####  示例\n\n  不要直接使用以下代码。\n\n##### index.js\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { createStore, applyMiddleware, compose } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport { Provider } from \"react-redux\";\nimport reducers from \"./reducers\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst reduxDevTools = window.devToolsExtension\n  ? window.devToolsExtension()\n  : f => f;\n\nconst store = createStore(\n  reducers,\n  compose(\n    applyMiddleware(thunk),\n    reduxDevTools\n  )\n);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App store={store} />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n```\n\n\n\n#### reducers.js\n\n```js\nimport {combineReducers} from 'redux'\nimport {counter} from './index.redux'\nconst reducers={\n    counter\n}\nexport  default combineReducers(reducers)\n```\n\n\n\n#### index.redux.js\n\n```js\n\nconst  add_gun='add_gun'\nconst remove_gun='remove_gun'\n\nexport function counter(state=0,action){\n    switch(action.type){\n      case 'add_gun':\n        return state+1;\n      case 'remove_gun':\n        return state-1;\n      default:\n        return 10\n    }\n  }\n\nexport function  addGun(){\n    return {type:add_gun}\n}\nexport function  removeGun(){\n    return {type:remove_gun}\n}\n\nexport function  addGunAsync(){\n   return dispatch => {\n       setTimeout(() => {\n           dispatch(addGun())\n       }, 2000);\n   }\n}\n```\n\n\n\n#### main.js\n\n```js\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { addGunAsync } from \"../index.redux\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nfunction MenuDetail() {\n  return (\n    <div>\n      <div>hello</div>\n    </div>\n  );\n}\n\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.state}\n        <button onClick={e => this.props.addGunAsync()}>addGunAsync</button>\n        <h1>now is {this.props.num}</h1>\n        <Router>\n          <Link to=\"/menudetail\">menu</Link>\n          <Route exact path=\"/menudetail\" component={MenuDetail} />\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default connect(\n  state => {\n    return { num: state.counter };\n  },\n  { addGunAsync }\n)(Menu);\n\n```\n\n#  react 20%  高级\n\n## 封装组件\n\n```js\nexport const ErrorBoundaryRoute = ({ component: Component, ...rest }: RouteProps) => {\n  const encloseInErrorBoundary = props => (\n    <ErrorBoundary>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n  \n  return <Route {...rest} render={encloseInErrorBoundary} />;\n};\n\nexport default ErrorBoundaryRoute;\n\n```\n\n使用\n\n```js\n <Switch>\n      <ErrorBoundaryRoute path=\"/login\" component={Login} />\n <Switch/>\n```\n\n\n\n## Redux\n\n### 手写 redux \n\n[/Users/zk/git/jsPrj/react/zk-redux](file:///Users/zk/git/jsPrj/react/zk-redux\n)\n\n\n### Middle Ware 示意图\n![image-20191116143821590](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20191116143821590.png)\n\n### 柯里化\nredux 源码里用到了柯里化, 最大的好处是将参与的函数定义全部都延后执行了.\n 比如下面的 thunk 源码.  \n```\nconst thunk = ({ dispatch, getState }) => next => action => {\n\n\n  if (typeof action === \"function\") {\n    console.log(\"thunk working\");\n    return action(dispatch, getState);\n  }\n   return next(action);\n};\nexport default thunk;\n\n```\n\n```\n({ dispatch, getState }) => next => action =>\n```\n全部都延后执行, 在函数体里则可以再重新确定函数流程.\n\n### 用到的 reduce 函数\ncallback 四个参数 \n1. Accumulator (acc) 累积的结果\n2. Current Value (cur) 当前参数\n3. Current Index (idx) 当前idx\n4. Source Array (src) 源数组\n\narr.reduce(callback[, initialValue])\n\n```\nconst array1 = [1, 2, 3, 4];\nconst reducer = (accumulator, currentValue) => accumulator + currentValue;\n\n// 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));\n// expected output: 10\n\n// 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));\n// expected output: 15\n\n```\n\n\n\n### 重点\n\n结论：闭包会延迟执行。延迟到最终的值。如果要固定值，得要解析它。\n\n对比下面这两段代码。\n``` js\nlet a={\n    afunc:function()\n    {\n        console.log(\"hello\");\n    }\n}\n\nlet afunc=a.afunc\n\nlet b={\n    bfunc: (...a)=>afunc(...a),\n    bfunc2: afunc,\n    bfunc3:\n    (func=>(...a)=>func(...a))(afunc)\n}\n\nafunc=function(){\n    console.log(\"world\");    \n}\n\nb.bfunc()\nb.bfunc2()\nb.bfunc3()\n\n\n\n \n```\n输出 world hello hello\n\n\n### Hooks\n\n为什么存在?\n\n1. Hooks 是为函数式组件而生.在 class 里不工作.  如下面例子,你就不需要为这种纯函数创建一个类了.去写 setState 啥的.\n\n   ```js\n   function Example(props) {\n     // You can use Hooks here!\n     return <div />;\n   }\n   ```\n\n2. 再有就是获取更简单.\n\n\n\n```\n\nconst [value,setValue]=useState(0);\n// 界面有刷新时，会调用，第二个参数是监听的值。\nuseEffect(()=>{\n\n},[])\n```\n\n\n\n\n\n\n\n\n\n\n## QA\n\n### 为什么要用 super(props)?\n\n1.  ES6 定义: 在 `constructor` 中,如果子类未调用 `super()`, 则,`this` 无效.\n\n   ```js\n   class MyComponent extends React.Component {\n     constructor() {\n       console.log(this); // Reference Error i.e return undefined\n     }\n     ...\n   }\n   ```\n\n2.  传入 `props` 是为了能在 `constructor` 中使用 this.props.\n\n   ```js\n   class MyComponent extends React.Component {    \n       constructor(props) {\n           super()\n   \n           console.log(this.props)\n           // -> undefined\n   \n           // Props parameter is still available\n           console.log(props)\n           // -> { icon: 'home', … }\n       }\n   \n       render() {\n           // No difference outside constructor\n           console.log(this.props)\n           // -> { icon: 'home', … }\n       }\n   }\n   ```\n\n   我们看 react 源码的构造函数![image-20191116111153615](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20191116111153615.png)\n\n   ```js\n   function Component(props, context, updater) {\n     this.props = props;   // <------------------------ ***\n     this.context = context;\n     // If a component has string refs, we will assign a different object later.\n     this.refs = emptyObject;\n     // We initialize the default updater but the real one gets injected by the\n     // renderer.\n     this.updater = updater || ReactNoopUpdateQueue;\n   \n   ```\n   \n   \n\n###   为什么推荐用 hashbang?\n\n如果服务端与 react 部署在一起,这样能够很好的区分接口与 ui请求. 比如 imgServer 项目.\n\n如果你在开发时还想实时的编译 react. 可以在 pacakage.json 里启用\n\n```json\n  \"proxy\": \"http://192.168.1.15:5000\"\n```\n\n\n\n\n\n##  基于 react 的好项目\n\n### 组件化拖拽界面\n\nhttps://github.com/prevwong/craft.js\n\n![image-20200229174005953](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20200229174005953.png)\n\n有的搞头!\n\n### \n\n### Next.js\n\n简单了 react 的开发, 它起的作用如果不了解 react 根本就觉察不到. \n\n- 最重要的,就是超简单的服务端渲染, 零配置. 其实 react 也支持服务端渲染的.但你能一键撸出来么.\n\n- 再有一个优点, 就是路由的简化.\n\nIt's no secret that creating single-page JavaScript applications can be pretty challenging these days. Fortunately, there are multiple frameworks and libraries to choose from.\n\nEven still, there's a high learning curve before you can build a proper application. That's because you need to learn about client-side routing, page layout, APIs, and so on. Furthermore, you may want to server-side render certain pages and statically prerender others (balancing SEO and speed).\n\n**So, we need something simple but customizable.**\n\nThink about how webapps are created with PHP. You create some files, write PHP code, then simply deploy it. We don't have to worry about routing much, and the app is rendered on the server by default.\n\n\n\n## 参考\n\n[whats-the-difference-between-super-and-superprops-in-react-when-using-e](https://stackoverflow.com/questions/30571875/whats-the-difference-between-super-and-superprops-in-react-when-using-e)\n\n[how-to-extend-a-class-without-having-to-use-super-in-es6](https://stackoverflow.com/questions/31067368/how-to-extend-a-class-without-having-to-use-super-in-es6/31079103#31079103)\n\n",
                    "title": "react 80% 功能"
                  },
                  {
                    "path": "5.轮子索引/3.前端库/react/手写 Hooks.md",
                    "content": "#handwritten #react/hooks  #docs/how-to-guides \n \n## 手写 React Hooks\n\n* Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n* 凡是 use 开头的 React API 都是 Hooks\n\n## Hook 是什么\n\nHook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。\n\n## 为什么使用 Hooks\n\n引用官网描述\n\n* ##### 在组件之间复用状态逻辑很难\n\n  可能要用到 render props （渲染属性）或者 HOC（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素）.如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。\n* ##### 复杂组件变得难以理解\n\n  组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug\n* ##### 难以理解的 class\n\n  this 指向问题：父组件给子组件传递函数时，必须绑定 this\n\n## Hook 规则\n\n* 只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用\n* 只在 React 函数中调用 Hook 在 React 的函数组件中调用 Hook 在自定义 Hook 中调用其他 Hook\n\n## 利用 eslint 做 hooks 规则检查\n\n使用 eslint-plugin-react-hooks 来检查代码错误\n\n```js\n{\n  \"plugins\": [\"react-hooks\"],\n  // ...\n  \"rules\": {\n    \"react-hooks/rules-of-hooks\": 'error',// 检查 Hook 的规则\n    \"react-hooks/exhaustive-deps\": 'warn' // 检查 effect 的依赖\n  }\n}\n复制代码\n```\n\n## useState\n\nuseState 会返回一个数组：一个 state，一个更新 state 的函数。\n\n类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并，而是直接替换\n\n```js\n// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useState(initialState) {\n  hookStates[hookIndex] = hookStates[hookIndex] || initialState;\n  // 利用闭包维护函数调用位置\n  let currentIndex = hookIndex;\n  function setState(newState) {\n    // 判断传入的state是否为函数,如果是把prevState传入\n    if (typeof newState === \"function\") {\n      // 重新复制给newState\n      newState = newState(hookStates[hookIndex]);\n    }\n    // 更新state\n    hookStates[currentIndex] = newState;\n    // 触发视图更新\n    render();\n  }\n  // 返回数组形式，解构可写成任意变量\n  return [hookStates[hookIndex++], setState];\n}\n复制代码\n```\n\n\n\n## useEffect\n\nuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API\n\n与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新视图，这让你的应用看起来响应更快。 在特殊情况（例如测量布局），有单独的 useLayoutEffect Hook，使用与 useEffect 相同\n\n```js\n//保存状态的数组\nlet hookStates = [];\n//索引\nlet hookIndex = 0;\n\nfunction useEffect(callback, dependencies) {\n  if (hookStates[hookIndex]) {\n    // 非初始调用\n    let lastDependencies = hookStates[hookIndex];\n    // 判断传入依赖项跟上一次是否相同\n    let same = dependencies.every(\n      (item, index) => item === lastDependencies[index]\n    );\n    if (same) {\n      hookIndex++;\n    } else {\n      hookStates[hookIndex++] = dependencies;\n      callback();\n    }\n  } else {\n    // 初始调用\n    hookStates[hookIndex++] = dependencies;\n    callback();\n  }\n}\n\n```\n\n## useMemo\n\n允许你通过「记住」上一次计算结果的方式在多次渲染的之间缓存计算结果\n\n使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要\n\n```js\n// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useMemo(factory, dependencies) {\n  if (hookStates[hookIndex]) {\n    // 非首次\n    let [lastMemo, lastDependencies] = hookStates[hookIndex];\n\n    // 判断传入依赖项跟上一次是否相同\n    let same = dependencies.every(\n      (item, index) => item === lastDependencies[index]\n    );\n    if (same) {\n      hookIndex++;\n      return lastMemo;\n    } else {\n      // 只要有一个依赖变量不一样的话\n      let newMemo = factory();\n      hookStates[hookIndex++] = [newMemo, dependencies];\n      return newMemo;\n    }\n  } else {\n    // 首次调用\n    let newMemo = factory();\n    hookStates[hookIndex++] = [newMemo, dependencies];\n    return newMemo;\n  }\n}\n复制代码\n```\n\n## useCallback\n\n允许你在重新渲染之间保持对相同的回调引用以使得 shouldComponentUpdate 继续工作\n\n```js\n// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useCallback(callback, dependencies) {\n  if (hookStates[hookIndex]) {\n    // 非首次\n    let [lastCallback, lastDependencies] = hookStates[hookIndex];\n\n    let same = dependencies.every(\n      (item, index) => item === lastDependencies[index]\n    );\n    if (same) {\n      hookIndex++;\n      return lastCallback;\n    } else {\n      // 只要有一个依赖变量不一样的话\n      hookStates[hookIndex++] = [callback, dependencies];\n      return callback;\n    }\n  } else {\n    // 首次调用\n    hookStates[hookIndex++] = [callback, dependencies];\n    return callback;\n  }\n}\n复制代码\n```\n\n## memo\n\n```js\nfunction memo(OldFunctionComponent) {\n  return class extends React.PureComponent {\n    render() {\n      return <OldFunctionComponent {...this.props} />;\n    }\n  };\n}\n复制代码\n```\n\n## useContext\n\n接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值 useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。仍然需要在上层组件树中使用 <MyContext.Provider> 来为下层组件提供 context\n\n```js\nfunction useContext(context) {\n  return context._currentValue;\n}\n\n// 父组件\nconst CountCtx = React.createContext();\nfunction ParentComp() {\n  const [state, setState] = React.useState({ number: 0 });\n  return (\n    <CountCtx.Provider value={{ state, setState }}>\n      <Child />\n    </CountCtx.Provider>\n  );\n}\n\n// 子组件\nfunction Child() {\n  let { state, setState } = useContext(CountCtx);\n  return (\n    <div>\n      <p>{state.number}</p>\n      <button onClick={() => setState({ number: state.number + 1 })}>\n        add\n      </button>\n    </div>\n  );\n}\n复制代码\n```\n\n## useRef\n\nuseRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数 useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的 ref 对象都是同一个（注意使用 React.createRef ，每次重新渲染组件都会重新创建 ref）\n\n```js\nlet lastRef;\n\nfunction useRef(value) {\n  lastRef = lastRef || { current: value };\n  return lastRef;\n}\n```\n\n## useReducer\n\nuseReducer 和 redux 中 reducer 很像 useState 内部就是靠 useReducer 来实现的\n\n```js\n// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useReducer(reducer, initialState) {\n  hookStates[hookIndex] = hookStates[hookIndex] || initialState;\n\n  let currentIndex = hookIndex;\n  function dispatch(action) {\n    hookStates[currentIndex] = reducer\n      ? reducer(hookStates[currentIndex], action)\n      : action;\n    // 触发视图更新\n    render();\n  }\n  return [hookStates[hookIndex++], dispatch];\n}\n\n// useState可以使用useReducer改写\nfunction useState(initialState) {\n  return useReducer(null, initialState);\n}\n复制代码\n```\n\n## 参考\n\n[Hook 规则](https://link.juejin.cn/?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhooks-rules.html \"https://react.docschina.org/docs/hooks-rules.html\")\n\n[React Hooks 详解 【近 1W 字】+ 项目实战](https://juejin.cn/post/6844903985338400782 \"https://juejin.cn/post/6844903985338400782\")\n\n## 推荐\n\n[React Hooks 父组件中获取子组件实例值](https://juejin.cn/post/6854573209644171277 \"https://juejin.cn/post/6854573209644171277\")\n\n[React Hooks 中 useRef 的优雅使用](https://juejin.cn/post/6854573209639976974 \"https://juejin.cn/post/6854573209639976974\")\n",
                    "title": "手写 Hooks"
                  },
                  {
                    "path": "5.轮子索引/3.前端库/react/手写 react.md",
                    "content": "#docs/how-to-guides  #react \n \n \n本文主要通过手写一个简版的 React，旨在了解 Facebook 团队使用两年多时间重构的 Fiber 架构到底做了些什么？从而对 React 基本原理有一个直观的认识。\n\n## 青铜 – React、JSX、DOM elements 如何工作的？\n\n本文主要基本 React 16.8 版本进行实现。\n\n下面先实现一个最简单的页面渲染，快速了解 JSX、React、DOM 元素的联系。\n\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n);\nconst container = document.getElementById(\"root\");\nReactDOM.render(element, container);\n```\n\n实现一个最简单的 React 应用，只需要上面的三行代码就够了 👆，下面我们也将拆分三步进行分析，\n\n1. 创建 React 元素（React Element）\n2. 获取根节点 root\n3. 将 React 元素渲染到页面上\n\n### 1. JSX 是如何被解析的 - Babel\n\n```\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n);\n```\n\n用 JSX 创建了一个 react 元素，它不是有效的 JS，其实它是被 babel 解析为如下代码：\n\n```\n\"use strict\";\nconst element = /*#__PURE__*/ React.createElement(\n  \"div\",\n  {\n    id: \"foo\",\n  },\n  /*#__PURE__*/ React.createElement(\"a\", null, \"bar\"),\n  /*#__PURE__*/ React.createElement(\"b\", null)\n);\n```\n\n可以看到 Babel 会将 JSX 转换成 `React.createElement()` 方法，其中 `createElement()` 方法接收三个参数，分别是元素类型 `type`、元素属性 `props`、和子元素 `children`，后面我们会实现这个方法。\n\n### 2. React 虚拟 DOM 对象的设计\n\nReact 的核心思想是在内存中维护一棵虚拟 DOM 树，当数据变化时更新虚拟 DOM，得到一棵新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中。\n\n首先来看下基本的虚拟 DOM 结构：\n\n```\nconst element = {\n  type: \"div\",\n  props: {\n    id: \"foo\",\n    children: [\n      {\n        type: \"a\",\n        props: {\n          children: [\"bar\"],\n        },\n      },\n      {\n        type: \"b\",\n        props: {\n          children: [],\n        },\n      },\n    ],\n  },\n};\n```\n\n可以看出 React.createElement() 方法其实就是返回了一个虚拟 DOM 对象。下面我们来实现 `createElement()` 这个方法，\n\n```\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map((child) =>\n        // 这里我们区分下基本类型和引用类型，用 createTextElement 来创建文本节点类型\n        typeof child === \"object\" ? child : createTextElement(child)\n      ),\n    },\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  };\n}\n```\n\n可以看到通过 Babel 编译后的 element 对象，其实是对 React.createElement()的递归调用所返回的数据结构 - 一个嵌套的虚拟 DOM 结构。\n\n### 3. 实现 render() 方法\n\n有了虚拟 DOM 结构，接下来需要根据它来生成真实节点并渲染到页面上，也就是 render() 方法的工作。基本分为以下四步：\n\n* 创建不同类型节点\n* 添加属性 props\n* 遍历 children，递归调用 render\n* 将生成的节点 append 到 root 根节点上\n\n```\nfunction render(element, container) {\n  // 1. 创建不同类型的DOM节点\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type);\n\n  // 2.为 DOM 节点添加属性props (排查children属性)\n  const isProperty = (key) => key !== \"children\";\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach((name) => {\n      dom[name] = element.props[name];\n    });\n\n  // 3. 遍历children，递归调用 render\n  element.props.children.forEach((child) => render(child, dom));\n\n  // 4. 将 DOM 节点添加至 root 根节点\n  container.appendChild(dom);\n}\n```\n\n此时还有一个问题，在使用 JSX 语法时，Babel 默认寻找 React.createElement 方法进行编译（这也是一般项目中 app.tsx 入口文件中虽然没有显式用到 react，但必须 import react 的原因），那么如何告诉 Babel 使用自己定义的 createElement 方法来编译呢？ JSX 支持使用以下注释的方式来告诉 Babel，使用指定的方法来进行编译：\n\n```\nconst MyReact = {\n  createElement,\n  render,\n};\n/** @jsx MyReact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n);\nfunction createElement() {\n  //...\n}\n```\n\n这样我们就通过实现一个简单的页面渲染，快速了解了 JSX、React、DOM 元素的联系。至此，我们就有了一个简单的 React，实现了将 JSX 渲染到页面上了。\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/184065/36/5735/53154/60ac6cdbE4b1ec8cb/623799a86925bdd7.png)\n\n## 白银 – Fiber 架构\n\n但是第一部分的这种递归调用的方式还是存在问题的。一旦我们开始渲染 render，直到我们渲染完整个完整的 DOM 树之前，我们是没法中止的，这会造成什么问题呢？\n\n在浏览器中，页面是一帧一帧绘制出来的，一般情况下设备的屏幕刷新率为 1s 60 次，每帧绘制大概需要 16ms。在这一帧中浏览器要完成很多事情！ 如果在某个阶段执行任务特别长，时间已经明显超过了 16ms，那么就会阻塞页面的渲染，从而出现卡顿现象，也就是常说的掉帧！\n\n![](https://img11.360buyimg.com/imagetools/jfs/t1/193075/32/4809/114056/60ac90d7E53b2b65d/8ec8e2abf9660a08.png)\n\nReact 16 之前就是采用这种递归调用的遍历方式，执行栈会越来越深，而且不能中断，中断后就不能恢复了。如果递归花了 100ms，则这 100ms 浏览器是无法响应的，代码执行时间越长卡顿越明显。\n\n为了解决以上的痛点问题，React 希望能够彻底解决主线程长时间占用问题，于是引入了 Fiber 架构。React Fiber 架构是怎么做的呢？\n\n* step1. 让 React 渲染的过程可以被中断，可以将控制权交回浏览器，让浏览器及时地响应用户的交互 -> 异步可中断\n* step2. 通过将工作任务拆分成一个个小的工作单元 units 分别来执行 -> Fiber\n\n### 1. window.requestIdleCallback()\n\n我们先来解决第一个问题，如何让 React 渲染的过程可以被中断，可以将控制权交回浏览器，让浏览器及时地响应用户的交互，等浏览器空闲后再恢复渲染？\n\n其实浏览器提供了相关实现的 API：`requestIdleCallback(callback, {timeout: 1000})`， 从字面意思可以理解成 “让浏览器在‘有空’的时候就执行我们的回调”\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/178407/10/5842/142317/60ac9585E8a01d5ad/419cf27e552077f8.png)\n\n我们来简单看一个关于 requestIdleCallback 例子 ~\n\n```\n// 定义一个任务队列\nlet taskQueue = [\n  () => {\n    console.log(\"task1 start\");\n    console.log(\"task1 end\");\n  },\n  () => {\n    console.log(\"task2 start\");\n    console.log(\"task2 end\");\n  },\n  () => {\n    console.log(\"task3 start\");\n    console.log(\"task3 end\");\n  },\n];\n\n// 执行工作单元。每次取出队列中的第一个任务，并执行\nlet performUnitOfWork = () => {\n  taskQueue.shift()();\n};\n\n/**\n * callback 接收默认参数 deadline，timeRamining 属性表示当前帧还剩多少时间\n */\nlet workloop = (deadline) => {\n  console.log(`此帧的剩余时间 --> ${deadline.timeRemaining()} ms`);\n  // 此帧剩余时间大于0\n  while (deadline.timeRemaining() > 0 && taskQueue.length > 0) {\n    performUnitOfWork();\n    console.log(`还剩时间: ${deadline.timeRemaining()} ms`);\n  }\n  // 否则应该放弃执行任务控制权，把执行权交还给浏览器。\n  if (taskQueue.length > 0) {\n    // 申请下一个时间片\n    requestIdleCallback(workloop);\n  }\n};\n\n// 注册任务，告诉浏览器如果每一帧存在空闲时间，就可以执行注册的这个任务\nrequestIdleCallback(workloop);\n```\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/191806/40/4957/150578/60acc124Eea52c221/855fb8faf3ea20a5.jpg)\n\n可以看到在当前帧还剩 15ms 时，浏览器依次完成了完成了三个任务，当前帧时间还比较充裕。下面增加一个 sleep 时间 20ms，也就是说每个任务都超过一帧的时间 16ms, 也就是执行完每一个任务后当前帧是没有时间了的，需要把控制权交给浏览器\n\n```\n// 每个任务都超过了16ms的时间\nlet taskQueue = [\n  () => {\n    console.log(\"task1 start\");\n    sleep(20);\n    console.log(\"task1 end\");\n  },\n  () => {\n    console.log(\"task2 start\");\n    sleep(20);\n    console.log(\"task2 end\");\n  },\n  () => {\n    console.log(\"task3 start\");\n    sleep(20);\n    console.log(\"task3 end\");\n  },\n];\n\nlet sleep = (delay) => {\n  for (let start = Date.now(); Date.now() - start <= delay; ) {}\n};\n// 其他逻辑不变\nlet performUnitOfWork = () => {\n  taskQueue.shift()();\n};\n// ...\n```\n\n![](https://img10.360buyimg.com/imagetools/jfs/t1/194238/19/4860/164905/60acc298Edbc7d481/8dbe8b2bc482f60a.jpg)\n\n可以看到浏览器每次执行一个任务，由于剩余时间为 0ms，都会把控制权交给浏览器，等待下一帧有时间时再次执行 workloop 方法。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a67307e78d94b28a9c7fa25fbfb1858~tplv-k3u1fbpfcp-zoom-1.image)\n\n但目前 `requestIdleCallback` 只有部分浏览器支持，其实 React 是自己实现了一个 `requestIdleCallback()`，它模拟将回调延迟到‘绘制操作’之后执行。React 自身的实现还是比较复杂的，本文我们仅使用 `requestIdleCallback()` 来模拟实现 React 的异步可中断机制即可。\n\n下面我们应用这个 API 来进行实现。\n\n```\n// 1. 定义下一次执行的工作单元\nlet nextUnitOfWork = null\n​\n// 2. 定义回调函数\nfunction workLoop(deadline) {\n  // 标示位\n  let shouldYield = false;\n\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n\n  // 提前申请下一个时间片\n  requestIdleCallback(workLoop)\n}\n\n// 3. 向浏览器注册回调事件，申请时间片\nrequestIdleCallback(workLoop)\n​\n// 4. 执行工作单元，并返回下一个工作单元\nfunction performUnitOfWork(nextUnitOfWork) {\n  // ...\n}\n```\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/179810/16/5799/55303/60ac9722Ef5fa7e6a/79b14529aa318528.png)\n\n了解了 React 对 requestIdleCallback() 的实现，下面我们来看看 React 对工作单元是如何进行拆分的？\n\n### 2. 拆分工作单元 - 初识 Fiber\n\nFiber 是对 React 核心算法的重构，Facebook 团队使用两年多的时间去重构 React 的核心算法，并在 React16 以上的版本中引入了 Fiber 架构。\n\n#### Fiber 既是一种数据结构，又是一个工作单元\n\n##### 1. Fiebr 作为数据结构\n\nReact Fiber 机制的实现，就是依赖于下面的这种数据结构 - 链表实现的。其中每个节点都是一个 fiber。一个 fiber 包括了 child（第一个子节点）、sibling（兄弟节点）、parent（父节点）等属性。Fiber 节点中其实还会保存节点的类型、节点的信息（比如 state，props）、节点对应的值等。\n\n```\n<div>\n  <h1>\n    <p />\n    <a />\n  </h1>\n  <h2 />\n</div>\n```\n\n![](https://img14.360buyimg.com/imagetools/jfs/t1/177797/8/5953/54048/60aca801E971eed5a/c2b1b3742e96d9b1.png)\n\n##### 2. Fiber 作为工作单元\n\n将它视作一个执行单元，每次执行完一个 “执行单元” （下面的 nextUnitOfWork）, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去。\n\n```\nwhile (nextUnitOfWork) {\n  nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  // 判断当前帧是否还有剩余时间\n}\n```\n\n要想实现 Fiber 结构需要分为两步，一是如何创建 Fiber 树，二是如何遍历 Fiber 树。\n\nReact 的思想就是设法将组件的递归更新，改成链表的依次执行。所以接下来我们先将之前的虚拟 DOM 树，转换成 Fiber 树。\n\n![](https://img14.360buyimg.com/imagetools/jfs/t1/147366/9/19588/425648/60aca8dcE1416d3fc/d1860a69445d0940.jpg)\n\n#### 具体 Fiber 实现\n\n因为是 render 方法中的递归调用不可中断的方式造成的性能问题，接下来我们来优化 render 方法\n\n```\n// 针对前文的 render 方法，只保留创建节点部分的逻辑，并重命名为createDom。\nfunction createDom(fiber) {\n  // 1. 创建不同类型的DOM节点\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type);\n\n  // 2.为 DOM 节点添加属性props (没有children属性)\n  const isProperty = (key) => key !== \"children\";\n  Object.keys(fiber.props)\n    .filter(isProperty)\n    .forEach((name) => {\n      dom[name] = fiber.props[name];\n    });\n\n  return dom;\n}\n```\n\n接下来定义工作单元，并在 render 方法中进行初始化。\n\n```\nlet nextUnitOfWork = null;\n\nfunction render(element, container) {\n  // 定义初始工作单元（定义初始Fiber根节点）\n  nextUnitOfWork = {\n    dom: container, // root\n    props: {\n      children: [element], // DOM\n    },\n  };\n  console.log(\"1. 初始 Fiber\", nextUnitOfWork);\n}\n```\n\n打印一下此时的 fiber 结构，可以看下初始 fiber 结构对应的就是 fiber 树的根节点。dom 属性中保存中 root 根节点、props.children 中保存着初始的虚拟 DOM 结构（后面对 fiber 树中的每个 fiber 节点的依次创建，依据的就是完整的虚拟 DOM 结构。）\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/195769/37/4893/306161/60acaae4Ea54196e2/a12b7d6a690a4a98.jpg)\n\n根据前面对 requestIdleCallback 的理解，下面我们定义一个事件循环，并在 requestIdleCallback()方法中进行回调事件注册。\n\n```\nfunction workLoop(deadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n  if (nextUnitOfWork) {\n    requestIdleCallback(workLoop);\n  }\n}\n\nrequestIdleCallback(workLoop);\n```\n\n那么这个 performUnitOfWork() 方法，都做了哪些工作呢？\n\n1. 把元素添加到 dom 中\n2. 当从根 Fiber 向下创建 Fiber 时，我们始终是为子节点创建 Fiber（逐步创建 fiber 链表的过程）\n3. 遍历 fiber 树，找到下一个工作单元（遍历 fiber 树的过程）\n\n```\n/**\n * 执行工作单元都做了什么❓\n */\nfunction performUnitOfWork(fiber) {\n  //  1. 把元素添加到 dom 中\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  }\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom);\n  }\n\n  // 2. 当从根 Fiber 向下创建 Fiber 时，我们始终是为子节点创建Fiber\n  const elements = fiber.props.children; // 之前的vDOM结构\n  let index = 0;\n  let prevSibling = null;\n  while (index < elements.length) {\n    const element = elements[index];\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      dom: null,\n      parent: fiber,\n    };\n    // 第一个子元素 作为 child，其余的 子元素 作为 sibling\n    if (index === 0) {\n      fiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n    prevSibling = newFiber;\n    index++;\n  }\n  console.log(\"2. 每次执行工作单元后的Fiber树\", fiber);\n\n  // 步骤2实现了创建 fiber树的过程 👆👆👆\n  // 下面的步骤3实现遍历 fiber的过程 👇👇👇\n\n  // 3. 遍历fiber树，找到下一个工作单元\n  if (fiber.child) {\n    return fiber.child;\n  }\n  while (fiber) {\n    if (fiber.sibling) {\n      return fiber.sibling;\n    }\n    fiber = fiber.parent;\n  }\n}\n```\n\n可以看到每一次执行工作单元，都逐渐完善了 fiber 结构，结构中包含了当前处理节点的 parent、child 以及 sibling 的指向。\n\n![](https://img12.360buyimg.com/imagetools/jfs/t1/194826/8/4780/769397/60acaf20Ee96e4e08/11372b05fd645301.jpg)\n\n最后获取页面根节点，并渲染到页面上。\n\n```\nconst container = document.getElementById(\"root\");\nMyReact.render(element, container);\n```\n\n## 黄金 – Commit 提交\n\n我们在上面的 performUnitOfWork 里 ，每次都把元素直接添加到 DOM 上。这里会有一个问题，就是浏览器随时都有可能中断我们的操作，这样呈现给用户的就是一个不完整的 UI，所以我们需要做出些改动，就是让所有工作单元执行完后，我们再一并进行所有 DOM 的添加。也就是说在 react 不同阶段的机制不同，\n\n* Render 阶段，是可中断的\n* Commit 阶段，是不可中断的\n\n下面我们标注出需要改动的部分\n\n```\nfunction performUnitOfWork(fiber) {\n  // 把元素添加到 dom 中\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  }\n  // step1. 去掉提交DOM节点的部分，后面进行统一提交\n  // if (fiber.parent) {\n  //   fiber.parent.dom.appendChild(fiber.dom);\n  // }\n\n  // 为元素的子元素都创建一个 fiber 结构（没有子元素跳过）\n  const elements = fiber.props.children;\n  let index = 0;\n  let prevSibling = null;\n  while (index < elements.length) {\n    const element = elements[index];\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      dom: null,\n      parent: fiber,\n    };\n    if (index === 0) {\n      fiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n    prevSibling = newFiber;\n    index++;\n  }\n\n  // 找到下一个工作单元（遍历fiber树）\n  if (fiber.child) {\n    return fiber.child;\n  }\n  while (fiber) {\n    if (fiber.sibling) {\n      return fiber.sibling;\n    }\n    fiber = fiber.parent;\n  }\n}\n\n// step2. 保存一个工作中的 fiber 树 wipRoot (work in progress root)并在render中初始化，便于后续 commit 整颗 fiber 树\n// 后续执行 performUnitOfWork时每次还是操作nextUnitOfWork\nlet wipRoot = null;\nfunction render(element, container) {\n  // 初始化需要跟踪fiber的根节点，并赋值给 nextUnitOfWork\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  };\n  nextUnitOfWork = wipRoot;\n}\n\n// step3 workLoop中判断所有工作单元都执行完后，一并进行“提交”操作\nfunction workLoop(deadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n  // 进行“提交”操作\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n  requestIdleCallback(workLoop);\n}\n\n// 4. 创建commit函数，将所有元素往 dom 树上添加\nfunction commitRoot() {\n  commitWork(wipRoot.child);\n  wipRoot = null;\n}\n\n// 进行递归提交\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return;\n  }\n  const domParent = fiber.parent.dom;\n  domParent.appendChild(fiber.dom);\n  commitWork(fiber.child);\n  commitWork(fiber.sibling);\n}\n```\n\n[完整 DEMO](https://github.com/sdyz/my-simple-react/tree/master)\n\n可以看到页面已成功渲染出来啦!\n\n![](https://img10.360buyimg.com/imagetools/jfs/t1/180741/25/5836/317432/60acb3a0Eb089614a/6e7614a8cf52c213.jpg)\n\n至此，我们已经完成了一个简版 React 的实现，包括了 React 如何将 JSX 元素转换成我们熟知的虚拟 DOM 结构；Fiber 架构是如何实现优化拆分工作单元、实现异步可中断机制的；以及如何将一个 Fiber 树进行进行遍历、提交至页面进行渲染的。\n\n当然，react 非常出名的 Reconciliation 协调算法本文还没有提到，它是 react 进行更新调度的核心机制，极大的提高的 react 的性能，后续有机会会继续进行探讨。\n\n最后放两张大神 [Lin Clark presentation in ReactConf 2017 ](https://www.youtube.com/watch?v=ZCuYPiUIONs)演讲的示意图（Lin Clark 这个演讲太经典了）。就好比一个小人儿在潜水，如果他一直潜水并且越潜越深，那么它是无法感知岸上情况的（执行栈会越来越深、而且不能中断）；第二张图就好像每次潜水一段时间就回到岸上看一下是否有新的任务要做（异步可中断，每次判断是否有优先级更高的任务），变得更加灵活了。\n\n![](https://img14.360buyimg.com/imagetools/jfs/t1/175480/23/11548/842462/60ace841E478d9f26/a89c55124239fbf2.jpg)\n\n当然，引用尤雨溪大神说的话：React Fiber 本质上是为了解决 React 更新低效率的问题，不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背。\n\n完！~ 撒花 ✿✿ ヽ(°▽°)ノ ✿\n\n### 参考\n\n[Build your own React](https://pomb.us/build-your-own-react/)\n\n[Lin Clark - A Cartoon Intro to Fiber - React Conf 2017](https://www.youtube.com/watch?v=ZCuYPiUIONs)\n\n[React 技术揭秘](https://react.iamkasong.com/)\n",
                    "title": "手写 react"
                  },
                  {
                    "path": "5.轮子索引/3.前端库/落地微前端 qiankun 理论与实践指北.md",
                    "content": "#microFrontEnd  #docs/how-to-guides \n\n \n\n> “一千个人眼里有一千个哈姆雷特” 本文仅是作者这段时间对微前端的思考与感悟，文笔拙劣，多多海涵。微前端的实现方式有很多种，但是微前端并不完美。只有适合自己、适合团队的才是最佳实践。\n\n由于本文较长（PS：本人懒得分篇），目录一至目录七偏理论知识，目录七之后为实践操作与思考，大家可以适当的跳跃来看\n\n**微前端是什么？**\n\n- 微前端不是特指某一项技术，而是一种思想。是由2016年 ThoughtWorks Technology Radar 中提出的，借鉴后端微服务的架构模式，将 Web 应用由单一的单体应用转变为多个小型前端应用，聚合为一的应用。\n- 所以微前端不是指具体的库，不是指具体的框架，不是指具体的工具，而是一种理想与架构模式。\n- 微前端的核心三大原则就是：**独立运行、独立部署、独立开发** 所以满足这些的最佳人选就是 “iframe”!!!\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/E452D799B846E7B1036D6B88CC45A4DF.jpg)image.png\n\n**微前端能解决我们什么问题？**\n\n举例: 一个持续多年的应用，经历几年的业务的更新迭代，当项目发展到一定程度的时候就会遇到以下问题\n\n1. 业务模块之间不断的堆叠，交错引用，业务耦合如何治理？\n2. 老技术、老代码不敢动，新技术、新架构又想用？\n3. 万年技术债？既要跟随业务敏捷迭代，又要保证代码库向好发展，旧的框架类库如何平稳升级？\n4. 一个项目多个团队开发，你冲突我，我冲突你，如何解决并行开发的冲突？\n5. 代码库持续膨胀，难以维护的项目代码，是屎上雕花？还是从头再来？\n\n有没有一种可以分解复杂度，提升协作效率，支持灵活扩展的架构模式？**微前端应运而生—— “更友好的iframe”** 将一个巨无霸应用拆解为一个个独立的微应用应用，而用户又是无感知的！\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/263482E4786C524CAC6AA51A5E68BA82.jpg)微前端核心原则：\n\n- 技术栈无关: 主应用不限制子应用接入的技术栈，每个应用的技术栈选型可以配合业务情景选择。\n- 独立开发、独立部署：既可以组合运行，也可以单独运行。\n- 环境隔离：应用之间 JavaScript、CSS 隔离避免互相影响\n- 消息通信：统一的通信方式，降低使用通信的成本\n- 依赖复用：解决依赖、公共逻辑需要重复维护的问题\n\n这意味着我们可以循序渐进的进行巨石应用的拆解，去技术升级、去架构尝试、去业务拆解等等。以低成本、低风险的进行，**为项目带来更多可能性**\n\n**我们的项目适不适合改造成微前端项目模式？**\n\n看我们的项目满足不满足微前端化，先看能不能满足以下几点即可。\n\n- 是否有明确的业务边界，业务是否高度集中。\n- 业务是否高度耦合、项目是否足够庞大到需要拆分。\n- 团队中存在多个技术栈并且无法统一，需要接入同一套主系统。\n- 技术老旧，扩展困难，维护吃力不讨好。\n- 开发协同、部署维护等工作，效率低下，一着不慎，满盘皆输。\n\n**注意：没有迫切的需求接入微前端，只会带来额外的负担，我们要知道我们使用微前端是为了什么？**\n\n# 二、微前端技术选型\n\n微前端实现方案对比\n\n| 技术方案           | 描述                                                         | 技术栈     | 优点                                                         | 缺点                                                         | 单独构建 / 部署 | 构建速度 | SPA 体验 | 项目侵入性 | 学习成本 | 通信难度 |\n| :----------------- | :----------------------------------------------------------- | :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- | :------- | :------- | :--------- | :------- | :------- |\n| iframe             | 每个微应用独立开发部署，通过 iframe的方式将这些应用嵌入到父应用系统中 | 无限制     | 1. 技术栈无关，子应用独立构建部署 2. 实现简单，子应用之间自带沙箱，天然隔离，互不影响 | 体验差、路由无法记忆、页面适配困难、无法监控、依赖无法复用，兼容性等都具有局限性，资源开销巨大，通信困难 | 支持            | 正常     | 不支持   | 高         | 低       | 高       |\n| Nginx 路由转发     | 通过Nginx配置实现不同路径映射到不同应用                      | 无限制     | 简单、快速、易配置                                           | 在切换应用时触发发页面刷新，通信不易                         | 支持            | 正常     | 不支持   | 正常       | 低       | 高       |\n| Npm 集成           | 将微应用抽离成包的方式，发布Npm中，由父应用依赖的方式使用，构建时候集成进项目中 | 无限制     | 1. 编译阶段的应用，在项目运行阶段无需加载，体验流畅 2.开发与接入成本低，容易理解 | 1. 影响主应用编译速度和打包后的体积 2. 不支持动态下发，npm包更新后，需要重新更新包，主应用需要重新发布部署 | 不支持          | 慢       | 支持     | 高         | 高       | 正常     |\n| 通用中心路由基座式 | 微应用可以使用不同技术栈；微应用之间完全独立，互不依赖。统一由基座工程进行管理，按照DOM节点的注册、挂载、卸载来完成。 | 无限制     | 子应用独立构建，用户体验好，可控性强，适应快速迭代           | 学习与实现的成本比较高，需要额外处理依赖复用                 | 支持            | 正常     | 支持     | 高         | 高       | 正常     |\n| 特定中心路由基座式 | 微应用业务线之间使用相同技术栈；基座工程和微应用可以单独开发单独部署；微应用有能力复用基座工程的公共基建。 | 统一技术栈 | 子应用独立构建，用户体验好，可控性强，适应快速迭代           | 学习与实现的成本比较高，需要额外处理依赖复用                 | 支持            | 正常     | 支持     | 高         | 高       | 正常     |\n| webpack5 模块联邦  | webpack5 模块联邦 去中心模式、脱离基座模式。每个应用是单独部署在各自的服务器，每个应用都可以引用其他应用，也能被其他应用所引用 | 统一技术栈 | 基于webpack5，无需引入新框架，学习成本低，像引入第三方库一样方便，各个应用的资源都可以相互共享应用间松耦合，各应用平行的关系 | 需要升级Webpack5技术栈必须保持一致改造旧项目难度大           | 支持            | 正常     | 支持     | 低         | 低       | 正常     |\n\n对于选择困难同学来说，可以参考以下纬度进行方案技术的选型\n\n| 参考纬度 | 是否能支持未来的迭代                                         |\n| :------- | :----------------------------------------------------------- |\n| 稳定性   | 该方案是否经历了社区的考验，有较多的成熟案例，同时保持较高的 活跃性 |\n| 可拓展性 | 支持定制化开发，提供较高的可拓展能力，同时成本可以在接受范围内 |\n| 可控性   | 发生问题后，能够在第一时间内进行问题排查，以最快的响应速度来处理问题，修复的方案是否会依赖于外部环境 |\n\n市面框架对比：\n\n- magic-microservices 一款基于 Web Components 的轻量级的微前端工厂函数。\n- icestark 阿里出品，是一个面向大型系统的微前端解决方案\n- single-spa 是一个将多个单页面应用聚合为一个整体应用的JavaScript 微前端框架\n- qiankun 蚂蚁金服出品，基于 single-spa 在 single-spa 的基础上封装\n- EMP YY出品，基于Webpack5 Module Federation 除了具备微前端的能力外，还实现了跨应用状态共享、跨框架组件调用的能力\n- MicroApp 京东出品，一款基于WebComponent的思想，轻量、高效、功能强大的微前端框架\n\n综合以上方案对比之后，我们确定采用了 `qiankun` 特定中心路由基座式的开发方案，原因如下：\n\n- 保证技术栈统一 Vue、微应用之间完全独立，互不影响。\n- 友好的“微前端方案“，与技术栈无关接入简单、像iframe一样简单\n- 改造成本低，对现有工程侵入度、业务线迁移成本也较低。\n- 和原有开发模式基本没有不同，开发人员学习成本较低。\n- qiankun 的微前端有 3 年使用场景以及 Issue 问题解决积累，社区也比较活跃，在踩坑的路上更容易自救～\n\n# 三、你需要明确的\n\n> 微前端并不是万能的”解药“，没有正确治理，所有的 codebase 的归宿都是”屎山”\n\n- **qiankun不是一个完整的微前端解决方案！**\n- **qiankun不是一个完整的微前端解决方案！！**\n- **qiankun不是一个完整的微前端解决方案！！！**\n\n**1.微前端的运行时容器**\n\n- qiankun 所帮你解决的这一块实际上是微前端的运行时容器，这是整个微前端工程化里面其中一个环节\n- 从这个角度来讲 qiankun 不算是一个完整的微前端解决方案，而是微前端运行时容器的一个完整解决方案，当你用了 qiankun 之后，你几乎能解决所有的微前端运行时容器的问题，但是更多的一些涉及工程和平台的问题，则需要我们去思考与处理。\n- 我们的版本管控、配置下发、监控发布，安全检测、等等这些怎么做，都不是 qiankun 作为一个库所能解答的，这些问题得根据具体情况，来选择适合自己的解决方案**2. 迁移成本**\n- 对于老旧项目的接入，很难做到零成本迁移，在开发的时候要预留足够的踩坑，魔改代码的时间。如果是已经维持几年堆叠的屎山需要做好因为不规范编码，所产生的各种奇怪的兼容性问题，这个时候你甚至会怀疑，“微前端是否真的有必要?\"**3. 技术栈的选择**\n- 微前端的核心不是多技术共存，而是分解复杂度，提升协作效率，支持灵活扩展，能把“一堆复杂的事情”变成“简单的一件事情”，但是也不是无脑使用的，广东话来说“多个香炉多只鬼”，每多一个技术栈都会增加：维护成本，兼容成本，资源开销成本，这些都会无形的拖累生产力。\n- 基座应用与微应用之间，强烈推荐使用相同的技术栈，相同的技术栈可以实现公共依赖库、UI库等抽离，减少资源开销，提升加载速度，最重要的是：“减少冲突的最好方式就是统一”，通过约束技术栈可以尽可能的减少项目之间的冲突，减少工作量与维护成本。\n\n**4. 微前端初尝试**\n\n- 对于微前端的接入最好的时候就是，刚开始不久或重要性不是特别强的项目，一方面项目具备兼容微前端的工程能力，另一方面项目使用微前端方案的成本最低，不需要改太多代码\n- 对于老旧项目的接入建议还是从边缘简单的模版入手，逐步分解。\n\n**7. 标准化才能提升生产力**\n\n- 混乱的项目会拖累生产效率，同时混乱的微前端也会加剧内耗，所以只有标准化才能提升生产力。\n- 解决微前端的接入问题是最简单的，但是微前端接入后的：工程化，应用监控，应用规范，应用管理才是微前端中困难的地方，如果你只是想简单的嵌入一个应用，我推荐你的使用 ”iframe“\n\n**9. qiankun 不支持 Vite ！！！**\n\n- 🚀 Link github 未来是否考虑支持 vite\n- 不建议尝试去改变目前的 qiankun，Vite的改造成本真的太高了，虽然webpack 比Vite慢，但是经过拆分的应用内容已经很小了，不会对项目有太大的拖累。\n\n**10. qiankun并不难**\n\n- 对于qiankun的学习其实大家不用很担心，好像一听微前端就很难的样子。因为 qiankun 真的很简单满打满算 10个API 都没有，接下来让我们一起走进qiankun的世界吧～～\n- 🚀 Link qiankun 官网文档\n\n# 四、微应用拆分规则\n\n> 微应用的拆与合思考：拆的是系统复杂度，合的是系统复用度 核心原则：高内聚，低耦合\n\n微应用的拆解没有具体规则，但是以下规则应该可以给你在进行系统拆分时提供一些依据。\n\n1. **“尽量减少彼此的通信和依赖“**，微前端的通信交互、链接跳转等操作所带来等成本其实是很大的，所以在拆分的时候尽量“完全独立，互不依赖”\n2. 微应用的拆分的时候**切忌“盲目细致拆分”**，过度拆分会导致 “做的很牛逼，但是没有用的困局”，微应用的拆分并不是一步到位的，我们要根据实际情况逐步拆分。如果一开始不知道应该划分多细，可以先粗粒度划分，然后随着需求的发展，逐步拆分。\n\n- 如：现在有一个售后管理系统，我们按业务线拆分为：客服管理，库存管理，物流管理，未来客服管理需求功能持续庞大再拆解为：智能客服、电话客服、在线客服。而这些客服，又可以嵌入供应商管理中心，商品管理中心 等项目使用。\n\n在拆分的时候我们应该尽量考虑未来场景：渐变式技术栈迁移，前端应用聚合、多系统业务复用，如何做业务解耦和代码复用。\n\n应用之间应该尽量解耦，子应用的事情就应该由子应用来做。\n\n- 如：子应用的一些标识，如：路由前缀，应用名称，根节点容器名称，依赖库的使用\n- 需要明确什么是子应用应该维护的，什么是父应用应该维护的，如果什么资源都一股脑的使用父应用下发，则会导致应用之间耦合严重。\n\n**建议按照业务域来做拆分**\n\n1. 保持核心业务的独立性，把无关的子业务拆分解耦。业务之间开发互不影响，业务之间可拆解微应用，单独打包，单独部署。\n2. 业务关联紧密的功能单元应该做成一个微应用、反之关联不紧密的可以考虑拆分成多个微应用，判断业务关联是否紧密的标准：看这个微应用与其他微应用是否有频繁的通信需求。\n3. 如果有可能说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。\n4. 分析平台差异，平台差异大可以根据平台特性拆分\n5. 分析页面结构，如果结构清晰，可以根据结构拆分\n6. 分析产品业务，将产品逻辑耦合度高的功能合并到一起\n\n# 五、引入qiankun - 在主应用中注册微应用\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/FFA5232CCD14F430CA3BB324491CA9D2.jpg)image.png\n\n**选择基座的模式？**\n\n1. **通用中心路由基座式：只有公共功能的主应用**(菜单栏、登录、退出...)不包含任何业务逻辑\n2. **特定中心路由基座式：一个含业务代码的项目**作为基座，所有新功能作为子应用引入\n\n以下案例是以Vue技术栈作为应用技术栈，建议应用之间还是统一技术栈，降低维护、上手、学习成本。越是不同技术、不同库的版本不同需要做的处理就越更多。\n\n## **qiankun 注册微应用的方式：**\n\n### **💫自动模式：使用 registerMicroApps + start，路由变化加载微应用**\n\n- 当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配\n\n1. 首次load应用，创建子应用实例，渲染。\n2. 切到其他子应用后切回，会重新创建新的子应用实例并渲染。\n3. 之前的子应用实例 qiankun 直接不要了，即使你没有手动销毁实例。\n4. 采用这种模式的话 一定要在子应用暴露的 unmount 钩子里手动销毁实例，不然会导致内存泄漏。\n\n- activeRule - `string | (location: Location) => boolean | Array<string | (location: Location) => boolean>` 必选，微应用的激活规则。\n- 支持直接配置字符串或字符串数组，如 `activeRule: '/app1'` 或 `activeRule: ['/app1', '/app2']`，当配置为字符串时会直接跟 url 中的路径部分做前缀匹配，匹配成功表明当前应用会被激活。\n- 支持配置一个 active function 函数或一组 active function。函数会传入当前 location 作为参数，函数返回 true 时表明当前微应用会被激活。如 `location => location.pathname.startsWith('/app1')`\n\n1. **自动挂载：registerMicroApps + start**\n\n```\nyarn add qiankun // ps：只需要主应用安装即可\n// 主应用/scr/main.js \nimport { registerMicroApps, start } from 'qiankun';\n\n// 1. 获取微应用配置\nconst MICRO_CONFIG = [\n  {\n    name: 'vue app', // 应用的名字 必填 唯一\n    entry: '//localhost:7100', // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n    container: '#yourContainer', // 挂载具体容器 ID\n     // 3. 根据路由匹配，激活的子应用\n    activeRule: '/yourActiveRule',\n    props: {\n        xxxx: '/' // 下发给子应用\n    }\n  }\n]\n\n// 2. 注册微应用\nregisterMicroApps(MICRO_CONFIG)\n\nstart() // 启动微服务\n```\n\n**activeRule 规则示例：此处拿官网的举例～**ctiveRule：`'/app1'`\n\n- **✅ https://app.com/app1**\n- **✅ https://app.com/app1/anything/everything**\n- 🚫 https://app.com/app2activeRule：\n\nactiveRule：`'/users/:userId/profile'`\n\n- **✅ https://app.com/users/123/profile**\n- **✅ https://app.com/users/123/profile/sub-profile/**\n- 🚫 https://app.com/users//profile/sub-profile/\n- 🚫 https://app.com/users/profile/sub-profile/\n\nactiveRule：`'/pathname/#/hash'`\n\n- **✅ https://app.com/pathname/#/hash**\n- **✅ https://app.com/pathname/#/hash/route/nested**\n- 🚫 https://app.com/pathname#/hash/route/nested\n- 🚫 https://app.com/pathname#/another-hash\n\nactiveRule：`['/pathname/#/hash', '/app1']`\n\n- **✅ https://app.com/pathname/#/hash/route/nested**\n- **✅ https://app.com/app1/anything/everything**\n- 🚫 https://app.com/pathname/app1\n- 🚫 https://app.com/app2\n- 💡 当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑。所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。\n\n### **💪手动模式：使用 loadMicroApp 手动注册微应用**\n\n1. 每个子应用都有一个唯一的实例ID，reload时会复用之前的实例\n2. 如果需要卸载则需要手动卸载 **xxxMicroApp.unmount()**\n\n由于registerMicroApps的特性，会导致路由的keep alive 失效，故本文使用 loadMicroAp + router.beforeEach 进行来达到自动注册的目的。\n\n如果微应用不是直接跟路由关联的时候，你可以选择手动加载微应用的方式会更加灵活。\n\n**手动挂载: loadMicroApps**\n\n```\n// 任意页面都可以注册\n\nimport { loadMicroApp } from 'qiankun';\n\n// 获取应用配置并手动挂载，挂载后返回挂载对象\nthis.microApp = loadMicroApp({\n    name: 'vue app', // 应用的名字 必填 唯一\n    entry: '//localhost:7100', // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n    container: '#yourContainer', // 挂载具体容器 ID\n    activeRule: '/yourActiveRule', // 根据路由 激活的子应用\n    props: {\n        xxxx: '/' // 下发给子应用\n    }\n})\n\nthis.microApp.unmount() // 手动销毁～\n```\n\n# 六、微应用挂载节点\n\n> 微应用可以挂载在页面的任意位置，微应用、微项目、微页面、微组件，一切皆有可能。\n\n- 微应用两种常见的挂载场景\n\n**第一种：路由页内挂载，把子应用内嵌页入使用**![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/34D509028BDD802E096A1660CE26F8F6.jpg)\n\n```\n// 主应用/src/views/About.vue\n<template>\n  <div class=\"about\">\n    <div id=\"sub-app-container\"></div>\n  </div>\n</template>\n```\n\n**第二种：根DOM中与主应用同级挂载，切换的时候隐藏应用，显示当前应用**![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/C9135AEAE95330D6492DA8262583BA6F.jpg)\n\n```\n// 主应用/scr/App.vue\n<template>\n    <div id=\"app\">\n        <!-- 不同的微应用 -->\n        <div v-show=\"location.hash.startsWith('#/operation')\" id=\"sub-operation-container\"></div>\n        <div v-show=\"location.hash.startsWith('#/inventory')\" id=\"sub-inventory-container\"></div>\n    </div>\n</template>\n```\n\n# 七、应用加载解析流程图\n\n> 简易的图示了qiankun是如何通过 import-html-entry 加载微应用的\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1D2BC8DBFD76D075836E4DEBEDA58591.jpg)image.png\n\n简易流程：\n\n1. qiankun 会用 原生fetch方法，请求微应用的 entry 获取微应用资源，然后通过 response.text 把获取内容转为字符串。\n2. 将 HTML 字符串传入 processTpl 函数，进行 HTML 模板解析，通过正则匹配 HTML 中对应的 javaScript（内联、外联）、css（内联、外联）、代码注释、entry、ignore 收集并替换，去除 `html/head/body` 等标签，其他资源保持原样\n3. 将收集的 `styles` 外链URL对象通过 fetch 获取 css，并将 css 内容以 `<style>` 的方式替换到原来 link标签的位置\n4. 收集 script 外链对象，对于异步执行的 JavaScript 资源会打上 `async` 标识 ，会使用 requestIdleCallback 方法延迟执行。\n5. 接下来会创建一个匿名自执行函数包裹住获取到的 js 字符串，最后通过 eval 去创建一个执行上下文执行 js 代码，通过传入 proxy 改变 window 指向，完成 JavaScript 沙箱隔离。源码位置。\n6. 由于 qiankun 是自执行函数执行微应用的 JavaScript，因此在加载后的微应用中是看不到 JavaScript 资源引用的，只有一个资源被执行替换的标识。\n7. 当一切准备就绪的时候，执行微应用的 JavaScript 代码，渲染出微应用\n\n# 八、微应用接入三步走\n\n**第一步：微应用的入口文件 修改 \\**webpack_public_path\\****\n\n- 在 `src` 目录新增 `public-path.js`\n- `webpack` 默认的 `publicPath` 为 `\"\"` 空字符串，会基于当前路径来加载资源。但是我们在主应用中加载微应用资源的时候会导致资源丢失，所以需要重新设置 `__webpack_public_path__` 的值\n\n```\n// 微应用/src/const/public-path.js\nif (window.__POWERED_BY_QIANKUN__) {\n    __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n} \n```\n\n**第二步：微应用webpack 新增配置**\n\n- **webpack** 配置修改 PS: **什么是 umd 模块？**\n\n```\nconst { name } = require('./package.json')\n\nmodule.exports = {\n  devServer: {\n      port: 8081, // 父应用配置微应用端口，要与微应用端口一致\n      disableHostCheck: true, // 关闭主机检查，使微应用可以被 fetch\n      headers: {\n          'Access-Control-Allow-Origin': '*' //因为qiankun内部请求都是fetch来请求资源，所以子应用必须允许跨域\n      }\n  },\n  configureWebpack: {\n      output: {\n          library: `${name}-[name]`, // 微应用的包名，这里与主应用中注册的微应用名称一致\n          libraryTarget: 'umd', // 这里设置为umd意思是在 AMD 或 CommonJS 的 require 之后可访问。\n          jsonpFunction: `webpackJsonp_${name}` // webpack用来异步加载chunk的JSONP 函数。\n      }\n  }\n}\n```\n\n**第三步：微应用添加生命周期**\n\n> 微应用需要在自己的入口文件，添加 `bootstrap`、`mount`、`unmount` 三个生命周期钩子，供主应用在适当的时机调用。\n\n- main.js 注册微应用，增加判断让子应用就算脱离了父应用也可以独立运行\n- PS：qiankun 生命周期函数都必须是 Promise，使用 async 会返回一个Promise对象\n\n```\n// 微应用/scr/main.js\n\nimport './public-path.js'\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\n\nlet instance = null\n\n// 1. 将注册方法用函数包裹，供后续主应用与独立运行调用\nfunction render(props = {}) {\n  const { container } = props\n  instance = new Vue({\n    router,\n    store,\n    render: h => h(App),\n  }).$mount(container ? container.querySelector('#app-micro') : '#app-micro')\n}\n\n// 判断是否在乾坤环境下，非乾坤环境下独立运行\nif (!window.__POWERED_BY_QIANKUN__) {\n  render()\n}\n\n// 2. 导出的生命周期\n/**\n * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。\n * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。\n */\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped')\n}\n\n/**\n * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法\n */\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props)\n  render(props);\n}\n\n/**\n * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例\n */\nexport async function unmount() {\n  instance.$destroy()\n  instance.$el.innerHTML = ''\n  instance = null\n}\n\n/**\n * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效\n */\nexport async function update(props) {\n  console.log('update props', props)\n}\n```\n\n**小结**经历这几步，qiankun 父应用与微应用就接入完成了。当父应用完成加载微应用的时候，微应用就会遵循对应的解析 规则，插入到父应用的HMTL中了。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/468D4F7F26B0DFFA53E19384368C72A1.jpg)image.png\n\n# 九、预加载微应用\n\n**预先请求子应用的 HTML、JS、CSS 等静态资源，等切换子应用时，可以直接从缓存中读取这些静态资源，从而加快渲染子应用。**\n\n1. **registerMicroApps 模式下在 `start` 方法配置预加载应用**\n\n   ```\n   import { registerMicroApps, start } from 'qiankun';\n   \n   registerMicroApps([...AppsConfig])\n   \n   start({ prefetch: \"all\" }) // 配置预加载\n   ```\n\n- prefetch - `boolean | 'all' | string[] | (( apps: RegistrableApp[] ) => { criticalAppNames: string[]; minorAppsName: string[] })` - 可选，是否开启预加载，默认为 `true`。\n\n  配置为 `true` 则会在第一个微应用 mount 完成后开始预加载其他微应用的静态资源\n\n  配置为 `all` 则主应用 `start` 后即开始预加载所有微应用静态资源\n\n  配置为 `string[]` 则会在第一个微应用 mounted 后开始加载数组内的微应用资源\n\n  配置为 `function` 则可完全自定义应用的资源加载时机 (首屏应用及次屏应用)\n\n**loadMicroApps 模式下**\n\n```\nimport { prefetchApps } from 'qiankun';\n\nexport const MICRO_PREFETCH_APPS = [\n    { name: 'vue-child', entry: '//localhost:7101/' },\n    { name: 'vue-app', entry: '//localhost:8081/' }\n]\n\nprefetchApps(MICRO_PREFETCH_APPS)\n// 基座/src/const/micro/application-list.js\n\nexport const MICRO_CONFIG =  [\n    {\n        name: 'you app name', // 应用的名字\n        entry: '//localhost:7286/', // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n        container: '#yuo-container-container', // 容器id\n        activeRule: '/your-prefix', // 根据路由激活的路径\n        isPreload: true, // !! 是否开启预加载 !!\n    }\n]\nimport { prefetchApps } from 'qiankun';\nimport { MICRO_CONFIG } from '@/const/micro/application-list.js';\n\n// 获取配置的 isPreload 字段，并生成加载对应的格式\nconst MICRO_PREFETCH_APPS = MICRO_CONFIG.reduce(\n    (total, { isPreload, name, entry }) => (isPreload ? [...total, { name, entry }] : total),\n    []\n)\n// 预加载应用\nprefetchApps(MICRO_PREFETCH_APPS)\n```\n\n- 笔者用的模式就是 loadMicroApps 模式，**为了日后维护的便携性，改造一下：**，新增 isPreload 字段维护是否开启预加载，这样有关于微应用的信息都在此 js文件维护，避免散弹式修改。\n\n# 十、路由模式选择与改造\n\n## 👉 我们应该怎么选择路由？\n\n> 最好的路由模式就是主应用、子应用都统一模式，可以减少不同模式之间的兼容工作\n\n本文选择统一为：父子路由hash 模式\n\n| 主模式  | 子模式  | 推荐     | 接入影响 | 解决方案          | 备注       |\n| :------ | :------ | :------- | :------- | :---------------- | :--------- |\n| hash    | hash    | 强烈推荐 | 无       |                   |            |\n| hash    | history | 不推荐   | 有       | history.pushState | 改造成本大 |\n| history | history | 强烈推荐 | 无       |                   |            |\n| history | hash    | 推荐     | 无       |                   |            |\n\nPS: 每个模式之间的组合并不是接入就可以完成的，都需要一些改造，如：增加路由前缀，路由配置base设置，不同的模式activeRule的规则都不同\n\n## ⚒ 路由改造工作\n\n### **新增微应用路由前缀**\n\n> 新增前缀不是微应用必须的，但是为了从 URL 上与其他应用隔离，也是为了接入旧应用的时候，能让 activeRule 方法能识别并激活应用，故新增路由前缀。\n\n**父应用路由表**\n\n```\n[\n    // 主应用 router.js：如果想匹配任意路径，我们可以使用通配符 (*)：\n    {\n        path: '/your-prefix',\n        name: 'Home',\n        component: Home\n    },\n     // 特定页面兜底 会匹配以 `/your-prefix` 开头的任意路径\n     // 如：/your-prefix/404 ， /your-prefix/no-permission ....\n    {\n        path: '/your-prefix/*',\n        name: 'Home',\n        component: Home\n    }\n]\n```\n\nPS：子应用路由切换，由于应用与路由都是通过 URL 注册与销毁的，当子应用路由跳转地址，无法与父应用的路由地址匹配上的时候页面会销毁，需要注意路由匹配，或者增加路由兜底。\n\n**子应用 hash 模式**\n\n```\n// hash 模式不能使用base，只能改前缀\nnew VueRouter({\n    mode: 'hash',\n    routes: [\n        {\n            //增加路由前缀判断\n            path: `${ window.__POWERED_BY_QIANKUN__ ? 'your-prefix' : ''}/login`,\n            component: _import('login/index.vue')\n        }\n    ]\n})\n```\n\n**子应用 history 模式**\n\n```\nnew VueRouter({\n    mode: 'history',\n    // **针对子应用是 history模式的时候，只用设置 router base 就好了，不用像hash 这么麻烦** \n    base: window.__POWERED_BY_QIANKUN__ ? 'your-prefix' : null,\n    routes: [\n        {\n            path: '/login',\n            component: _import('login/index.vue')\n        }\n    ]\n})\n```\n\n# 十一、 📝 旧项目路由接入改造\n\n> 但是由于笔者是接入的是旧项目并且又是 hash 路由模式想顺利接入，一个个加三元则改动太多路由表了，为了减少对于旧项目接入时的影响仅在以下三处做修改（ps：因为懒）\n\n## 1. hash路由模式：格式化路由表对象，微路由表路径，别名，重定向增加前缀区分应用\n\n- 这里我们利用递归函数需要给路由动态增加前缀、path 、redirect、alias 这个三种状态需要动态处理一下\n\n1. 路由表数据\n\n```\nconst routes = [\n    {\n        path: '/home',\n        name: 'home',\n        component: Home\n    },\n    {\n        path: '/about',\n        name: 'about',\n        redirect: 'home',\n        component: () => import('../views/About.vue')\n    },\n  {\n        path: '/about',\n        name: 'about',\n        alias: '/user/about',\n        component: () => import('../views/About.vue')\n    }\n]\n```\n\n- \n\n1. 格式化路由方法\n\n```\nlet SUN_ROUTER_PATH_LIST = [] // 所有被格式化的路由都记录一下\n\n// 1. 格式化路由器参数 递归格式化\nexport function formatRouterParams(parameter) {\n    // 判断如果不是 qiankun 环境内容则原样返回\n    if (!window.__POWERED_BY_QIANKUN__) {\n        return parameter.data\n    }\n    \n    // 递归函数：data：数据源，params：需要替换的参数（数组、字符串），value需要替换的值（函数），deepKey：判断是否需要递归的参数名\n    const recursionData = ({ data, params, value, deepKey }) => {\n        return data.reduce((total, item) => {\n            item = formatData({ item, params, value })\n            // 判断是否需要继续递归\n            if (deepKey && item[deepKey] && Array.isArray(item[deepKey])) {\n                item[deepKey] = recursionData({\n                    data: item[deepKey],\n                    params,\n                    value,\n                    deepKey\n                })\n            }\n            return [...total, item]\n        }, [])\n    }\n    return recursionData(parameter)\n}\n\n// 2. 格式化路由数据增加前缀\nexport function formatData({ item, params, value }) {\n    if (!item) return\n    \n    // 如果params是数组：[path, ...more] 遍历增加前缀\n    if (Array.isArray(params)) {\n        params.forEach(key => {\n            if (Object.prototype.hasOwnProperty.call(item, key)) {\n                item[key] = geRouterValue(value, item[key])\n            }\n        })\n    } else if (params) {\n        item[params] = geRouterValue(value, item[params])\n    }\n\n    // 记录格式化路由路径\n    SUN_ROUTER_PATH_LIST.push(item)\n    return item\n}\n\n// 3. 判断value是函数还是值，如果是函数则调用函数 返回对应的value 值\nexport function geRouterValue(value, key) {\n    return typeof value === 'function' ? value(key) : value\n}\n```\n\n1. 调用递归方法统一替换微应用路由表\n\n```\nconst BASE_ROUTER_PATH = 'your-prefix'\n\nconst router = new VueRouter({\n    mode: 'hash',\n    // 调用方法格式化路由表参数！！！\n    routes: formatRouterParams({\n        data: route,\n        deepKey: 'children',\n        params: ['path', 'redirect', 'alias'],\n        value: value => { // value 格式化的方法\n            if (window.__POWERED_BY_QIANKUN__ && typeof value === 'string') {\n                 const path = value[] === '/' ? value : `/${value}`\n                 return BASE_ROUTER_PATH + path\n            }\n            return value\n        }\n    })\n})\n```\n\n遍历结果返回-路由表，统一增加“your-prefix”前缀啦\n\n```\n[\n    {\n        \"path\": \"your-prefix/home\",\n        \"name\": \"home\",\n        \"component\": \"Home\"\n    },\n    {\n        \"path\": \"your-prefix/about\",\n        \"name\": \"about\",\n        \"redirect\": \"your-prefix/home\",\n        \"component\": \"\"\n    },\n    {\n        \"path\": \"your-prefix/about\",\n        \"name\": \"about\",\n        \"alias\": \"your-prefix/user/about\",\n        \"component\": \"\"\n    }\n]\n```\n\n## **2. router.beforeEach**\n\n> 跳转的时候调用检查跳转函数，判断是否需要增加前缀\n\n```\n// 路由全局守卫 \n// ps: 在内部判断，如果跳转的路由与当前子应用无关，直接放行即可\nrouter.beforeEach((to, from, next) => {\n    checkLink(to, next, () => {\n        next()\n    })\n})\n```\n\n- 简单来说：如果是在 qiankun 环境中，并且不是跳转其他微应用的path， 并且跳转不是格式化前缀的路径，并且当前拼接的地址与格式化的路由地址是一致的才拼接 next\n\n```\n// LINK_MICRO_APP_LIST, SUN_ROUTER_PATH_LIST 变量上文有记录\n\nconst { name } = require('../../package.json')\nexport const BASE_ROUTER_PATH = `/${name}` // 此处笔者用了 package.json 的 name 做为 “your-prefix” 方便后期维护\n\n// 跳转的时候检查，判断是否需要增加前缀\nexport function checkLink(to, next, callback) {\n    // 是否存在qinakun环境中\n    const IS_HAVE_QIANKUN = window.__POWERED_BY_QIANKUN__\n    // 是否跳转其他微应用\n    const IS_JUMP_TO_MICRO_APP = Object.values(LINK_MICRO_APP_LIST).includes(to.path)\n    // 是否跳转的是根路径\n    const IS_BASE_PATH_SYMBOL = to.path === '/'\n    // 根路径是否匹配一致\n    const IS_HAVE_BASE_ROUTER_PATH = getBasePath(to.path, '/') === getBasePath(BASE_ROUTER_PATH, '/')\n    // 判断以上情况来确定是否需要给路由动态增加前缀\n    const IS_ADD_PREFIX = IS_HAVE_QIANKUN && !IS_JUMP_TO_MICRO_APP && !IS_HAVE_BASE_ROUTER_PATH\n    if (IS_ADD_PREFIX || IS_BASE_PATH_SYMBOL) {\n        const path = `${BASE_ROUTER_PATH}${to.path}`\n        // 当前拼接的地址与 当前格式化的路由是否一致，一致才是跳转内部路由\n        if (SUN_ROUTER_PATH_LIST.some(e => [e.path, e.redirect, e.alias].includes(path))) {\n            next({ path })\n        }\n    }\n    // 执行回调函数\n    callback && callback()\n}\n\n// 获取当前的基础路径  如: getBasePath('/user/age/xxx', '/') => '/user'\nexport function getBasePath(path, prefix = '') {\n    if (!path) return\n    const pathArray = String(path).split('/').filter(item => item)\n    const basePath = prefix + pathArray[]\n    return basePath\n}\n```\n\n## 3.改写router.push OR router.replace\n\n```\n// 因为改变了next()的地址, push方法会提示报错，这里过滤一下～\nconst originalPush = VueRouter.prototype.push\nVueRouter.prototype.push = function push(location) {\n    return originalPush.call(this, location).catch(err => err)\n}\n```\n\nps: **其可以直接在push中改写， 省略 router.befroeEach**\n\n```\nconst originalPush = VueRouter.prototype.push\n\nVueRouter.prototype.push = function push(location) {\n    const IS_JUMP_TO_MICRO_APP = Object.values(LINK_MICRO_APP_LIST).includes(location.path)\n    const IS_HAVE_QIANKUN = window.__POWERED_BY_QIANKUN__\n    const IS_BASE_PATH_SYMBOL = location.path === '/'\n    const IS_HAVE_BASE_ROUTER_PATH = getBasePath(location.path, '/') === BASE_ROUTER_PATH\n    const IS_ADD_PREFIX = IS_HAVE_QIANKUN && !IS_JUMP_TO_MICRO_APP && !IS_BASE_PATH_SYMBOL && !IS_HAVE_BASE_ROUTER_PATH\n\n    if (IS_ADD_PREFIX) {\n        location.path = `${BASE_ROUTER_PATH}${location.path}`\n    }\n    return originalPush.call(this, location)\n}\n```\n\n## 4. 路由跳转记录\n\n**跳转方式: 路由跳转与正常使用无异**\n\n- ps: 在父应用是history模式，子应用是 hash模式的时候 子应用需要特殊处理一下URL重定向切换 history.pushState\n\n**跳转其他微应用**\n\n1. 由于我们的应用之间式分离的，所以跳转外部应用的路由也是分离的，**如果在项目中字面量固定写死风险太大了，如果外部应用发生一点改变，需要改项目里的路径的时候将会是一个噩梦**，所以我们统一使用在各自的微应用维护一个常量列表去处理记录应用之间的跳转，方便全局统一管理。此处仅笔者一点拙见，如有更好建议请多多发表。\n2. PS：此处跳转的常量列表其实也可以放到基座应用去维护，但是最佳选择是有运维平台去维护应用之间跳转关系会更好～\n\n```\n// 微应用/scr/const/link-micro-app-list\nexport const LINK_MICRO_APP_LIST = {\n    CHILD_VUE: '/child/vue', // vue 微应用地址\n    CHILD_REACT: '/child/react', // react 微应用地址\n    USER_INFO: '/user/info' // 跳转父应用用户信息页地址\n}\n```\n\n**使用场景：**\n\n```\n// 微应用/router.js\n\n// 1. 判断是否跳转其他应用\nconst IS_JUMP_TO_MICRO_APP = Object.values(LINK_MICRO_APP_LIST).includes(to.path)\n\n// 2. 定义路由的时候通过路由列表地址获取\nlet routes = [\n    {\n        path: '/about',\n        name: 'about',\n        // 别名 重定向 凡是跳转其他应用的都应该在这里统一管理 ！！！\n        redirect: LINK_MICRO_APP_LIST['CHILD_VUE'], \n        component: () => import('../views/About.vue')\n    }\n]\n\n// router.beforeEach\nrouter.beforeEach((to, from, next) => {\n    if (IS_JUMP_TO_MICRO_APP) {\n        next(false) // 禁止跳转其他ying yon\n    }\n  // ... more code\n})\n```\n\n# 十二、 微应用与路由之间 如何 keep alive\n\n- **registerMicroApps模式下，为什么切换路由会导致应用重载？**\n\n- - 例：A 到 B， 触发A unmount ⇒ 判断 B 是否加载过，已加载则触发 mount，未加载则触发 bootstrap ⇒ mount\n  - 详情可以看上文 **“五、引入qiankun - 在主应用中注册微应用”**\n  - URL 改变时应用匹配切换，路由的切换会导致应用的卸载与加载\n  - 如果子应用挂载在内部路由，路由跳转也将触发应用的重载\n  - 应用切换导致重载，导致组件状态丢失，为了保持应用实例不被加载，我们需要手动的控制应用的注册与销毁\n\n- 方案一：**loadMicroApp**\n\n- - 优点：在一个页面中可以同时挂载多个微应用\n  - 缺点：无法根据路由匹配规则来挂载应用\n  - 适用场景：当需要在一个页面中同时挂载2个以上子应用，并且子应用的挂载不需要通过路由匹配来实现。\n  - PS：在基座中关闭标签页时，需要手动调用app的unmount钩子销毁应用，不然再次新建页签进入时还是以前的实例\n\nloadMicroApp不能根据路由规则来挂载应用不是qiankun的问题，是我们的问题～\n\n**使用 router.\\**afterEach\\** + loadMicroApp 的解决应用 keep alive，思路是通过判断路由守卫的地址，如果是符合激活规则的则激活应用**\n\n**1. 主应用 router 路由守卫**\n\n```\n// 主应用/src/router/index.js\n// 1. 全局后置钩子调用微应用加载方法\n// 为什么笔者会在这里调用呢，其实是笔者利用了JavaScript机制的宏任务，目的就是为了在路由页获取是微应用的容器是否挂载了微应用，因为有时候微应用会因为作者系统的路由切换而被替换掉，所以用这个方式解决\nrouter.afterEach(to => {\n    setTimeout(() => { // setTimeout 是宏任务的一种\n        microApplicationLoading(to.path) // 把当前跳转的路径传入\n    })\n})\n```\n\n**2. 判断微应用加载的方法 microApplicationLoading**\n\n- 应用表\n\n```\n// **src/const/micro/application-list.js** \nexport const microApplicationList [\n    {\n        name: 'you app name', // 应用的名字\n        entry: '//localhost:7286/', // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n        container: '#yuo-container-container', // 容器id\n        activeRule: '/your-prefix', // 根据路由激活的路径\n        **isPreload: true, // !! 是否开启预加载 !!\n        isRouteStart: true, // 是否需要路由启动**\n        props: { // 下发子应用的资源\n            router: router,\n            store: store,\n            parentEventHub: parentEventHub\n        }\n    }\n]\n```\n\n- 加载微应用方法\n\n```\n// 主应用/src/const/micro/qianun-utils.js\n// 加载微应用方法\nimport { loadMicroApp } from 'qiankun'\n\nexport async function microApplicationLoading(path) {\n    // 1. 根据路由地址加载当前应用配置\n    let currentActiveMicroConfig = await store.dispatch('d2admin/micro/GET_FIND_MICRO_CONFIG', path)\n  \n    // 2. 从 vuex 获取缓存的微应用列表\n    const microApplicationList = store.getters['d2admin/micro/microApplicationList']\n\n    // 3. 如果没有匹配应用配置则代表跳转的不是微应用 or 微应用配置不需要路由启动的属性\n    if (!currentActiveMicroConfig || !currentActiveMicroConfig.isRouteStart) {\n        return\n    }\n\n    // 4. 根据应用配置 获取缓存的应用\n    const cacheMicro = microApplicationList.get(currentActiveMicroConfig.activeRule)\n \n    // 5. 判断当前挂载的是否有内容\n    const containerNode = getContainerNode(currentActiveMicroConfig.container)\n    const isNoTNodeContents = containerNode !== -1 && !containerNode\n \n    // 6. 如果没有dom节点 or 没有缓存应用配置 注册一下\n    if (isNoTNodeContents || !cacheMicro) {\n   \n        // 如果有缓存应用配置，但是容器没有应用挂载，先卸载缓存应用再注册微应用\n        if (cacheMicro) {\n            cacheMicro.unmount()\n            cacheMicro.unmountPromise.then(() => {\n                loadRouterMicroApp(currentActiveMicroConfig)\n            })\n            return\n        }\n\n        // 加载应用\n        loadRouterMicroApp(currentActiveMicroConfig)\n    }\n}\n\n// 加载微应用\nexport function loadRouterMicroApp(currentApp) {\n    const micro = loadMicroApp(currentApp)\n    micro.mountPromise.then(() => {\n        // 挂载完成 设置一下vuex微应用列表\n        store.dispatch('d2admin/micro/SET_MICRO_APPLICATION_LIST', {\n            key: currentApp.activeRule,\n            value: micro\n        })\n    })\n}\n\n// 获取容器节点\nexport function getContainerNode(container) {\n    const containerNode = container && document.querySelector(container)\n    \n    if (containerNode) {\n        return containerNode.childNodes.length\n    }\n    \n    return -1\n}\n```\n\n**vuex 方法 记录一下注册应用对象**\n\n```\n// 主应用/src/store/modules/d2admin/modules/micro.js\nimport MICRO_CONFIG from '@/const/micro/application-list.js '\n\nexport default {\n    state: {\n        microApplicationList: new Map([]) // 已经注册的微应用列表\n    },\n    getters: {\n        microApplicationList(state) {\n            return state.microApplicationList\n        }\n    },\n    actions: {\n        // 设置微应用程序列表\n        SET_MICRO_APPLICATION_LIST({ state, dispatch }, { key, value }) {\n            state.microApplicationList.set(key, value)\n        },\n        // 通过路径获取微应用配置\n        GET_FIND_MICRO_CONFIG({ state }, path) {\n            return MICRO_CONFIG.find(e => {\n                return getPathPrefix(path, '/') === getPathPrefix(e.activeRule, '/')\n            })\n        }\n    }\n}\n\n// 获取当前的基础路径  如: getPathPrefix('/user/age/xxx', '/') => '/user'\nexport function getPathPrefix(path, prefix = '') {\n    if (!path) return\n    const pathArray = String(path).split('/').filter(item => item)\n    const basePath = prefix + pathArray[]\n    return basePath\n}\n```\n\n**🚀 Link: 更多的 keep-alive 解决方案**\n\n# 十三、沙箱模式\n\n## CSS沙箱\n\n> 微前端对于样式隔离问题，目前相关配套还不是很成熟\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/7EE8F7A3617F6ACF99F65C6AA2423F4F.jpg)image.png\n\n- 由于微前端场景下，不同技术栈的子应用会被集成到同一个运行时中，所以我们必须在框架层确保各个子应用之间不会出现样式互相干扰的问题。不同于 JavaScript 的隔离，目前 CSS 隔离在行业内还不完全的成熟，但是“甲之蜜糖，乙之砒shuang“，每个方案都有着不同的优势与劣势。\n\n- 样式隔离有着各种方案\n\n- - BEM （Block Element Module）规范\n  - CSS-Modules 构建时生成各自的作用域\n  - CSS in JS 使用 JS 语言写 CSS\n  - Shadow DOM 沙箱隔离\n  - experimentalStyleIsolation 给所有的样式选择器前面都加了当前挂载容器\n  - Dynamic Stylesheet 动态样式表\n  - postcss 增加命名空间\n\n- 但是即使是有着如此多的样式隔离方案，css 还是会有一堆问题等着你去处理。例如：\n\n- - 不同应用依赖了同一个UI库，不同版本的情况\n  - 子应用，样式丢失或应用到了主项目的样式\n  - 微应用构运行时越界例如 **body 构建 DOM 的场景（弹窗、抽屉、popover 等这种插入到主应用body 的dom 元素）**，必定会导致构建出来的 DOM 无法应用子应用的样式的情况。\n\n> 本文采取的样式隔离的最佳实践是：采用约定式隔离，用 CSS 命名空间。备选：CSS Module、css-in-js 等工程化手段，建立约束：如：避免写全局样式，子应用不能侵入(如动态增加全局样式等)修改除本应用外的样式，子应用样式写在以子应用名作为命名空间的类里等。\n\n1. **默认沙箱**\n\n- qiankun是默认开启沙箱隔离的，默认情况下沙箱可以确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离\n\n**严格样式隔离的沙箱模式**\n\n```\nstart({\n  sandbox: {\n    strictStyleIsolation: true // 严格沙箱模式\n  }\n})\n```\n\nqiankun 会为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响，基于 ShadowDOM 的严格样式隔离并不是一个可以无脑使用的方案，大部分情况下都需要接入应用做一些适配后才能正常在 ShadowDOM 中运行起来\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/0B46EE190D80861EDFF90D518837F052.jpg)image.png\n\n**qiankun 还提供了一个实验性的样式隔离特性 experimentalStyleIsolation**\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/D7E88504050B9DAD9CE60A6E8ABE8F93.jpg)image.png\n\n- 当 experimentalStyleIsolation 被设置为 true 时，qiankun 会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围\n\n**BEM （Block Element Module）规范命名约束**\n\n特定规则链接：\n\n```\n模块：            .Block\n模块多单词：       .Header-Block\n模块_状态：        .Block_Modifier\n模块__子元素：     .Block__Element\n模块__子元素_状态：.Block__Element_Modifier\n```\n\n- '-'  中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接符号。\n- __  双下划线：双下划线用来连接块和块的子元素\n- _  单下划线：单下划线用来描述一个块或者块的子元素的一种状\n- **B** - `Block` 一个独立的模块，一个本身就有意义的独立实体 比如：`header`、`menu`、`container`\n- **E** - `Element` 元素,块的一部分但是自身没有独立的含义 比如：`header title`、`container input`\n- **M** - `Modifier` 修饰符，块或者元素的一些状态或者属性标志 比如：`small`、`checked`\n\n**CSS Modules**\n\n- 指的是我们像 import js 一样去引入我们的 css 代码，代码中的每一个类名都是引入对象的一个属性，通过这种方式，即可在使用时明确指定所引用的 css 样式。并且 CSS Modules 在打包的时候会自动将类名转换成 hash 值，完全杜绝 css 类名冲突的问题。\n\n**CSS In JS**\n\n- CSS in JS，意思就是使用 js 语言写 css，完全不需要些单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化\n\n**postcss 增加命名空间**\n\n```\nnpm i postcss-plugin-namespace -D\nmodule.exports = ctx => {\n    return {\n        plugins: [\n            require('postcss-plugin-namespace')('#your-prefix', {\n                ignore: ['html', /body/]\n            })\n        ]\n    }\n}\n<html id=\"your-prefix\"></html>\n```\n\n- public/index.html\n- 配置postcss\n\n1. 在项目根目录创建`postcss.config.js`文件\n\n   该插件会将全局所有class前加上统一前缀，并过滤掉ignore内的标签；ignore内可以写字符串，可以写正则表达式。但每次编译前都会运行，所以可能会增加编译时间\n\n   注意：如果用`/body/`这样的正则，会将所有带body的class都过滤掉，比如`el-drawer__body`、`el-dialog__body`等。\n\n## JavaScript 沙箱\n\nqiankun框架为了实现 JavaScript隔离，提供了三种不同场景使用的沙箱，分别是 **`snapshotSandbox`\\**、\\**`proxySandbox`\\**、\\**`legacySandbox`**\n\n- 快照沙箱(snapshotSandbox)：`qiankun`的快照沙箱是基于`diff`来实现的，主要用于不支持`window.Proxy`的低版本浏览器(IE 浏览器)，而且也只适应单个的子应用\n\n- 代理沙箱(proxySandbox)：`qiankun`基于`es6`的`Proxy`实现了两种应用场景不同的沙箱，\n\n- - 一种是`legacySandbox`(单例)\n  - 一种是`proxySandbox`(多例)\n\n- PS：**qiankun 默认开启沙箱模式**\n\n- - 但是qiankun目前还是有一些缺陷：**给某个内置对象添加属性或方法会导致突破沙箱限制，污染都全局的window属性**\n  - **沙箱不是万能的，沙箱只有一层的劫持，例如 Date.prototype.xxx 这样的改动是不会被还原的**\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/7207B7E1E2CC21F21F3EC34967B11F9E.jpg)image.png\n\n```\n    // 示例\n    // 1. 子应用-改写了 setItem 方法\n    window.localStorage.setItem = function() {\n      console.log('Hi child')\n    }\n\n    // 2. 兄弟应用-调用 setItem\n    console.log(window.localStorage.setItem) // ƒ () {console.log('Hi child')} 污染了全局\n\n    // 3. 主应用-调用 setItem\n    console.log(window.localStorage.setItem) // ƒ () {console.log('Hi child')} 污染了全局\n```\n\n- **微应用挂载window的 是 proxy 代理出来的 window，并不是真实的window，所以修改会被隔离掉**\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/4614AAE6446B7D1FA546C8F907F97C4E.jpg)image.png\n\n```\n// 1. 主应用\nwindow.user = {\n    my: {\n        name: 'I m your father'\n    }\n}\n\n// 2. 微应用 这里第一次输出还是会继承父的 数据\nconsole.log(window.user)  // {my: {name: \"I m your father\"}}\n\nwindow.user = { // 改变数据\n    my: {\n        name: 'child'\n    }\n}\n\nconsole.log(window.user)  // {my: {name: \"child\"}}\n\n// 3. 兄弟应用 因为有沙箱隔离不会影响到 window\nconsole.log(window.user)  // {my: {name: \"I m your father\"}}\n```\n\n微前端中最多的问题就是在沙箱中了，无论是 CSS 还是 JavaScript 沙箱都不是十全十美的，我们只能通过各种约束来避免沙箱出现问题的可能。例如：建立团队前缀，命名空间 CSS、事件、本地存储和 Cookie，以避免冲突并明确所有权。\n\n**笔者整理了一下经常出现问题的场景。**\n\n1. 由于 qiankun 沙箱的缺陷，window 对象并不是完全隔离的，子应用的 window 又是基于父应用的，经常导致的是：父应用的依赖库已经挂到window上了，子应用再挂载的时候就报错了\n2. 微前端海纳百川的特性，当不同技术栈的应用被集合在同一个”运行时环境“的时候，微应用之间会出现样式互扰的问题，依赖版本冲突的问题\n3. 代码在沙箱内运行错误的问题，主要是 BOM，DOM 的 API 使用冲突，因为无法隔离所以会有改写的危机\n4. qiankun 会将微应用的 JS/CSS 内容都记录在全局变量中，如果一直重复的挂载应用没有卸载，会导致内存占用过多，导致页面卡顿。\n5. 给 body 、 document 等绑定的事件，必须在 unmount 周期清除，使用 document.body.addEventListener 或者 document.body.onClick 添加的事件并不会被沙箱移除，会对其他的页面产生影响\n6. 第三方引入的 JS 不生效，有些 JS 文件本身是个立即执行函数，或者会动态的创建 scipt 标签，但是所有获取资源的请求是被乾坤劫持处理，所以都不会正常执行，也不会在 window 下面挂载相应的变量\n7. 由于是相同的 window 对象，不会有应用之间的隔离，localStorage、sessionStorage、cookie 等对象互相冲突覆盖\n8. 改变全局变量 window/location 的默认行为，通过 document 操作 Layout 的 DOM，这些本身都是一些不推荐的做法\n\n# 十四、localStorage、sessionStorage应用之间的使用\n\n- **因为父子应用都是同一个 window，所以 localStorage、sessionStorage、cookie, 这些方法就会造成数据覆盖问题**\n- 正常读取即可，因为无论父子应用，存储的相关信息都以父应用的地址进行存储。\n- 需要注意微应用之间数据冲突、数据覆盖问题，这里改写一个 setItem getItme 解决这个问题\n\nPS:\n\n- 此方案只是针对难以改动的老项目去做的，不推荐去改变 window 的方法，如果您有这个需求则应该去抽离成一个类或函数去做。\n- 子项目的改动原 window 的 prototype qiankun 的沙箱无法处理隔离\n- 目前不支持 sessionStorage[“keyName”] = value， sessionStorage.keyName =  value 这种写法，如果想使用以上方法可以使用 proxy or  defineProperty 改写本文不再赘述\n- 动态给 getItem、setItem方法加前缀，这样在接入旧项目的时候不会这么痛苦，取巧方式，不推荐\n\n```\n//定义需要遍历的常量\nconst storageMap = [\n  {\n    storage: sessionStorage,\n    method: 'getItem'\n  },\n  {\n    storage: sessionStorage,\n    method: 'setItem'\n  },\n  {\n    storage: localStorage,\n    method: 'getItem'\n  },\n  {\n    storage: localStorage,\n    method: 'setItem'\n  }\n]\n\n// 改写方法\nfunction formatItem(storage, method) {\n  storage[method] = function(key, value, isGlobal = false) { // isGlobal 是否存储or查找全局\n    if (window.__POWERED_BY_QIANKUN__ && !isGlobal) { // 如果是qiankun则追加前缀\n      key = BASE_ROUTER_PATH + key\n    }\n    Object.getPrototypeOf(storage)[method].call(this, key, value) // 引用原方法改动最小化\n  }\n}\n\n// 遍历方法\nstorageMap.forEach(({ storage, method }) => {\n  formatItem(storage, method)\n})\n```\n\n# 十五、资源共享\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/DE25FE27ABE56447239A1422819BAE77.jpg)https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d381aa6a6e34b11bf0c9ae59dcc85f4~tplv-k3u1fbpfcp-zoom-1.image\n\n对于应用之间的资源共享，笔者认为这个与微前端的概念是有矛盾的。\n\n微前端的概念：\n\n- 「技术栈无关」：主框架不限制接入应用的技术栈，子应用具备完全自主权\n- 「独立开发 独立部署」：子应用仓库独立，可独立开发，部署完成后主框架自动完成同步更新\n- 「独立运行」：每个子应用之间状态隔离，运行时状态不共享，不要共享运行时，即使所有团队都使用相同的框 架。构建自包含的独立应用程序。不要依赖共享状态或全局变量。\n\n矛盾思考：\n\n1. 「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。\n2. 按照理想的情况：我们希望微前端尽可能独立解耦，但是不同微应用之间可能存在大量相同的重复的资源依赖，在分秒必争的今天，每一个资源的开销都不容小觑，如果把一些可复用的资源直接共享出去，那岂不是可以高效降低资源的开销了吗。\n3. 当我们把资源共享出去的时，也给应用带来了依赖冗余，微应用把公共资源引入的同时，也把未来的复杂性也给引入进来了。\n\n## **1. 共享模块方式**\n\n以下是笔者整理的共享模块的方式，\n\n### npm 依赖\n\n- 抽离相关代码（utils、组件..) 将其打包并上传 npm 库，然后在需要的微应用中以本地依赖或 npm link 的方式安装依赖，以 npm 的方式达到资源共享的目的。但是其本质只是代码层面的共享与复用，每个应用构建的的时候还是会把依赖包一起打包\n- 并且 npm 管理，每次 npm 更新的时候都要在各微应用进行重新构建发布。\n\n### git submodule or git subtree\n\n- 🚀 Link git submodule\n- subtree 和 submodule 的目的都是用于 git 子仓库管理，二者的主要区别在于，subtree 属于拷贝子仓库，而 submodule 属于引用子仓库。\n- 他们允许你将一个 Git 仓库当作另外一个 Git 仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立\n- 创建一个 libs 的项目进行管理维护，里面存放各种公用的方法，组件，图片等，并且同步到gitlab上\n- `git submodule` 和 `git subtree` 都是很好的子仓库管理方案，但缺点是每次子应用变更后，聚合库还得同步一次变更，考虑到并不是所有人都会使用该聚合仓库，子仓库独立开发时往往不会主动同步到聚合库，使用聚合库的同学就得经常做同步的操作，比较耗时耗力，不算特别完美。\n\n### webpack Externals\n\n- 🚀 Link git Externals\n- 配置 webpack 输出的 bundle 中排除依赖，换句话说通过在 Externals 定义的依赖，最终输出的 bundle 不存在该依赖，\n- externals 前提是依赖都要有 cdn 或 找到它对应的 JS 文件，例如：jQuery.min.js 之类的，也就是说这些依赖插件得要是支持 umd 格式的才行。\n- 通过这种形式在微前端基座应用加载公共模块，并将微应用引用同样模块的Externals 移除掉，就可以实现模块共享了 但是存在微应用技术栈多样化不统一的情况，可能有的使用 Vue3，有的使用 React 开发，但 externals 并无法支持`多版本共存`的情况\n\n> qiankun不建议共享依赖，担心原型链污染等问题，如果一定要使用：推荐使用webpack的 Externals 来共享依赖库。\n\n**使用场景：**\n\n- 如果主子应用使用的是**相同的库或者包！！！** (`vue、axios、vue-router、element` 等) 可以用 externals 的方式来引入，减少加载重复包导致资源浪费，**一个项目使用了之后，另一个项目使用不再重复加载，可以直接复用这个文件**。\n\n**使用原理：**\n\n- `qiankun` 将子项目的外链 `script` 标签，内容请求到之后，会记录到一个全局变量中，下次再次使用，他会先从这个全局变量中取。这样就会实现内容的复用，只要保证两个链接的 `url` 一致即可。\n\n**使用方式：**\n\n- 微应用之间使用\n\n- - 只要子项目配置了`webpack` 的 externals，并在 `index.html` 中使用外链 `script` 引入这些公共依赖，只要这些公共依赖URL一致即可，请求的时候会优先从缓存中读取，类似HTTP缓存\n\n- 微应用使用基座依赖\n\n- - 给微应用的公共依赖的加上 `ignore` 属性（这是自定义的属性，非标准属性）。\n  - `qiankun` 在入口解析的时候会判断如果有这个属性就忽略。子项目独立运行，这些 `js/css` 仍能被加载，如此，便实现了“子项目复用主项目的依赖”。\n\n```\nmodule.exports = { \n    configureWebpack: { \n        externals: { \n            'vue': 'Vue', \n            'vue-router': 'VueRouter', \n            'vuex': 'Vuex', \n            'element-ui': 'ELEMENT' \n        }\n    }\n}\n<link ignore rel=\"stylesheet\" href=\"//cnd.com/antd.css\">\n<script ignore src=\"//cnd.com/antd.js\"></script>\n```\n\nPS：主项目使用`externals` 后，子项目可以复用它的依赖，但是不复用依赖的子项目会报错。\n\n🚀 Link # [Bug]公共依赖提取的时候，qiankun，代理window访问并没有先访问微应用的window，再访问主应用的window\n\n### webpack DLL\n\n- 🚀 Link webpack DLL\n- dll 插件可以帮助我们直接将已安装好的依赖在 node_module 中打包出来，结合 **add-asset-html-webpack-plugin** 插件帮助我们将生成打包好的 js 文件插入到 html 中\n- 因为使用公共依赖，意味着所有使用公共依赖的应用，必须使用同版本的依赖，并且 qiankun 使用 dllplugin 提取公共依赖后，导致不同子应用中的全局 filter、component、mixin 相互影响\n\n### 使用lerna管理\n\n- Lerna · 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目 | Lerna 中文文档\n\n### 通过聚合目录\n\n- 聚合目录相当于是一个空目录，在该目录下 clone 所有子仓库，并 .gitignore，子仓库的代码提交都在各自的仓库目录下进行操作，这样聚合库可以避免做同步的操作。\n\n上面的方案都是业内比较成熟的方案，还需开发者深入了解，笔者采用的是：NPM、webpack external。对外的且稳定的组件或封装，推荐 `npm` 包方式。\n\n## 2. 通过主应用共享资源给微应用\n\n主应用的下发资源的核心就是：**注册的时候通过 props 下发**\n\n### **props 方式**\n\n- **父应用注册时或加载时，将依赖通过 `props` 传递给子应用，子应用在 `bootstrap` 或者 `mount` 钩子函数中获取**\n- 主应用注册下发，任何你想要的资源，但是切勿无脑下发资源，需要考虑日后解耦或独立运行的问题。\n\n```\n// 主应用/src/const/micro/application-list.js\nimport { layout, assets, config, layout, public } from '/lib'\n\nexport default [{\n    name: 'you-app-name', // 应用的名字\n    entry: '//localhost:7286/', // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n    container: '#you-app-name-container', // 容器id\n    activeRule: '/you-app-name', // 根据路由激活的路径，这里注意要与子应用对应的 package ==> name 文件一致\n    props: { // 下发微应用的入口, 如果是固定确认的资源可以维护在应用注册列表\n        hideLayout: true, // 是否隐藏子应用侧边栏、导航栏\n        defaultPath: '', // 默认跳转地址\n        commonComponent: {}, // 下发的组件\n        public: public, // 父亲应用公共文件\n        assets: assets, // 父应用资源文件\n        config: config, // 父应用配置文件\n        layout: layout  // 父应用布局组件\n    }\n}]\n```\n\n如果是动态数据可以注册的时候传递下发\n\n```\nimport store from '@/store/index'\nimport router from '@/router'\n\n// 在微应用 props 属性 动态下发配置。\ncurrentApp.props = {\n  ...currentApp.props,\n  router: router, // 下发父应用路由\n  store: store // 下发父应用vuex\n}\n\nloadMicroApp(currentApp) // 注册应用的时候在子应用可以在微应用的生命周期中获取\n```\n\n- 微应用接收\n\n```\n// 微应用 mount 中接收\nimport childStore from '@/store/index'\nimport childRouter from '@/router'\n\nexport async function mount(props) {\n    render(props)\n}\n\n// 动态挂载 通过 this.$root.xxx 使用 data 的数据\nfunction render(props = {}) {\n    // 获取父应用下发的资源，并存储在 data 上\n    const { container, router，store，layout, config, assets, public, commonComponent } = props\n    instance = new Vue({\n        childRouter,\n        childStore,\n        data() {\n            return {\n                parentRouter: router, // 父应用路由\n                parentVuex: store, // 父应用 vuex\n                parentLayout: layout, // 父应用布局组件\n                parentConfig: config, // 父应用配置文件\n                parentAssets: assets, // 父应用资源文件\n                parentPublic: public, // 父亲应用公共文件\n                parentCommonComponent: commonComponent // 下发的组件\n            }\n        },\n        render: h => h(App)\n    }).$mount(container ? container.querySelector('#you-micro') : '#you-micro')\n}\n```\n\n### window 方式\n\n- 因为主项目会先加载，然后才会加载子项目，所以一般是子项目复用主项目的组件，做法也很简单，主项目加载时，将组件挂载到 `window` 上，子项目直接注册即可\n- 但是笔者这里不推荐任何修改 window 的方式，因为沙箱缺陷的缘故，不打扰就是最好的安排～\n\n**主项目入口文件：**\n\n```\nimport HelloWorld from '@/components/HelloWorld.vue'\nwindow.commonComponent = { HelloWorld };\n```\n\n**子项目直接使用：**\n\n```\ncomponents: {\n  HelloWorld: window.__POWERED_BY_QIANKUN__ ? window.commonComponent.HelloWorld : import('@/components/HelloWorld.vue'))\n}\n```\n\n### **项目间的组件共享**\n\n> 子项目本身自己也有这个组件，当别的子项目已经加载过了，就复用别人的组件，如果别的子项目未加载，就使用自己的这个组件\n\n适用场景就是避免组件的重复加载，这个组件可能并不是全局的，只是某个页面使用。做法分三步：\n\n**1.由于子项目之间的全局变量不共享，主项目提供一个全局变量，用来存放组件**\n\n- **通过 `props` 传给需要共享组件的子项目。**\n\n```\n// 主应用\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nprops: {\n  commonComponent: {\n    HelloWorld\n  }\n}\n```\n\n**2.子项目拿到这个变量挂载到 `window` 上**\n\n```\nexport async function mount(props) {\n  window.commonComponent = props.data.commonComponent\n  render(props.data)\n}\n```\n\n**3.子项目中的共享组件写成异步组件，异步组件需要返回 Promise.resolve()**\n\n```\ncomponents: {\n   HelloWorld: async () => {\n      if (!window.commonComponent) {\n        window.commonComponent = {} // 独立运行时\n      }\n      const HelloWorld = window.commonComponent.HelloWorld\n      return HelloWorld || (window.commonComponent.HelloWorld = import('@/components/HelloWorld.vue'))\n   }\n}\n```\n\n# 十六、应用通信\n\n**通信设计原则**\n\n- 跨应用通信：解耦易接入\n- 开放但不失约束：通信收口，统一管理\n- 简单易用：学习成本低，接口尽可能少\n- 易于维护：分模块管理，避免通信冲突\n- 容易排查：链路监控性强，及时跟踪问题\n\n**微前端通信方式**\n\n- 基于 URL\n\n- - 使用简单、通用性强，但能力较弱，不适用复杂的业务场景\n\n- 基于 Props\n\n- - 应用给子应用传值。适用于主子应用共享组件、公共方法调用等。\n\n- 发布/订阅模式\n\n- - 一对多关系，观察者和被观察者是抽象耦合的。但是数据链路难跟踪。\n\n- 状态管理模式\n\n- - 能够统一管理，链路清晰，易维护\n\n- 基于 `localStorage`、`sessionStorage` 实现的通信方式\n\n- - 不推荐，因为 JSON.stringify() 会造成数据丢失，它只会对Number、String、Booolean、Array转换，对于undefined、function、NaN、 regExp、Date 都会丢失本身的值\n\n基于URL、Props 、LocalStorage 的方式就不讲述了上文都有对应的说明，以下只对 发布/订阅模式，状态管理模式进行讲解\n\n## 发布/订阅模式 EventBus\n\n笔者这里的设计模式是，主应用注册 EventBus，然后通过 props 下发微应用，这样微应用既有主应用的EventBus 也可以有自己的 EventBus\n\n- 主应用注册 EventBus\n\n```\nVue.prototype.$eventBus = new Vue()\n\nexport const parentEventBus = Vue.prototype.$eventBus\n```\n\n- 通过 props 下发\n\n```\n// 在微应用 props 属性 动态下发配置。\nimport { parentEventBus } from '@/main'\n\ncurrentApp.props = {\n    ...currentActiveMicroConfig.props,\n    parentEventBus: parentEventBus // 下发主应用的 EventBus\n}\n\nloadMicroApp(currentApp)\n```\n\n- 子应用接受并注册\n\n```\n// 微应用 mount 中接收\nexport async function mount(props) {\n    render(props)\n}\n\n// 动态挂载 通过 this.$root.xxx 使用data的数据\nfunction render(props = {}) {\n    const { parentEventBus } = props\n    Vue.prototype.$eventBus = new Vue() // 子应用的独享的 EventBus\n    Vue.prototype.$parentEventBus = parentEventBus // 主应用下发的 EventBus\n    // 注册操作省略 ...\n}\n```\n\n- 使用 还是正常使用\n\n```\nthis.$parentEventBus.$off('you-event') // 关闭\n\nthis.$parentEventBus.$on('you-event', data => { // 监听\n  // xxxx code action\n})\n\nthis.$parentEventBus.$emit('you-event', {...}) // 发布\n```\n\n## 使用 qiankun initGlobalState\n\n- 主应用\n\n```\n// src/const/micro/actions.js\nimport { initGlobalState } from 'qiankun'\n\nexport const initialState = {}\n\nconst actions = initGlobalState(initialState)\n\nexport default actions\n```\n\n- 主应用使用\n\n```\nimport actions from '@/const/micro/actions'\n\n// 设置\nactions.setGlobalState({\n   xxxxDataKey: xxxValue\n})\n\n// 监听全局\nactions.onGlobalStateChange((state, prev) => {\n  console.log(state, prev, '子应用的 state: 变更后的状态; prev 变更前的状态')\n})\n```\n\n- 微应用\n\n```\n// src/const/micro/actions.js 封装一下到时候引入使用方便\nfunction emptyAction() {\n    // 警告：提示当前使用的是空 Action\n    console.warn('Current execute action is empty!')\n}\n\nclass Actions {\n    // 默认值为空 Action\n    actions = {\n        onGlobalStateChange: emptyAction,\n        setGlobalState: emptyAction\n    }\n\n    // 设置 actions\n    setActions(actions) {\n        this.actions = actions\n    }\n\n    // 映射监听\n    onGlobalStateChange(...args) {\n        return this.actions.onGlobalStateChange(...args)\n    }\n\n    // 映射设置\n    setGlobalState(...args) {\n        return this.actions.setGlobalState(...args)\n    }\n}\n\nconst actions = new Actions()\nexport default actions\n```\n\n- 微应用使用\n\n```\nimport actions from './const/micro/actions'\n\nexport async function mount(props) {\n    actions.setActions(props) // 设置一下 actions 对象\n}\n\nactions.onGlobalStateChange((state, prev) => {\n  // 监听公共应用下发 state: 变更后的状态; prev 变更前的状态\n})\n```\n\n## 状态管理模式\n\n- 基于父应用的 vuex store 传给子应用\n\n```\n// 在微应用 props 属性 动态下发配置。\nimport store from '@/store/index'\n\ncurrentApp.props = {\n    ...currentActiveMicroConfig.props,\n    store: store // 下发主应用的 store\n}\n\nloadMicroApp(currentApp)\n```\n\n- 子应用接受并使用\n\n```\n// 微应用 mount 中接收\nexport async function mount(props) {\n    render(props)\n}\n\n// 动态挂载 通过 this.$root.xxx 使用data的数据\nfunction render(props = {}) {\n    const { container, store } = props\n    instance = new Vue({\n        childStore,\n        data() {\n            return {\n                parentVuex: store, // 父应用 vuex\n            }\n        },\n        render: h => h(App)\n    }).$mount(container ? container.querySelector('#you-micro') : '#you-micro')\n}\n```\n\n- 使用\n\n```\nthis.$root.parentVuex.state.xxxx // 读\n\nthis.$root.parentVuex.commit('xxxx', {}) // 写\n```\n\n# 十七、微应用内存溢出思考\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/4BE2856A49C836B73C11D1704D5476E7.jpg)image.png\n\n- qiankun 会将微应用的 JS/CSS 内容都记录在全局变量中，如果一直重复的挂载应用没有卸载，会导致内存占用过多，导致页面卡顿\n- 虽然官方没有明确说名内存的溢出问题，但是笔者在开发的过程中，在重复加载应用的时候崩溃过几次，出于安全性思考还是使用一些手段来约束变量的开销吧～\n\n1. 微应用卸载的时候清空微应用注册的附加内容及 DOM 元素等\n2. 设置自动销毁时间，去销毁那些长时间挂载的应用，\n3. 设置最大运行应用数量，超过规定的数量的时候吧第一个应用销毁\n\n**1. 卸载时清空无用实例**\n\n```\nexport async function unmount() { \n    instance.$destroy() \n    instance.$el.innerHTML = '' // 关键\n    instance = null \n    route = null\n    // ... more\n}\n```\n\n**2. 设置过期时间与最大运行数，这里的的内容可以结合上面的内容来看，上文有对应的说明**\n\n```\n// src/const/micro/index.js\nexport const MAX_RUN_MICRO_NUMBER = 5 // 最大运行微应用数量\n// 主应用/src/const/micro/application-list.js\n\nexport default [{\n    name: 'you-app-name', // 应用的名字\n    // ... micro app config\n    // 自动销毁时间 单位：3000（ms） or (Infinity = 永久不会销毁）\n    unmountTime: '300000'\n}]\n```\n\n**注册的时候记录时间**\n\n```\n// src/const/micro/qianun-utils.js\n// 注册应用的方法\nexport function loadRouterMicroApp(currentApp) {\n    // 1. 返回注册应用对象\n    const micro = loadMicroApp(currentApp)\n    // 2. 微应用挂载完成\n    micro.mountPromise.then(() => {\n        // 3. 在应用对象，增加开始时间字段，记录微应用挂载时间\n        micro.createTime = new Date().getTime()\n        // 4. 在应用对象，增加卸载时间字段 记录应用卸载时间，如果时间是空默认 永不销毁\n        micro.unmountTime = currentApp.unmountTime || 'Infinity'\n        // 5. 设置当前应用列表, 记录挂载应用挂载信息，后期路由会匹配是否是否需要卸载\n        store.dispatch('d2admin/micro/SET_MICRO_APPLICATION_LIST', {\n            key: currentApp.activeRule,\n            value: micro\n        })\n    })\n}\n```\n\n**路由守卫的时候判断是否需要卸载**\n\n```\nrouter.afterEach(to => {\n    microApplicationLoading(to.path)\n})\n// 主应用/src/const/micro/qianun-utils.js\n\n// 加载微应用方法\nexport async function microApplicationLoading(path) {\n    // 1. 根据路由地址加载当前应用配置\n    let currentActiveMicroConfig = await store.dispatch('d2admin/micro/GET_FIND_MICRO_CONFIG', path)\n\n    // 2. 获取微应用列表\n    const microApplicationList = store.getters['d2admin/micro/microApplicationList']\n\n    // 3. 判断应用运行时间销毁应用\n    store.dispatch('d2admin/micro/CHECK_UNMOUNT_MICRO', { microApplicationList, currentActiveMicroConfig })\n\n    // ... code 后面注册判断操作就省略了\n}\n```\n\n判断是否最大堆栈、判断是否超时销毁\n\n```\n// 主应用/src/store/modules/d2admin/modules/micro.js\n\nexport default {\n    state: {\n        microApplicationList: new Map([]),\n    },\n    actions: {\n        // 检查一下是否需要卸载微应用 依据时间来判断 microApplicationList：缓存微应用列表，currentActiveMicroConfig：当前URL匹配的微应用配置\n        CHECK_UNMOUNT_MICRO({ state, dispatch }, { microApplicationList, currentActiveMicroConfig }) {\n            // 1. 判断时候有缓存列表\n            if (!microApplicationList.size) {\n                return\n            }\n            \n            // 2. 获取当前时间\n            const currentTime = new Date().getTime()\n\n            // 3. 遍历缓存应用列表，判断应用是否需要销毁了～\n            Array.from(microApplicationList).forEach(([key, item]) => {\n                // 4. 获取应用运行时间\n                const runningTime = currentTime - item.createTime\n                // 5. 获取应用卸载时间\n                const unmountTime = item.unmountTime\n\n                // 6. 如果有微应用配置，这说明跳转就是已经挂载过的微应用了，刷新应用时间与取消应用销毁（续费一下，避免销毁有激活重复开销）\n                if (currentActiveMicroConfig) {\n                    item.createTime = new Date().getTime()\n                    // ！！！设置一下当前缓存应用列表，更新应用时间，判断是否达到最大堆栈，是否需要清除应用！！！\n                    dispatch('SET_MICRO_APPLICATION_LIST', {\n                        key: item.activeRule,\n                        value: item\n                    })\n                    return\n                }\n                \n                // 7. 如果运行时大于销毁时间则销毁对应应用，并且不是 Infinity 关键字\n                if (runningTime >= unmountTime && unmountTime !== 'Infinity') {\n                    dispatch('DELETE_MICRO_APPLICATION_LIST', key)\n                }\n            })\n        },\n        \n        // 删除微应用程序列表\n        DELETE_MICRO_APPLICATION_LIST({ state }, key) {\n            const micro = state.microApplicationList.get(key)\n            micro && micro.unmount()\n            state.microApplicationList.delete(key)\n        },\n        \n        // 设置微应用程序列表\n        SET_MICRO_APPLICATION_LIST({ state, dispatch }, { key, value }) {\n            // 判断是否达到最大堆栈，清除应用\n            dispatch('CLEAR_MICRO_STACK')\n            state.microApplicationList.set(key, value)\n        },\n        \n        // 检查是否需要清空堆栈\n        CLEAR_MICRO_STACK({ state, dispatch }) {\n            // 判断是否是 Infinity 无堆栈限制\n            if (MAX_RUN_MICRO_NUMBER === 'Infinity') {\n                return\n            }\n\n            // 判断是否达到最大堆栈\n            if (state.microApplicationList.size < MAX_RUN_MICRO_NUMBER) {\n                return\n            }\n\n            // 获取MAP的第一个应用销毁并删除vuex信息\n            const key = state.microApplicationList.keys().next().value\n            dispatch('DELETE_MICRO_APPLICATION_LIST', key)\n        }\n    }\n}\n```\n\n# 十八、同一路由多应用共存\n\n- 如果一个页面同时展示多个微应用，需要使用 `loadMicroApp` 来加载。\n- 如果这些微应用都有路由跳转的需求，要保证这些路由能互不干扰，需要使用 `momery` 路由。\n- `vue-router` 使用 `abstract` 模式，`react-router` 使用 `memory history` 模式，`angular-router` 不支持。\n- Vue Router 的导航方法 (`push`、 `replace`、 `go`) 在各类路由模式(`history`、 `hash` 和 `abstract`) 下表现一致。\n- `abstract` 是vue路由中的第三种模式，本身是用来在不支持浏览器API的环境中，充当fallback，无论 hash还是history模式都会对浏览器上的url产生作用，于是我们利用到了abstract这种与浏览器分离的路由模式解决多应用路由冲突的问题。\n\n```\nfunction render({ data = {} , container, defaultPath } = {}) {\n    router = new VueRouter({\n        mode: 'abstract', // 不会被URL所影响\n        routes\n    })\n\n    instance = new Vue({\n        router,\n        store,\n        render: h => h(App)\n    }).$mount(container ? container.querySelector('#appVueHash') : '#appVueHash')\n\n    if (defaultPath) {\n        router.push(defaultPath)\n    }\n}\n```\n\n# 十九、微应用开发与部署\n\n## 开发与部署目录建议\n\n> 建议在开发与部署的时候，所有的微应用都放在一个目录，虽然qiankun的应用只需提供微应用URL地址即可，从理论上来说项目放在那里都是没有影响的。但是出于管理维护的目的，我们还是推荐：\n\n- 相关应用都在同一个目录下，统一管理\n- 所有微应用都是独立项目、独立仓库、独立部署\n\n```\n└── micro-app-container       # 根文件夹\n    ├── main/                 # 基座应用/主应用\n    ├── child/                # 存放所有微应用的文件夹\n    |   ├── vue-hash/         # 存放微应用 vue-hash 的文件夹\n    |   ├── vue-history/      # 存放微应用 vue-history 的文件夹\n    ├── package.json          # 公共文件的 index.html 执行命令\n    ├── node_modules/         # 公共文件依赖\n```\n\n## 使用npm-run-all 简化script配置\n\n根据上面的结构一个一个 启动or打包应用太麻烦了，使用npm-run-all 命令 **解决npm run** **命令无法同时运行多个脚本的问题**\n\nnpm-run-all的三个特点：\n\n- 顺序执行 、并行执行、混合执行\n- `--parallel`: 并行运行多个命令，例如：npm-run-all --parallel lint build\n- `--serial`: 多个命令按排列顺序执行，例如：npm-run-all --serial clean lint build:\n- `--continue-on-error`: 是否忽略错误，添加此参数 npm-run-all 会自动退出出错的命令，继续运行正常的\n- `--race`: 添加此参数之后，只要有一个命令运行出错，那么 npm-run-all 就会结束掉全部的命令\n\n安装依赖\n\n```\nnpm install npm-run-all --save-dev\n// or\nyarn add npm-run-all --dev\n```\n\n配置命令 package.json, 一键给所有应用安装依赖\n\n```\n// 执行 install: 的命令～ 可以批量执行相同命令的前缀，可以异步、同步执行命令\n// 例如：npm run install-all 就给所有项目安装依赖\n\"scripts\": {\n    \"install:child-hash\": \"cd child/child-hash && yarn\",\n    \"install:child-history\": \"cd child/child-history && yarn\",\n    \"install:main\": \"cd main && yarn\",\n    \"install-all\": \"npm-run-all install:*\", // 全局安装依赖\n\n    \"start:child-hash\": \"cd child/child-hash && npm run serve\",\n    \"start:child-history\": \"cd child/child-history && npm run serve\",\n    \"start:main\": \"cd main && npm run serve\",\n    \"serve-all\": \"npm-run-all --parallel start:*\", // 全局启动\n\n    \"build:child-hash\": \"cd child/child-hash && npm run build\",\n    \"build:child-history\": \"cd child/child-history && npm run build\",\n    \"build:main\": \"cd main && npm run build\",\n    \"build-all\": \"npm-run-all --parallel build:*\" // 全局打包\n}\n```\n\n**或者配合脚本可以自己写一写简单的 shell 脚本**\n\n```\n# script/clone-all.sh\n# 相关项目地址\n\n# xxx 项目\ngit clone http:/xxxxxxx.git\n\n# xxx 项目\ngit clone http://xxxxxxxx.git\n```\n\n**package.json 中增加命令执行**\n\n```\n\"clone:all\": \"bash ./scripts/clone-all.sh\" // npm run clone:all 便可以批量克隆项目了 \n```\n\n**部署的时候也和开发的时候一样，不过可以直接放在基座应用里面使用**\n\n```\n└── html/                     # 根文件夹\n    |\n    ├── child/                # 存放所有微应用的文件夹\n    |   ├── vue-hash/         # 存放微应用 vue-hash 的文件夹\n    |   ├── vue-history/      # 存放微应用 vue-history 的文件夹\n    ├── index.html            # 主应用的index.html\n    ├── css/                  # 主应用的css文件夹\n    ├── js/                   # 主应用的js文件夹\n```\n\n**此时需要设置微应用构建时的 `publicPath` 和 `history` 模式的路由 `base`，然后才能打包放到对应的目录里。构建的时候切记要修改 webpack 中的 publicPath 地址！！！**\n\n| 项目        | 路由 base           | publicPath          | 真实访问路径                             |\n| :---------- | :------------------ | :------------------ | :--------------------------------------- |\n| vue-hash    | 无                  | /child/vue-hash/    | http://localhost:8080/child/vue-hash/    |\n| vue-history | /child/vue-history/ | /child/vue-history/ | http://localhost:8080/child/vue-history/ |\n\n- vue-history 微应用\n\n  ```\n  base: window.__POWERED_BY_QIANKUN__ ? '/app-vue-history/' : '/child/vue-history/',\n  ```\n\n  ```\n  module.exports = {\n    publicPath: '/child/vue-history/',\n  };\n  ```\n\n1. 同时主应用的配置文件 entry 入口也要和当前环境一样需要动态更改\n\n1. 微应用 webpack 打包 publicPath 配置（`vue.config.js`）：\n\n1. 微应用路由设置：\n\n但是笔者觉得这样写真的不优雅，笔者希望有关于微前端的所有配置都在一个微前端配置页里面维护，并且清晰可见。\n\n所以笔者的做法是方法判断环境传入一个对象，减少三元的丑陋与混乱，把路由前缀动态的下发给微应用，但微应用注册的时候，在动态把前缀加上\n\n```\n// 主应用 src/const/micro/application-list.js\n// 获取不同环境的入口\nfunction getEentry({ prodPath, devPath }) {\n    const isProduction = process.env.NODE_ENV === 'production'\n    return isProduction ? prodPath : devPath\n}\n\n// 注册微应用列表\nexport default [\n    {\n        name: 'your-name', // 应用的名字\n        // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch\n        entry: getEentry({\n            devPath: '//localhost:7286/', // 开发环境地址\n            prodPath: `/child/your-name/` // 生产环境地址\n        }),\n        props: { // 下发微应用的入口\n            routeBase: '/app-vue-history/', // 动态下发路由前缀\n        }\n    }\n]\n```\n\n# 总结\n\n- 感谢各位能看到这里，这是笔者在微前端实践的一些心得，碍于篇幅原因，很多技术细节我们就不再文中赘述了，如果有希望了解更多 qiankun 原理，或者更多实践细节的小伙伴，可以在文章底部留言，在**此很感谢能给予我实践机会的彬哥与标哥**，希望本文能在您微前端的探索之路为您照亮前方，感谢支持，本文如果有笔误的的地方，欢迎提出，定会及时修复与改进，愿君代码路上一路畅通无阻～",
                    "title": "二、微前端技术选型"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/Homebrew 切换包版本.md",
                    "content": "#bash #tools #brew #docs/how-to-guides \n\n\n```\n brew switch icu4c 62.1\n```\n \n## Listing Older Versions\n\nFirst, let's get to the location where the Homebrew Formulas are stored.\n\n```sh\n$ cd $(brew --prefix)/Homebrew/Library/Taps/homebrew/homebrew-core/Formula\n```\n\nNext, we need to look for the git commit for the version we want\n\n```sh\n$ git log --follow icu4c.rb\ncommit c179a064276d698d66953898ff9e02d6e0664b2a\nAuthor: BrewTestBot <brew-test-bot@googlegroups.com>\nDate:   Wed Aug 15 21:51:09 2018 +0000\n\n    icu4c: update 62.1 bottle.\n\ncommit 2235a91cedb2038a7c721796b48e63836c792607\nAuthor: ilovezfs <ilovezfs@icloud.com>\nDate:   Tue Jul 24 09:44:31 2018 +0200\n\n    icu4c: remove head spec (#30427)\n\ncommit e6b65d7433d0a18c36eb584be554500b6ec06884\nAuthor: BrewTestBot <brew-test-bot@googlegroups.com>\nDate:   Fri Jun 22 02:12:37 2018 +0000\n\n    icu4c: update 62.1 bottle.\n\ncommit 004bdfeef173becdc7e1344a4c095945a97ca410\nAuthor: Chongyu Zhu <i@lembacon.com>\nDate:   Thu Jun 21 08:27:56 2018 +0800\n\n    icu4c 62.1\n\ncommit 6d98155ab46f61482f16f8bcffb378a0a71e0d15\nAuthor: BrewTestBot <brew-test-bot@googlegroups.com>\nDate:   Thu Mar 29 06:16:10 2018 +0000\n\n    icu4c: update 61.1 bottle.\n\ncommit 3f4b2375618b730d038c6a739170bf44af8ba5a0\nAuthor: commitay <commitay@users.noreply.github.com>\nDate:   Tue Mar 27 08:02:19 2018 +1000\n\n    icu4c 61.1\n```\n\n\n\n \nNow that we have identified the commit\n \n6d981\n\n, we can create a new branch with that commit\n\n```sh\n$ git checkout -b icu4c-61.1 6d9815\nSwitched to a new branch 'icu4c-61.1'\n```\n\nThen we can proceed to install the Formula\n\n```sh\n$ brew reinstall ./icu4c.rb\n```\n\nThen I can switch to the older version\n\n```sh\n$ brew switch icu4c 61.1\n```\n\n \n\n```ruby\nclass Icu4cAT611 < Formula\n```\n\n## Check For Dependencies And Syntax Changes\n\nNote that the Homebrew Formula syntax may evolve over time, and your older formula may also have specific dependencies. For example, this Python 3.5.2 formula gives the following error\n\n```ruby\n$ brew audit --strict --online ./python@3.5.2.rb\nBroken dependencies:\n  /usr/local/opt/gdbm/lib/libgdbm.4.dylib (gdbm)\npython352:\n  * C: 96: col 1: Use 2 spaces for indentation in a heredoc.\n  * python352 has broken dynamic library links:\n     \nError: 2 problems in 1 formula\n```\n\n \n\n```sh\n$ brew tap hanxue/homebrew-versions\n$ brew install icu4c@61.1\n```\n\n\n\n\n\n[http://hanxue-it.blogspot.com/2018/08/macos-homebrew-installing-older-version-of-software.html](http://hanxue-it.blogspot.com/2018/08/macos-homebrew-installing-older-version-of-software.html)\n\n https://discourse.brew.sh/t/undefined-method-prefer-64-bit-for-os-module/3837/2\n\n https://stackoverflow.com/questions/3987683/homebrew-install-specific-version-of-formula",
                    "title": "Homebrew 切换包版本"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/What is Bash.md",
                    "content": "#definition  #docs/reference \n\nsh 是一种由 POSIX standard **定义**的语言.它是一种标准, 不是实现. 但它有很多实现.\n\n比如 dash, ksh88,ash\n\n/bin/sh 通常是一个链接.链接到实现了 sh 的程序上.比如 bash\n\n```\n>> sh --version\nGNU bash, version 3.2.57(1)-release (x86_64-apple-darwin16)\nCopyright (C) 2007 Free Software Foundation, Inc.\n```\n\nbash 是早于 sh POSIX 标准的.   但可以使用 bash --posix 来与posix兼容.  \n\n1. 最近的 Debian 和 Ubuntu 都是使用链接 sh 到  dash\n2. BSDs, 一般使用 pdksh\n\n使用 Shebang line 来决定一个脚本文件到底用什么执行\n\n```\n#!/bin/sh  \n```\n\n将使用 sh 指向的实现\n\n```\n#!/bin/dash \n```\n\n将使用 dash\n\n\n\n可以使用以下命令检测当前 shell 环境\n\n```\necho $0\n```\n\n 或者\n\n```shell\nps -p $$\n```\n",
                    "title": "What is Bash"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/check if file exist.md",
                    "content": "#bash #docs/how-to-guides \n\n [ -f ./a.jpg ] && echo \"$FILE exist\" || echo \"not exist\"",
                    "title": "check if file exist"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/check if string exist.md",
                    "content": "#bash #docs/how-to-guides \n\n```shell\n[[ \"$BROWSER\" == \"Chrome \"]] && echo \"its Chrome\"\n```",
                    "title": "check if string exist"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/echo.md",
                    "content": "#docs/whatis-why-explanation  #bash \n\n`echo` prints all of its arguments. It does not read from `stdin`. So the second `echo` prints all of its arguments (none) and exits, ignoring the `Hello` on `stdin`.\n\nFor a program that reads its `stdin` and prints that to `stdout`, use `cat`:\n\n```sh\n$ echo Hello | cat\nHello\n```",
                    "title": "echo"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/expand in zsh.md",
                    "content": "#docs/how-to-guides  #bash\n\n\n```bash\nconvert image.{jpg,png}  <tab>\n=>\nconvert image.jpg image.png \n\ntouch foo.{,1,2,10} <tab>\n=>\ntouch foo. foo.1 foo.2 foo.10 \n\n\ntouch project{1,2}/src/test/test{1,2,3}  \n\n# first you need foo bar folders exist \ntouch {foo,bar}/{a..j}\n```\n\n![Image](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2020-02-10-10:48.png)",
                    "title": "expand in zsh"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/get bash real path.md",
                    "content": "#bash #docs/how-to-guides \nthis is useful when you need to write script executed everywhere.\n\n``` bash\n#!/bin/bash\n\necho $0\n \nfull_path=$(realpath $0)\necho $full_path\n\n\ndir_path=$(dirname $0)\necho $dir_path\n \nexamples=$(dirname $dir_path )\necho $examples\n \ndata_dir=\"$examples/data\"\necho \"DATA: $data_dir\"\n```\n\n \n \n ",
                    "title": "get bash real path"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/login shell & non login shell.md",
                    "content": "#docs/reference  #bash \n\nlogin shell\n\n在成功登陆后。login shell 就启动了。mac 打开的 shell都是login　shell.而 linux　则是 non login.\n\n查看是不是 login shell\n\n```shell\necho $0\t\n-bash   # - 代表这是一个 login　shell\nbash    # 没有 - ，代表这是一个 nonlogin shell\n```\n\n\n\n所以，在 mac　里打开 terminal，读的是 \n\n.bash_profile \n\nWhen `bash` cannot find `.bash_profile` it will look for `.bash_login`and if that does not exist either `.profile`. If `.bash_profile` is present the succeeding files will be ignored. (though you can `source` them in your `.bash_profile`)\n\n\n\nThere is also a file `/etc/profile` that is run for interactive login shells (and Terminal.app). This provides a central location to configure the shells for all users on a system. On macOS `/etc/profile`sets the default `PATH` with the `path_helper` tool and then `source`s `/etc/bashrc` which (you guessed) would be the central file for all users that is executed for non-login interactive shells. For macOS Terminal.app `/etc/bashrc` sets the default prompt and then itself sources `/etc/bashrc_Apple_Terminal` which sets up the session persistence across logins.\n\nSo in macOS Terminal.app, before you even see a prompt, these scripts will be run:\n\n-   /etc/profile\n\n  -\n    /etc/bashrc\n\n    - `/etc/bashrc_Apple_Terminal`\n\n- if it exists:\n\n  ```\n  ~/.bash_profile\n  ```\n\n  - when `~/.bash_profile` does not exists, `~/.bash_login`\n  - when neither `~/.bash_profile` nor `~/.bash_login` exist, `~/.profile`\n\n- `~/bash_profile` can optionally source `~/.bashrc`\n\nhttps://scriptingosx.com/2017/04/about-bash_profile-and-bashrc-on-macos/",
                    "title": "login shell & non login shell"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/makefile.md",
                    "content": "#docs/how-to-guides \n\n## 概念\n\n```makefile\n<target> : <prerequisites>\n[tab]<command>\n```\n\ntarget 是必须的,不可省略.\n\nprerequisites 和 command  是可选的.但两都至少有一个.\n\n\n\n每条规则就明确两件事\n\n1. 构建目标的前置条件是什么\n\n2. 如何构建\n\n## 文件格式\n\n### 目标\n\n目标通常有 3 类\n\n1. 一个文件名. \n\n2. 多个文件名,用空格分隔.\n\n3. 某个操作名.这种叫伪目标. (phony target)\n\n   但如果当前目录有,正好有一个文件叫做 clean.那这个目标就不会执行了.因为文件已存在.为了避免这种情况.通常明确声明伪目标\n\n   ```makefile\n   .PHONE: clean\n   clean:\n   \trm *.o temp\n   ```\n\n   \n\n如果 make 时没有指定目标.默认会执行第一个目标.\n\n\n\n### 前置条件\n\n前置条件通常是一组文件名,之间用空格分隔. 它是目标是否需要重构的决断依据.只要前一个前置文件不存在,或者有过更新(通过对比目标与前置文件的 last-modification时间戳,前置的比目标新). 目标就需要重新重新构建.\n\n```makefile\nresult.txt: source.txt\n\tcp source.txt result.txt\t\n```\n\n上面代码中.如果 source.txt存在.那么\n\n`make result.txt` 可以正常运行.否则.必须写一条规则,来生成 source.txt\n\n```makefile\nsource.txt:\n\techo \"this is the source\" > source.txt\n```\n\n\n\n### 命令\n\n每行命令必须以 tab 开头. \n\n**每条规则里的每行**在执行时都是在一个单独的 shell 中执行. 之间没有继承关系.\n\n```makefile\nvar-lost:\n    export foo=bar\n    echo \"foo=[$$foo]\"\n```\n\n上述代码执行后. foo 为空\n\n要解决这个问题, 可以加上分号,写在一行\n\n ```makefile\nvar-lost:\n    export foo=bar;echo \"foo=[$$foo]\"\n ```\n\n\n\n另一种解决方法是在换行前加反斜杠转义\n\n```makefile\n\nvar-kept:\n    export foo=bar; \\\n    echo \"foo=[$$foo]\"\n```\n\n\n\n最后一种方法是加上 `.ONESHELL:` 命令  (我的机上不起作用)\n\n```makefile\n.ONESHELL:\nvar-kept:\n    export foo=bar; \n    echo \"foo=[$$foo]\"\n```\n\n\n\n## 语法\n\n### 注释\n\n```makefile\n# bash-makefile\nresult.txt: source.txt\n    # 这是注释\n    cp source.txt result.txt # 这也是注释\n```\n\n\n\n###  回声\n\n正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。\n\n```makefile\n\ntest:\n    # 这是测试\n```\n\n执行上面的规则，会得到下面的结果。\n\n```shell\n\n$ make test\n# 这是测试\n```\n\n在命令的前面加上@，就可以关闭回声。\n\n现在再执行`make test`，就不会有任何输出。\n\n由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。\n\n```makefile\ntest:\n    @# 这是测试\n    @echo TODO\n```\n\n\n\n### 通配符\n\nMakefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为o的文件。\n\n```makefile\nclean:\n        rm -f *.o\n```\n\n\n\n### 模式匹配\n\nMake命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。\n\n```makefile\n%.o: %.c\n```\n\n等同于下面的写法。\n\n```makefile\nf1.o: f1.c\nf2.o: f2.c\n```\n\n使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。\n\n\n\n### 变量和赋值符\n\nMakefile 允许使用等号自定义变量。\n\n```makefile\ntxt = Hello World\ntest:\n    @echo $(txt)\n```\n\n调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。\n\n```makefile\ntest:\n    @echo $$HOME\n```\n\n有时，变量的值可能指向另一个变量。\n\n```makefile\nv1 = $(v2)\n```\n\n上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。\n\n为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看[StackOverflow](http://stackoverflow.com/questions/448910/makefile-variable-assignment)。\n\n\n\n### 内置变量\n\nMake命令提供一系列内置变量，比如，\\$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见[手册](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)。\n\n```makefile\noutput:\n    $(CC) -o output input.c\n```\n\n\n\n\n\n### 自动变量\n\nMake命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。\n\n**(1) $@**\n\n$@指代当前目标，就是Make命令当前构建的那个目标。比如，`make foo`的 ​\\$@ 就指代foo。\n\n```makefile\na.txt b.txt: \n    touch $@\n```\n\n等同于下面的写法。\n\n```makefile\na.txt:\n    touch a.txt\nb.txt:\n    touch b.txt\n```\n\n\n\n```makefile\na.txt: b.txt c.txt\n    cp $< $@ \n```\n\n等同于下面的写法。\n\n```makefile\n\na.txt: b.txt c.txt\n    cp b.txt a.txt \n```\n\n**(3) $?**\n\n\\$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，\\$?就指代p2。\n\n\n\n**(4)$^**\n\n\\$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 \\$^ 就指代 p1 p2 。\n\n**5）$\\***\n\n\\$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。\n\n**（6）\\$(@D) 和 $(@F)**\n\n\\$(@D) 和 ​\\$(@F) 分别指向 ​\\$@ 的目录名和文件名。比如，\\$@是 src/input.c，那么\\$(@D) 的值为 src ，​\\$(@F) 的值为 input.c。\n\n所有的自动变量清单，请看[手册](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)。下面是自动变量的一个例子。\n\n\n\n```makefile\ndest/%.txt: src/%.txt\n    @[ -d dest ] || mkdir dest\n    cp $< $@\n```\n\n上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，\\$\\< 指代前置文件（src/%.txt）， ​\\$@ 指代目标文件（dest/%.txt）。\n\n###  判断和循环\n\nMakefile使用 Bash 语法，完成判断和循环。\n\n```bash\nifeq ($(CC),gcc)\n  libs=$(libs_for_gcc)\nelse\n  libs=$(normal_libs)\nendif\n```\n\n上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。\n\n```bash\nLIST = one two three\nall:\n    for i in $(LIST); do \\\n        echo $$i; \\\n    done\n\n# 等同于\n\nall:\n    for i in one two three; do \\\n        echo $i; \\\n    done\n```\n\n上面代码的运行结果。\n\n```bash\none\ntwo\nthree\n```\n\n\n\n### 函数\n\nMakefile 还可以使用函数，格式如下。\n\n```bash\n$(function arguments)\n# 或者\n${function arguments}\n```\n\nMakefile提供了许多[内置函数](http://www.gnu.org/software/make/manual/html_node/Functions.html)，可供调用。下面是几个常用的内置函数。\n\n**（1）shell 函数**\n\nshell 函数用来执行 shell 命令\n\n```shell\nsrcfiles := $(shell echo src/{00..99}.txt)\n```\n\n**（2）wildcard 函数**\n\nwildcard 函数用来在 Makefile 中，替换 Bash 的通配符。\n\n```shell\nsrcfiles := $(wildcard src/*.txt)\t\n```\n\n**（3）subst 函数**\n\nsubst 函数用来文本替换，格式如下。\n\n```bash\n$(subst from,to,text)\n```\n\n下面的例子将字符串\"feet on the street\"替换成\"fEEt on the strEEt\"。\n\n```bash\n$(subst ee,EE,feet on the street)\n```\n\n下面是一个稍微复杂的例子。\n\n```bash\ncomma:= ,\nempty:=\n# space变量用两个空变量作为标识符，当中是一个空格\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n# bar is now `a,b,c'.\n```\n\n**（4）patsubst函数**\n\npatsubst 函数用于模式匹配的替换，格式如下。\n\n```bash\n$(patsubst pattern,replacement,text)\n```\n\n下面的例子将文件名\"x.c.c bar.c\"，替换成\"x.c.o bar.o\"。\n\n```bash\n$(patsubst %.c,%.o,x.c.c bar.c)\n```\n\n**（5）替换后缀名**\n\n替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。\n\n```bash\nmin: $(OUTPUT:.js=.min.js)\n```\n\n上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。\n\n\n\n## Makefile 的实例\n\n**（1）执行多个目标**\n\n```makefile\n.PHONY: cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff\n        rm program\n\ncleanobj :\n        rm *.o\n\ncleandiff :\n        rm *.diff\n```\n\n上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。\n\n**（2）编译C语言项目**\n\n```makefile\nedit : main.o kbd.o command.o display.o \n    cc -o edit main.o kbd.o command.o display.o\n\nmain.o : main.c defs.h\n    cc -c main.c\nkbd.o : kbd.c defs.h command.h\n    cc -c kbd.c\ncommand.o : command.c defs.h command.h\n    cc -c command.c\ndisplay.o : display.c defs.h\n    cc -c display.c\n\nclean :\n     rm edit main.o kbd.o command.o display.o\n\n.PHONY: edit clean\n```\n\n\n\n## 使用 Make 构建网站\n\n\n\n##  Demo \nhttps://www.youtube.com/watch?v=_Ms1Z4xfqv4&pbjreload=10\n\n``` Makefile\n\npaper.pdf: paper.md plot-data.png\n\techo \"--\" >$@\n\nplot-%.png: %.dat plot.py\n\t# $* crosponds to % \n\t# $@ equals the target\n\t#\n\t# support we have 1.dat 2.dat\n\t# below commands equals to \n\t# ./plot.py -i 1.dat plot-2.png \n\t# ./plot.py -i 2.dat plot-2.png \n\t# ./plot.py -i  $* -o $@\n\tcat $*.dat > $@ \n\n```\n\n\n\n\n",
                    "title": "makefile"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/sed.md",
                    "content": "#bash  #docs/reference \n\nStream editor \n\n替换跟 vim 一样\n\n## syntax \n```\nsed SCRIPT INPUTFILE...\n```\n\n\n\n```bash\n# bash-sed & awk 技巧\nsed 's/old/new/' < old.txt >new.txt\n\n#  以:为分隔符替换\nsed 's:/usr/local/bin:/common/bin:' < old.txt >new.txt\n\n# 正则表达式 & 代表找到的.  -E 代表正则表达式扩展,支持+ (Mac)  -r (linux)\n echo \"123 abc\" | sed -E 's/[0-9]+/& &/'\n\n# 替换 \\1 \necho abcd123 | sed 's/\\([\na-z]*\\).*/\\1/'\n\n# 交替两个单词\necho abc efg | sed -E 's/([a-z]+) ([a-z]+)/\\2 \\1/' # Using Apple Mac OS X\n\n# 只使第 2 次匹配生效\necho a b c d  | sed 's/[a-zA-Z]* //2' \n#> a c d\n\n# 全局匹配\necho a b c d  | sed 's/[a-zA-Z]*/1/g'  \n#> 1 1 1 1\n\n\n\n\n```\n\n## Demo\n\n### 替换 hello 为 world\n\n```shell\nsedl 's/hello/world/' input.txt > output.txt\n```\n\n如果没有指定 INPUTFILE, 或者 INPUTFILE 为 - d.\n\n则这些命令是一样\n\n```shell\nsed 's/hello/world/' input.txt > output.txt\nsed 's/hello/world/' < input.txt > output.txt\ncat input.txt | sed 's/hello/world/' - > output.txt\n```\n\n\n\n### 直接在文件里修改\n\n```shell\nsed -i 's/hello/world/' file.txt\n```\n\n-i  也就是 inplace 的意思\n\n\n\n### 多次替换\n\n默认 sed 后面第一个非 option 的参数为 SCRIPT,后面的非 option 的参数为 INPUTFILE\n\n使用 -e 命令可以指定多次替换\n\n```shell\nsed -e 's/find/replace/' -e 's/find/replace/' filename\n```\n\n",
                    "title": "sed"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/show system log.md",
                    "content": "#mac #docs/how-to-guides \n\nlog show --last 1s",
                    "title": "show system log"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/shrink image using convert.md",
                    "content": "#mac #docs/how-to-guides \n\n```bash\n convert temporary.gif -resize 300x300 smaller.gif\n \n```",
                    "title": "shrink image using convert"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/bash/using FFmpeg record gif.md",
                    "content": "#ffmpeg  #docs/how-to-guides  \n``` bash\n#  录制屏幕\nffmpeg -f avfoundation -i \"1\" -pix_fmt yuv420p -r 25 -t 5 out.mov\n\n# 转换格式为 gif\nffmpeg -i out.mov -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=0 --delay=3 > movie-name.gif\n\n\n```",
                    "title": "using FFmpeg record gif"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/git/git internal.md",
                    "content": "#git #docs/whatis-why-explanation  \n\n \nTree contains (Tree | Blob)\nBlob constains bytes of file\nCommit\nObject\nRefs\n\n\n##  internal flow\n### git init\n\n```bash\nmkdir gitdemo && cd gitdemo\ngit init \ntree -a     \n```\n\nnothings exists other than hooks. \t\n\n\n\n.\n├── .DS_Store\n└── .git\n    ├── HEAD\n    ├── config\n    ├── description\n    ├── hooks\n    │   ├── applypatch-msg.sample\n    │   ├── commit-msg.sample\n    │   ├── post-update.sample\n    │   ├── pre-applypatch.sample\n    │   ├── pre-commit.sample\n    │   ├── pre-push.sample\n    │   ├── pre-rebase.sample\n    │   ├── pre-receive.sample\n    │   ├── prepare-commit-msg.sample\n    │   └── update.sample\n    ├── info\n    │   └── exclude\n    ├── objects\n    │   ├── info\n    │   └── pack\n    └── refs\n        ├── heads\n        └── tags\n\n### make a folder copy for comparison\n\n```bash\ncopy -r gitdemo  gitdemo2\n```\n\n\n\n### add file\n\n```bash\ncd gitdemo \necho \"hello,world\" >hello.txt\ngit add hello.txt\n```\n\n![image-20200210115754210](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20200210115754210.png)\n\nsha1 include the folder name and the file name\n\nsha1(hello.txt) = 2d832d9....\n\n\n\ngit commit\n\n```bash\ngit commit\n```\n\n![image-20200210121230166](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20200210121230166.png)\n\n```bash\ngit cat-file -p fe05fd05de\n----------------------------------------------\ntree c8ba7a2a8ed5f8134b8038e5d0fdf7a6a759d619\nauthor zk <liuzq7@gmail.com> 1581307568 +0800\ncommitter zk <liuzq7@gmail.com> 1581307568 +0800\n\nadd hello.txt\n\ngit cat-file -p c8ba7 \n----------------------------------------------\n100644 blob 2d832d9044c698081e59c322d5a2a459da546469\thello.txt\n\n\ngit cat-file -p 2d832d9044c\n----------------------------------------------\nhello,world\n```\n\n\n\n## 原理\n\n在.git/object里,组成树的 object \n\n1. blob object 存储数据\n2. tree object 存储文件名字\n3. commit object  存储 commit 信息,人名,提交注释\n4. tag object \n\n在refs 文件夹里, 有 heads tags,相当于指针 \n![image-20210527180429157](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20210527180429157.png)\n\ngit checkout 只能  checkout commit object,\n\n---\n\n### Objects\n\n文件内容存储在 .git/objects\n校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。\n\n```\necho 'test content' | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n\n$ find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n```\n\n",
                    "title": "git internal"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/git/git submodule.md",
                    "content": "#git #docs/how-to-guides \n## 增加 submodule 到工程\n\n在你 git 的任意目录下\n```\ngit submodule add <gitRepoUrl> name -b master \n```\n\n> 要手动提交一下。git-sync 不会提交\n> 一定要使用 -b 指定分支\n\n``` conf\n[submodule \"SubmoduleTestRepo\"]\n    path = SubmoduleTestRepo\n    url = https://github.com/jzaccone/SubmoduleTestRepo.git\n    branch = master\n```\n## 本地工程初始化已存在的.submodule\n\n```\ngit submodule update --recursive --init\n```\n\n如果没反应，可能是由于你改了 .git 里的 modules 文件，导致文件版本对不上\n\n试着重新\n\n```\ngit submodule  add ssh://git@code.spacenx.cn:1022/privateZone/docs.git 4.工作/中科泰岳/项目/2.私域  -b master \n```\n\n\n\n## 更新最新 submodule\n\n在主工程里更新所有 submodule 到最新\ngit submodule update --remote --merge\n\n\n\n## 移除 submodule\n\n两种方法\n\n```\n0. mv a/submodule a/submodule_tmp\n\n1. git submodule deinit -f -- a/submodule    \n2. rm -rf .git/modules/a/submodule\n3. git rm -f a/submodule\n# git-submodule\n\n# or, if you want to leave it in your working tree and have done step 0\n3.   git rm --cached a/submodule\n3bis mv a/submodule_tmp a/submodule\n```\n\n\n\n参考：\nhttps://gb.yekai.net/concepts/subtree-vs-submodule\n",
                    "title": "git submodule"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/git/实时监控 git log.md",
                    "content": "#git #tips #docs/how-to-guides \n\n用下面的命令，颜色会正常显示\n\nwatch -c 'git log --graph --pretty=\"%C(yellow bold)%h %C(white)%s%C(nobold)\"'",
                    "title": "实时监控 git log"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/k8s/Ingress.md",
                    "content": "#k8s  #docs/whatis-why-explanation \n\n什么是 Ingress ？ 简要讲，它就是一个k8s 版的 nginx。\n\n上面讲 NodePort 的范围默认只能是 30000-32767，那如果我们的网站要暴露到 80 咋整？ 我们需要一个 proxy-server 代理 NodePort 到 80 端口。 如下图\n\n![image-20190919234347413](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190919234347413.png)\n\n那当我们需要 http://my-online-store.com/video时，又咋整。我们将原来http://my-online-store.com 变成 http://my-online-store.com/wear。如果我们又需要 https 呢？整在哪一层？\n\n![image-20190919235124364](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190919235124364.png)\n\n\n\nk8s 于是提出了 ingress 抽象。\n\n![image-20190919235309678](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190919235309678.png)\n\n#### 创建 ingress\n\n![image-20190924133955316](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190924133955316.png)\n\n创建 nginx ingress controller\n\n```yml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n\tname: nginx-ingress-controller\nspec:\n\treplicas: 1\n\tselector:\n\t\tmatchLabels:\n\t\t\tname: nginx-ingress\n\ttemplate:\n\t\tmetadata:\n\t\t\tlabels:\n\t\t\t\tname:\tnginx-ingress\n\t\tspec:\n\t\t\tcontainers:\n\t\t\t\t- name: nginx-ingress-controller\n\t\t\t\t  image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.21.0\n\t\t\targs:\n\t\t\t\t- /nginx-ingress-controller\n\t\tenv:\n\t\t\t- name: POD_NAME\n\t\t\t  valueFrom:\n\t\t\t  \tfieldRef:\n\t\t\t  \t\tfieldPath: metadata.name\n\t\t\t- name: POD_NAMESPACE\n\t\t    valueFrom:\n\t\t    \tfieldRef:\n\t\t    \t\tfieldPath: metadata.namespace\n\t\tporrts:\n\t\t\t- name: http\n\t\t\t  containerPort: 80\n\t\t\t- name: https\n\t\t\t  containerPort: 443\n```\n\nnginx ingress 的配置放在Configmap里,(现在什么都没有)\n\n```yml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n\tname: nginx-configuration\n```\n\n创建 nginx ingress service\n\n```yml\napiVersion: v1\nkind: Service\nmetadata:\n\tname: nginx-ingress\nspec:\n\ttype: NodePort\n\tports:\n\t- port: 80\n\t  targetPort: 80\n\t  protocol: TCP\n\t  name: http\n\t- port: 443\n\t  targetPort: 443\n\t  name: https\n\tselector:\n\t\tname: nginx-ingress\n```\n\n创建授权\n\n```yml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n\tname: nginx-ingress-serviceaccount\n```\n\n\n\n### 创建入口规则\n\n\n\n#####  只有一个后端\n\n\n\n![image-20190924134230174](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190924134230174.png)\n\n```yml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n\tname: ingress-wear\nspec:\n\tbackend:\n\t\tserviceName: wear-service\n\t\tservicePort: 80 \n```\n\n\n\n##### 多个后端\n\n![image-20190924134657443](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190924134657443.png)\n\n```yml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n\tname: ingress-wear-watch\nspec:\n\trules:\n\t- http:\n\t\tpaths:\n\t\t- path: /wear\n\t\t  backend:\n\t\t  \tserviceName: wear-service\n\t\t  \tservicePort: 80\n\t\t- path: /watch\n\t\t  backend:\n\t\t  \tserviceName: watch-service\n\t\t  \tservicePort: 80\t\t  \t \n```\n\n\n\n##### 基于 host\n\n![image-20190924135035163](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190924135035163.png)\n\n\n\n```yml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n\tname: ingress-wear-watch\nspec:\n\trule:\n\t- host: wear.my-online-store.com\n\t  http:\n\t  \tpaths:\n\t  \t- backend:\n\t  \t\tserviceName: wear-service\n\t  \t\tservicePort: 80\n\t- host: watch.my-online-store.com\n\t  http:\n\t  \tpaths:\n\t  \t- backend:\n\t  \t\tserviceName: watch-service\n\t  \t\tservicePort: 80\n```\n\n\n\n> host 不指定域名,则默认为 * 即全部.\n\n\n\n### 安全策略\n\n![image-20190924140520841](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190924140520841.png)\n\n>  Flannel 不支持安全策略\n\n```yml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n\tname: db-policy\nspec:\npodSelector:\n\tmatchLabels:\n\t\trole: db\n\tpolicyTypes:\n\t- ingress\n  ingress:\n  - from:\n  \t- podSelector:\n  \t\t\tmatchLabels:\n  \t\t\t\tname:\tapi-pod\n  \tports:\n  \t- protocol: TCP\n  \t  port:  3306\n```",
                    "title": "Ingress"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/k8s/Liveness Probe.md",
                    "content": "#k8s #docs/how-to-guides \n\n从开发者角度, 检测 Pod 是否真正运行了.比如通过检测某个接口是否返回了数据.\n\n```yml\napiVersion: v1\nkind: Pod\nmeataData:\n\tname: simple-webapp\n\tlabels:\n\t\tname: simple-webapp\nspec:\n\tcontainers:\n\t- name: simple-webapp\n\t  image: simple-webapp\n\t  ports:\n\t  - containerPort: 8080\n\t  # 定义 ready probe\n\t  redinessProbe:\n\t  \thttpGet:\n\t  \t\tpath: /api/ready\n\t  \t\tport: 8080\n\t  \t# 延迟 10 秒检测\n\t\t  initialDelaySeconds: 10\n\t\t  # 每 5 次 检测一次\n\t\t  periodSeconds: 5\n\t\t  # 最多检测 8 次\n\t\t  failureThreshold: 8\n\t\t# 定义 live probe, 与 probe 一模一样.只不过改个名字.\n\t\t#livenessProbe:\n\t\t\n```\n\n有很多种检测方法\n\n### Http\n\n```yml\n\t  redinessProbe:\n\t  \thttpGet:\n\t  \t\tpath: /api/ready\n\t  \t\tport: 8080\n```\n\n\n\n### TCP\n\n```yml\n\t  redinessProbe:\n\t  \ttcpSocket:\n\t  \t\tport: 8080\n```\n\n\n\n### Command\n\n```yml\n\t  redinessProbe:\n\t  \texec:\n\t  \t\tcommand:\n\t  \t\t  - cat\n\t  \t\t  - /app/is_ready\n```",
                    "title": "Liveness Probe"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/k8s/k8s Jobs.md",
                    "content": "#k8s  #docs/reference \n\nJob 保证了,只运行 n 次. 且成功运行.\n\n```yml\napiVersion: batch/v1\nkind: Job\nmetadata:\n\tname: math-add-job\nspec:\n# 一个结束后另一个的创建,总共创建 3 个\n  completions: 3\n#  保证最多同时运行3 个,且成功运行\n#  parallelism: 3\n\ttemplate:f \n\t\tspec:\n\t\t\tcontainers:\n\t\t\t\t- name: math-add\n\t\t\t\t  image: ubuntu\n\t\t\t\t  command: ['expr','3','+','2']\n\t\t\trestartPolicy: Never\n```\n\n查看结果,便在生产里,结果应该持久化的\n\n```yml\nkubectl logs <pod_name>\n```\n\n ",
                    "title": "k8s Jobs"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/k8s/k8s 安装.md",
                    "content": "#k8s  #docs/how-to-guides  \n### 单机方案  \n\n参看文档: [mac 使用 minikube](mac%20使用%20minikube.md)\n\n\n### 集群方案\n[Installing kubeadm | Kubernetes](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#before-you-begin)\n \n\n",
                    "title": "k8s 安装"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/k8s/k8s 怎么删除服务.md",
                    "content": "#k8s   #docs/how-to-guides \n\nKubernetes has some workloads (those contain PodTemplate in their manifest). These are:\n\n-   [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/)\n-   Controllers (basically Pod controllers)\n    -   [ReplicationController](https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/)\n    -   [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)\n    -   [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)\n    -   [StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)\n    -   [DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)\n    -   [Job](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)\n    -   [CronJob](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)\n\nSee, who controls whom:\n\n-   ReplicationController -> Pod(s)\n-   ReplicaSet -> Pod(s)\n-   Deployment -> ReplicaSet(s) -> Pod(s)\n-   StatefulSet -> Pod(s)\n-   DaemonSet -> Pod(s)\n-   Job -> Pod\n-   CronJob -> Job(s) -> Pod\n\n`a -> b` means `a` creates and controls `b` and the value of field `.metadata.ownerReference` in `b`'s manifest is the reference of `a`. For example\n\n``` yaml\n apiVersion: v1\n kind: Pod\n metadata:\n   ...\n   ownerReferences:\n   - apiVersion: apps/v1\n     controller: true\n     blockOwnerDeletion: true\n     kind: ReplicaSet\n     name: my-repset\n     uid: d9607e19-f88f-11e6-a518-42010a800195\n   ...\n ```\n\n\nThis way, deletion of the parent object will also delete the child object via [garbase collection](https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/).\nSo, `a`'s controller ensures that `a`'s current `status` matches with `a`'s `spec`. Say, if one deletes `b`, then `b` will be deleted. But `a` is still alive and `a`'s controller sees that there is a difference between `a`'s current `status` and `a`'s `spec`. So `a`'s controller recreates a new `b` obj to match with the `a`'s spec.\n\nThe ops created a Deployment that created ReplicaSet that further created Pod(s). So here the soln was to delete the root obj which was the Deployment.\n\n```bash\n$ kubectl get deploy -n {namespace}\n\n$ kubectl delete deploy {deployment name} -n {namespace}\n```\n\n\n\nAnother problem may arise during deletion is as follows: If there is any finalizer in the `.metadata.finalizers[]` section, then only after completing the task(s) performed by the associated controller, the deletion will be performed. If one wants to delete the object without performing the finalizer(s)' action(s), then he/she has to delete those finalizer(s) first. For example,\n\n```bash\nkubectl patch -n {namespace} deploy {deployment name} --patch '{\"metadata\":{\"finalizers\":[]}}'\nkubectl delete -n {namespace} deploy {deployment name}\n```",
                    "title": "k8s 怎么删除服务"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/linux/nginx.md",
                    "content": "#nginx #docs/how-to-guides \n\n \n## 配置文件\n\n### 大体结构\n```\n# nginx-教程\nevents {\n\t# ...\n}\nhttp {\n\t# ...\n\tserver {\n\t\n\t}\n  server {\n\n  }\n}\n\n```\n\n\n### 常用介绍\n```\n# 顶层配置信息管理服务器级别行为\nworker_processes  1;\n\n# event指令与事件模型有关，配置处理连接有关信息\nevents {\n    worker_connections  1024;\n}\n# nginx 里 root 与  alias 的区别\nhttp://stackoverflow.com/questions/10631933/nginx-static-file-serving-confusion-with-root-alias\n大概意思是alias在匹配后就会丢弃匹配。\n而root在匹配后将会将匹配附加在后面。\n# http指令处理http请求\nhttp {\n    # mime type映射\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    # server 表示一个虚拟主机，一台服务器可配置多个虚拟主机\n    server {\n        # 监听端口\n        listen       80;\n        # 识别的域名\n        server_name  localhost;\n\n        # 一个关键设置，与url参数乱码问题有关\n        charset utf-8;\n\n        #access_log  logs/host.access.log  main;\n\n        #location表达式：\n        #syntax: location [=|~|~*|^~|@] /uri/ { … }\n        #分为两种匹配模式，普通字符串匹配，正则匹配\n        #无开头引导字符或以=开头表示普通字符串匹配\n        #以~或~* 开头表示正则匹配，~*表示不区分大小写\n        #多个location时匹配规则\n        #总体是先普通后正则原则，只识别URI部分，例如请求为/test/1/abc.do?arg=xxx\n        #1. 先查找是否有=开头的精确匹配，即location = /test/1/abc.do {...}\n        #2. 再查找普通匹配，以 最大前缀 为规则，如有以下两个location\n        #   location /test/ {...}\n        #   location /test/1/ {...}\n        #   则匹配后一项\n        #3. 匹配到一个普通格式后，搜索并未结束，而是暂存当前结果，并继续再搜索正则模式\n        #4. 在所有正则模式location中找到第一个匹配项后，以此匹配项为最终结果\n        #   所以正则匹配项匹配规则受定义前后顺序影响，但普通匹配不会\n        #5. 如果未找到正则匹配项，则以3中缓存的结果为最终结果\n        #6. 如果一个匹配都没有，返回404\n        \n        #location =/ {...} 与 location / {...} 的差别\n        #前一个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它\n        #而后一个正相反，所有请求必然都是以/开头，所以没有其它匹配结果时一定会执行到它\n        \n        #location ^~ / {...} ^~意思是非正则，表示匹配到此模式后不再继续正则搜索\n        #所有如果这样配置，相当于关闭了正则匹配功能\n        #因为一个请求在普通匹配规则下没得到其它普通匹配结果时，最终匹配到这里\n        #而这个^~指令又相当于不允许正则，相当于匹配到此为止\n        location / {\n            root   html;\n            index  index.html index.htm;\n            # deny all; 拒绝请求，返回403\n            # allow all; 允许请求\n        }\n        \n        location /test/ {\n            deny all;\n        }\n        \n        location ~ /test/.+\\.jsp$ {\n           proxy_pass  http://192.168.1.62:8080;\n        }\n\n        location ~ \\.jsp$ {\n           proxy_pass  http://192.168.1.61:8080;\n        }\n\n        # 定义各类错误页\n        error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        \n        # @类似于变量定义\n        # error_page 403 http://www.jikexueyuan.com这种定义不允许，所以利用@实现\n        error_page 403 @page403;\n        location @page403 {\n            proxy_pass http://http://www.jikexueyuan.com;\n        }\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    \n    server {\n        listen       80;\n        #listen 9090\n        server_name  www.test.com test.com other.cc;\n\n        location / {\n            # root d:\\\\test; 注意，win下d:\\test因转义符问题不允许\n            root d:/test\n            index  index.html index.htm;\n        }\n    }\n}\n\n```\n\n### 配置优化\n\n```\n\n# nginx不同于apache服务器，当进行了大量优化设置后会魔术般的明显性能提升效果\n# nginx在安装完成后，大部分参数就已经是最优化了，我们需要管理的东西并不多\n\n#user  nobody;\n\n#阻塞和非阻塞网络模型：\n#同步阻塞模型，一请求一进（线）程，当进（线）程增加到一定程度后\n#更多CPU时间浪费到切换一，性能急剧下降，所以负载率不高\n#Nginx基于事件的非阻塞多路复用(epoll或kquene)模型\n#一个进程在短时间内可以响应大量的请求\n#建议值 <= cpu核心数量，一般高于cpu数量不会带好处，也许还有进程切换开销的负面影响\nworker_processes 4;\n\n#将work process绑定到特定cpu上，避免进程在cpu间切换的开销\nworker_cpu_affinity 0001 0010 0100 1000 \n#8内核4进程时的设置方法 worker_cpu_affinity 00000001 00000010 00000100 10000000\n \n# 每进程最大可打开文件描述符数量(linux上文件描述符比较广义，网络端口、设备、磁盘文件都是)\n# 文件描述符用完了，新的连接会被拒绝，产生502类错误\n# linux最大可打开文件数可通过ulimit -n FILECNT或 /etc/security/limits.conf配置\n# 理论值 系统最大数量 / 进程数。但进程间工作量并不是平均分配的，所以可以设置的大一些\nworker_rlimit_nofile 655350 \n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n#pid        logs/nginx.pid;\n\n\nevents {\n    # 并发响应能力的关键配置值\n    # 每个进程允许的最大同时连接数，work_connectins * worker_processes = maxConnection;\n    # 要注意maxConnections不等同于可响应的用户数量，\n    # 因为一般一个浏览器会同时开两条连接，如果反向代理，nginx到后端服务器的连接也要占用连接数\n    # 所以，做静态服务器时，一般 maxClient = work_connectins * worker_processes / 2\n    # 做反向代理服务器时 maxClient = work_connectins * worker_processes / 4\n    \n    # 这个值理论上越大越好，但最多可承受多少请求与配件和网络相关,也可最大可打开文件，最大可用sockets数量（约64K）有关\n    worker_connections  500;\n    \n    # 指明使用epoll 或 kquene (*BSD)\n    use epoll\n    \n    # 备注：要达到超高负载下最好的网络响应能力，还有必要优化与网络相关的linux内核参数\n}\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    # 关闭此项可减少IO开销，但也无法记录访问信息，不利用业务分析，一般运维情况不建议使用\n    access_log off\n    # 只记录更为严重的错误日志，可减少IO压力\n    error_log logs/error.log crit;\n    #access_log  logs/access.log  main;\n\n    # 启用内核复制模式，应该保持开启达到最快IO效率\n    sendfile        on;\n    \n    # 简单说，启动如下两项配置，会在数据包达到一定大小后再发送数据\n    # 这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性\n    # 比较适合于文件下载这类的大数据包通信场景\n    #tcp_nopush     on; 在 \n    #tcp_nodelay on|off on禁用Nagle算法 \n\n    #keepalive_timeout  0;\n    \n    # HTTP1.1支持持久连接alive\n    # 降低每个连接的alive时间可在一定程度上提高可响应连接数量，所以一般可适当降低此值\n    keepalive_timeout  30s;\n\n    # 启动内容压缩，有效降低网络流量\n    gzip on;    \n    # 过短的内容压缩效果不佳，压缩过程还会浪费系统资源\n    gzip_min_length 1000;\n    # 可选值1~9,压缩级别越高压缩率越高，但对系统性能要求越高\n    gzip_comp_level 4;\n    # 压缩的内容类别\n    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\n    # 静态文件缓存\n    # 最大缓存数量，文件未使用存活期\n    open_file_cache max=655350 inactive=20s;\n    # 验证缓存有效期时间间隔\n    open_file_cache_valid 30s;\n    # 有效期内文件最少使用次数\n    open_file_cache_min_uses 2;\n\n    server {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n}\n\n```\n\n \n\n## 添加模块\n\n```\n./configure --prefix=[:/output_dir]   --add_module=[:module_folder]\n```\n\n如果已经安装 nginx 不要用 make install 这样会覆盖配置文件，直接make，得到 **nginx**，停掉nginx（sbin/nginx -s stop），再覆盖nginx文件\n\n \n\n## 通过 docker 安装\n\n \n\n```yml\nversion: '3.1'\nservices:\n  nginx:\n    restart: always\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n      - 8080:8080\n    volumes:\n      - ./conf/nginx.conf:/etc/nginx/nginx.conf\n      - ./html:/usr/share/nginx/html\n```\n\n默认 volume 是不会在宿主机上创建文件的，只会创建目录。\n\nnginx.conf \n\n```ini\n# 启动进程，通常设置成 cpu 数量大小\nworker_processes 1;\n\nevents {\n\tuse epoll;\n\t# 单个 worker 最大并发\n\tworker_connections 1024;\n}\n\nhttp {\n\t# 设定 mime 类型，\n\tinclude  mime.types;\n\tdefault_type application/octet-stream;\n\t\n  # 是否使用 zero copy 方式输出文件\n\tsendfile on;\n\t\n\t# 连接超时\n\tkeepalive_timeout 65;\n\t\n\t# 请求缓冲\n\tclient_header_buffer_size 2k;\n\t\n\t\n\tupstream tomcat1 {\n\t# 如果使用的容器，则这里应该是容器的名字，如 server tomcat-server:8080\n\t\tserver 192.168.1.5:8080;\n\t}\n\tupstream tomcat2 {\n\t\tserver 192.168.1.6:8080;\n\t}\n\t# 多个可以级成负载\t\n\tupstream tomcat_load_balance {\n\t\tserver 192.168.1.6:8080 weight=10;\n\t\tserver 192.168.1.7:8080 weigth=10;\n\t\tserver 192.168.1.8:8080 weight=10;\n\t}\n\t\n\t# 一个 server 就是一个虚拟主机\n\tserver {\n\t\tlisten 80;\n\t\t# 可以是 ip，也可以是域名，可以在 host 里配置，那 虚拟主机可以 listen 同一个端口\n\t\tserver_name service.a.com;\n\t\t\n\t\tlocation / {\n\t\t\t\t# 访问 http://ip/index.html  将找 /usr/share/nginx/html/html80/index.html\n\t\t\t\t# 访问 http://ip/item/index.html  将找 /usr/share/nginx/html/html80/item/index.html\n\t\t\t\troot /usr/share/nginx/html/html80;\n\t\t\t\t\n\t\t\t\tindex index.html index.html;\n\t\t}\n\t}\n\t\n\tserver  {\n\t\t\tlisten 8080;\n\t\t\tserver_name 192.168.1.4;\n\t\tlocation / {\n\t\t\t\troot /usr/share/nginx/html/html8080;\n\t\t\t\tindex index.html index.html;\n\t\t}\n\t}\n\t\n\tserver  {\n\t\t\tlisten 8085;\n\t\tlocation / {\n\t\t\t\tproxy_pass http://tomcat1;\n\t\t\t\tindex index.html index.html;\n\t\t}\n\t}\n\t\n\t\tserver  {\n\t\t\tlisten 9085;\n\t\tlocation / {\n\t\t\t\tproxy_pass http://tomcat_load_balance;\n\t\t\t\tindex index.html index.html;\n\t\t}\n\t}\n\t\n}\n```\n\n",
                    "title": "nginx"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/linux/ubuntu 设置静态 ip.md",
                    "content": "#docs/how-to-guides  #linux \n\n### ubuntu 18 \n\nubuntu 18 **配置/etc/network/interfaces无用**\n\nvim /etc/netplan/*.yaml ，有可能叫 01-netcfg.yaml 或者 50-cloud-init.yaml\n\n```yaml\n# Linux 网络设置\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: true\n```\n\n\n\n修改为\n\n```yaml\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    eth0:\n     dhcp4: no\n     addresses: [192.168.1.222/24]\n     gateway4: 192.168.1.1\n     nameservers:\n       addresses: [8.8.8.8,8.8.4.4]\n```\n\n\n\n使生效\n\n```bash\nsudo netplan apply\n# 如果有问题，看一下原因\nsudo netplan --debug apply\n```\n\n\n\n### ubuntu 14～16\n\nvim /etc/network/interfaces\n\n```yaml\nauto eth0\niface eth0 inet static\n        address 192.168.1.22\n        netmask 255.255.255.0\n        gateway 192.168.1.1\n        dns-nameservers 8.8.8.8 8.8.4.4\n```\n\n\n\n重启或使用以下命令生效\n\n```\nsudo ip a flush enp0s3\nsudo systemctl restart networking.service\n```\n\n",
                    "title": "ubuntu 设置静态 ip"
                  },
                  {
                    "path": "5.轮子索引/4.系统.运维/mac/yabai.md",
                    "content": " #bash/tools/yabai  #docs/how-to-guides \n纯键盘操作的 macOS 平铺式窗口管理器 - yabai\n\n在 macOS 上，[已经有不少各具特色的窗口管理器](https://sspai.com/search/article?q=窗口管理)，例如 [Magnet](https://magnet.crowdcafe.com/), [Moom](https://manytricks.com/moom/) 等。不过，这些窗口管理器，都或多或少地依赖一些鼠标/触控板操作。\n\n对于 Linux, 存在着另一种窗口管理工具：[平铺式窗口管理器](https://en.wikipedia.org/wiki/Tiling_window_manager)。常见的 [awesome](https://awesomewm.org/) 和 [i3](https://i3wm.org/), 都有着各自忠实的用户。\n\n而前段时间出现的开源软件 [yabai](https://github.com/koekeishiya/yabai), 为 macOS 带来了平铺式窗口管理器。本文将对 yabai 的安装和使用做一个初步的介绍。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1-20220509103419954.png)使用 yabai 管理的 macOS 桌面\n\n# mac-tile 布局\n\n与平铺式窗口管理器相对的，是**浮动式窗口管理器**，也就是 Windows 和 macOS 下默认的窗口管理器。在浮动式窗口管理器下，窗口可以**自由移动**、**自由调整大小**，窗口之间可以**相互重叠**。\n\n而**平铺式窗口管理器**，能够将窗口平铺在桌面上，**窗口之间不能相互重叠**。\n\n平铺式窗口管理器大多具有如下特点：\n\n- 纯键盘操作\n\n切换活动窗口、最大化/全屏、调整窗口大小、调整布局方式、添加/删除/切换桌面、移动窗口到其他桌面、移动窗口到其他显示器…… 所有与窗口管理的操作，都可以通过键盘来实现。部分窗口管理器甚至不提供鼠标操作，只提供键盘操作。\n\n虽然通过纯键盘的方式管理窗口，会增加学习和记忆成本。但和 Vim、双拼输入法等软件类似，熟练掌握键盘后，能够大幅度提升窗口管理的效率和操作的爽快感。\n\n- 自动进行窗口布局\n\n在打开较多窗口、使用较大显示器的情况下，使用浮动式窗口管理器，需要花费精力不停切换窗口、调整窗口的大小和位置……\n\n而平铺式窗口管理器，默认就能按照一定的布局方式，将窗口平铺在桌面上，从而减少手动调整窗口带来的工作量。\n\n- 完善的多桌面、多显示器支持\n\n多数平铺式窗口管理器，对于多个桌面、多个显示器之间的窗口切换都有着完善的支持。如下图片来自 Awesome 官网，从中可以感受到在多显示器环境中使用平铺式窗口管理器的体验：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1-20220509103422186.png)使用 Awesome 进行多显示器窗口管理\n\n（图片来源：https://awesomewm.org/）\n\n- 高度的可定制能力\n\n包括 yabai 在内的平铺式窗口管理器，都能够通过配置文件进行丰富的设置，从而更加满足自己的使用习惯。\n\n# 安装 yabai\n\n**注意：为了使 yabai 正常工作，需要在运行 yabai 之前，[关闭 macOS 的系统完整性保护](https://developer.apple.com/library/archive/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html)（SIP）。请自行了解该操作可能带来的安全风险，如果不确定，建议首先在虚拟机中体验。**\n\n本节将介绍使用 Homebrew 安装 yabai, 导入 yabai GitHub 仓库中的示例配置，并安装 [skhd](https://github.com/koekeishiya/skhd) 做为 yabai 的快捷键工具的完整过程。更多安装方式，请参考 [yabai 的 README 文件](https://github.com/koekeishiya/yabai/blob/master/README.md)。\n\n首先安装 yabai（如果电脑中没有 Homebrew, 请先[安装 Homebrew](https://brew.sh/)）:\n\n```\nbrew tap koekeishiya/formulae\nbrew install yabai∑\n\n\n# 安装 script addition\nsudo yabai --install-sa\n# 手动启动一下\nsudo yabai --load-sa\n```\n\n然后安装 skhd, skhd 用于给 yabai 提供快捷键支持，也可以用其他快捷键工具代替：\n\n```\nbrew install koekeishiya/formulae/skhd\n```\n\n下载 skhd 和 yabai 的示例配置文件：\n\n```\ncurl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/yabairc --output ~/.yabairc\ncurl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/skhdrc --output ~/.skhdrc\n```\n\n启动 skhd 和 yabai 服务：\n\n```\nbrew services start skhd\nbrew services start yabai\n```\n\n第一次启动 skhd 和 yabai 之后，macOS 会提示是否允许两者访问辅助功能。在系统偏好设置中添加权限后，再重启一次 skhd 和 yabai, 即可正常工作：\n\n```\nbrew services start skhd\nbrew services start yabai\n```\n\n# 使用 yabai\n\n在完成上述步骤后，yabai 就已经启动，并在后台正常运行了。这时候会发现，所有的窗口都不听使唤了，无论怎么移动，怎么调整大小，窗口都会自动停靠在桌面的一角😂\n\n这时候先不要慌，这是平铺式窗口管理器工作的正常现象。可以先按 `Control + Option + D` 切换回传统的浮动模式，就可以继续自由移动窗口了。准备好下一步操作后，按一下 `Control + Option + A`, 即可切换为平铺模式。\n\n## 调整窗口分布\n\nyabai 默认使用 Binary Space Partitioning 的布局来排列窗口：只打开一个窗口时，窗口充满全屏；打开两个窗口时，两个窗口各占屏幕的 1/2, 打开三个窗口时，一个窗口占屏幕的 1/2, 另外两个窗口各占屏幕的四分之一……\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1-20220509103422367.png)Binary Space Partitioning 示意图\n\n也就是说，在打开多个窗口的时候，屏幕被分割成多个大小不同的区域。这时候可以通过快捷键来移动窗口，将不同窗口放置在不同大小的区域。\n\n- Shift + Option + h: 左移当前活动窗口\n- Shift + Option + j: 下移当前活动窗口\n- Shift + Option + k: 上移当前活动窗口\n- Shift + Option + l: 右移当前活动窗口\n\n熟悉 Vim 的话，应该不会 `h`, `j`, `k`, `l` 四个键控制方向感到陌生。\n\n另外，还可以使用 `Option + r` 键来旋转桌面的布局，使较大窗口和较小窗口都能分布在屏幕的合适位置。\n\n## 调整窗口大小\n\n虽然 yabai 将屏幕分割为不同大小的区域，但有些时候，我们还是需要对窗口大小做进一步的调整，或者最大化某个窗口：\n\n- Shift + Option + a: 增大当前活动窗口左侧\n- Shift + Option + s: 增大当前活动窗口下侧\n- Shift + Option + w: 增大当前活动窗口上侧\n- Shift + Option + d: 增大当前活动窗口右侧\n- Shift + Command + a: 缩小当前活动窗口左侧\n- Shift + Command + s: 缩小当前活动窗口下侧\n- Shift + Command + w: 缩小当前活动窗口上侧\n- Shift + Command + d: 缩小当前活动窗口右侧\n- Option + f: 最大化/恢复当前窗口\n- Shift + Option + 0: 恢复原始窗口大小\n\n## 切换活动窗口\n\n在使用 yabai 之后，虽然能够继续使用鼠标/触控板来切换活动窗口，但 yabai 提供了一系列快捷键，可以更高效地实现活动窗口的切换。\n\n- Option + h: 使左侧窗口成为活动窗口\n- Option + j: 使下方窗口成为活动窗口\n- Option + k: 使上方窗口成为活动窗口\n- Option + l: 使右侧窗口成为活动窗口\n\n## 使单个窗口成为浮动模式\n\n对于某些不需要成为平铺模式，受窗口管理器控制的窗口（例如微信的聊天窗口，大部分时候处于关闭或最小化状态，只有需要回复消息时才会短暂打开），yabai 也能够灵活地将其单独设置为浮动模式，从而使窗口可以自动缩放。\n\n- Option + t: 使当前活动窗口成为浮动模式\n- Option + p: 使当前活动窗口成为浮动模式，以类似「画中画」的形式显示在屏幕右上角\n\n## 多个桌面的管理\n\n在窗口较多，单个桌面无法容纳下的时候，可以创建新的桌面，并将窗口移动到新的桌面上。\n\n- Shift + Command + n: 创建新桌面\n- Command + Option + n: 创建新桌面，并将当前活动窗口移动至新桌面\n\n由于篇幅限制，更多快捷键组合，例如多显示器的支持等，在本文中不再详细介绍。具体请参考 [skhd 的默认配置文件](https://github.com/koekeishiya/yabai/blob/master/examples/skhdrc)，以及 [yabai 文档](https://github.com/koekeishiya/yabai/blob/master/doc/yabai.asciidoc)。\n\n# 定制 yabai\n\nyabai 和 skhd 都有着比较强的可定制能力，可以通过修改 `~/.yabairc` 和 `~/.skhdrc`, 对其进行个性化的设置。\n\n## 打开状态栏\n\nyabai 拥有一个简洁的状态栏，用于代替 macOS 的 Menubar, 显示当前桌面，以及时间和电量等信息。效果如下：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1-20220509103422574.png)yabai 状态栏\n\n状态栏默认不显示，可通过修改配置文件来打开。方法如下：\n\n首先[打开终端](https://sspai.com/post/45534)，输入 `nano ~/.yabairc`（或 `vi ~/.yabairc`），打开 yabai 的配置文件，找到文件中 `bar settings` 的地方：\n\n```\n# bar settings\nyabai -m config status_bar                   off\nyabai -m config status_bar_text_font         \"Helvetica Neue:Bold:12.0\"\nyabai -m config status_bar_icon_font         \"FontAwesome:Regular:12.0\"\nyabai -m config status_bar_background_color  0xff202020\nyabai -m config status_bar_foreground_color  0xffa8a8a8\nyabai -m config status_bar_space_icon_strip  I II III IV V VI VII VIII IX X\nyabai -m config status_bar_power_icon_strip   \nyabai -m config status_bar_space_icon        \nyabai -m config status_bar_clock_icon        \n```\n\n此处就是 yabai 状态栏的设置选项。将第一行的 `off` 修改为 `on`, 即可打开状态栏。\n\n在后面几行中，还可以对状态栏的字体、颜色、图标进行设置。在 `status_bar_space_icon_strip` 行，将 `I`, `II`, `III` 等修改为 emoji 或 FontAwesome 图标字体，就可以为对应序号的桌面，指定为对应的图标。（例如可以将前三个桌面分别设置为「写作」、「资讯」、「娱乐」图标，然后将同类 App 放在同一个桌面上）\n\n配置文件修改保存之后，[安装 FontAwesome 4 字体](https://fontawesome.com/v4.7.0/)，设置[自动隐藏 macOS Menubar](https://support.apple.com/zh-cn/guide/mac-help/mchlp1446/mac)，然后执行如下命令重启 yabai, 即可看到状态栏：\n\n```\nbrew services restart yabai\n```\n\n## 设置窗口之间的间隔\n\n在 yabai 的默认设置中，窗口之间的间隔较大。可以适当减小窗口之间的间隔，提高桌面空间利用率。\n\n修改方法：在 `~/.yabairc` 中找到如下配置，适当减小相关数值即可：\n\n```\n# general space settings\nyabai -m config layout                       bsp\nyabai -m config top_padding                  20\nyabai -m config bottom_padding               20\nyabai -m config left_padding                 20\nyabai -m config right_padding                20\nyabai -m config window_gap                   10\n```\n\n例如我将前四个值修改为 0, 最后一个值修改为 3 之后，效果如下图所示：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1-20220509103423071.png)yabai 缩小窗口之间的间隔后的效果\n\n## 自定义快捷键、快速打开终端\n\nyabai 的快捷键功能，是通过 skhd 来实现的。所以，修改 `~/.skhdrc`, 即可实现自定义快捷键。\n\n例如，在 Linux 中，部分窗口管理器将 `Alt/Win + 回车` 做为打开终端的快捷键。而对于需要经常使用终端的 macOS 用户，就可以使用 skhd 为终端指定一个快捷键。\n\n默认的 `.skhdrc` 中，第二行已经将 `Command + 回车` 做为打开 [kitty](https://sw.kovidgoyal.net/kitty/) 的快捷键：\n\n```\ncmd - return : /Applications/Kitty.app/Contents/MacOS/kitty --single-instance -d ~\n```\n\n而如果自己的常用终端不是 kitty, 而是 [iTerm2](https://www.iterm2.com/), 只需将这一行修改为如下内容，即可使用 `Command + 回车` 快速打开 iTerm2.\n\n```\ncmd - return : open /Applications/iTerm.app\n```\n\n## 通过脚本实现自动化操作\n\n在 `.skhdrc` 中可以发现，所有 yabai 相关的操作，都是通过 `yabai -m` 命令，向 yabai 发消息来实现的。所以，我们也可以在自己的脚本中，加入 `yabai -m` 相关命令，来实现自动化操作。\n\n如下脚本是一个简单的示例：\n\n```\n#!/bin/bash\n\n# 创建一个新桌面，并切换至新桌面\nyabai -m space --create\nid=$(yabai -m query --displays --display | grep \"spaces\")\nyabai -m space --focus $(echo ${id:${#id}-3:1})\n\n# 打开备忘录、提醒事项和文本编辑\nopen /Applications/Notes.app\nopen /Applications/Reminders.app\nopen /Applications/TextEdit.app\n```\n\n通过此脚本，即可创建一个新桌面，然后在新桌面上同时打开备忘录、提醒事项、文本编辑。当然也可以在 `.skhdrc` 中为这个脚本分配一个快捷键，只需一个按键，就可以执行上述一系列操作。\n\n# 延伸阅读\n\nyabai 还是一个比较新的软件，经过两天的试用，仍会偶尔遇到一些小 bug, 例如窗口无法自动调整大小等；另外，必须关闭 SIP 才能正常使用，也不方便大部分对 macOS 安全性有要求的人使用。希望后续的版本能够进一步完善，为我们带来更好的体验。\n\n在 Windows 上，也可以尝试 bug.n, 这是一款基于 [AutoHotKey](https://www.autohotkey.com/) 的窗口管理工具，与 yabai 有着类似的功能：\n\n- [koekeishiya/yabai: A tiling window manager for macOS based on binary space partitioning](https://github.com/koekeishiya/yabai)\n\n如果想了解关于平铺式窗口管理器的更多内容，可以参考如下链接：\n\n- [Why Use A Tiling Window Manager? Speed, Efficiency and Customization! - YouTube](https://www.youtube.com/watch?v=Lj1IfdKY0CU)\n- [ChunkWM tutorial on macOS! - YouTube](https://www.youtube.com/watch?v=ZUMucXKU4Fw)\n- [CHUNKWM + SKHD - Mac OS X Mojave deserves a Tiling Window Manager system too - YouTube](https://www.youtube.com/watch?v=k1YChPy8_L0)\n- [5 reasons the i3 window manager makes Linux better | Opensource.com](https://opensource.com/article/18/8/i3-tiling-window-manager)\n- [平铺式窗口管理器 Musca 初体验 · LinuxTOY](https://linuxtoy.org/archives/musca.html)\n- [平铺式窗口管理器-Awesome | HaHack](https://www.hahack.com/tools/awesome/)\n- [平铺式窗口管理器——Awesome · LinuxTOY](https://linuxtoy.org/archives/awesome.html)\n\n\n\n\n\n---\n\n在使用 cmd+tab 时, mac 会自动重排space, 可以禁止使用\n\nhttps://github.com/koekeishiya/yabai/wiki/Tips-and-tricks#fix-spaces-reordering-automatically ",
                    "title": "mac-tile 布局"
                  },
                  {
                    "path": "5.轮子索引/5.数据库.缓存.MQ.中间件/mysql/MySQL 修改 root 密码.md",
                    "content": "#mySQL  #docs/how-to-guides \n\n## 先修改安全策略\n\nmysql 5.7 默认密码使用 validate_password 密码加强插件\n\n登陆 mysql 客户端，执行以下两条命令\n\n```\nmysql> set global validate_password_length=1;\nmysql> set global validate_password_policy=0;\n```\n\n \n## 再修改密码\n\n```\nmysql> set password=password(\"root\");\n```\n \n\n## 再授权\n\n默认情况下 mysql 只允许 localhost 访问，需要对 ip 授权\n\n```\ngrant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;\n```\n\n",
                    "title": "MySQL 修改 root 密码"
                  },
                  {
                    "path": "5.轮子索引/5.数据库.缓存.MQ.中间件/mysql/MySQL 大批量数据插入.md",
                    "content": "#docs/how-to-guides  #mySQL \n\n``` sql\n-- 创建表\ncreate table dept(\n  dno int(5) primary key default 0,\n  dname varchar(20) not null default '',\n  loc varchar(30) default ''\n) engine=innodb default charset=utf8;\n\n\ncreate table emp(\n  eid int(5) primary key,\n  ename varchar(20) not null default '',\n  job varchar(20) not null default '',\n  deptno int(5) not null default 0\n)\n```\n见插入数据工程:\n``` bash\n/Users/zk/git/pythonPrj/mysql-make-fake-data\n```",
                    "title": "MySQL 大批量数据插入"
                  },
                  {
                    "path": "5.轮子索引/5.数据库.缓存.MQ.中间件/mysql/主从复制.md",
                    "content": "#mySQL #docs/how-to-guides \n ![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-02-11-03-36.png)\n\n## master 配置 \n在 /etc/my.cnf\n``` ini\n[mysqld]\n# id\nserver-id=1\n\n# bin log 日志位置\nlog-bin=\"/var/mysql/mysql-bin\"\n\n# 错误记录日志\nlog-error=\"/var/mysql/mysql-error\"\n\n# 忽略同步哪些数据库,(不同步mysql系统数据库)\nbinlog-ignore-db=mysql\n\n# (可选) 指定哪些数据库同步\nbinlog-do-db=test\n\n```\n\n在 master 上执行授权,告诉master 谁是 slave\n``` sql\n-- 授权 ip 为 192.168.1.*,用户名为root ,密码为 root 的 mysql实例为自己的小弟\n  GRANT REPLICATION slave, reload,super on *.* to 'root'@'192.168.1.%' identified by 'root';\n  \n  flush previleges;\n\n  -- 授权完后,查看 master 状态\n  show master status;\n```\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/2019-07-02-11-14-21.png)\n\n记录  file 与 position 字段. 在配置 slave 时要用到.\n\n## slave 配置\n在 /etc/my.cnf\n``` ini\n[mysqld]\n# id (id 不能与 master 一样)\nserver-id=2\n\n# bin log 日志位置,(相对路径也可以)\nlog-bin=\"mysql-bin\"\n\n# 错误记录日志\nlog-error=\"mysql-error\"\n\n# 要复制过来的数据库\nreplication-do-db=test\n```\n\n在 slave 上执行授权,告诉谁是 master\n``` sql\n-- 授权 ip 为 192.168.1.15,用户名为root ,密码为 root 的 mysql实例为自己的小弟\nchange master to \nmaster_host='192.168.1.15',\nmaster_user='root',\nmaster_password='root',\nmaster_port=3306,\nmaster_log_file='mysql-bin.000001',\nmaster_log_pos=575\n  \n-- 开启同步\nstart slave;\n\n-- 授权完后,查看 master 状态\nshow master status;\n-- 确认 Slave_IO_Running: yes\n-- 确认 Slave_SQL_Running:yes\n-- 如果不是 yes, 则查看 Last_IO_Error 或 Last_SQL_Error,解决问题.\n\n\n```\n在授权时,如果已经是 slave 了,需 stop slave 再重新进行授权.\n\n在start slave 时,可能还是会报 id 重复的问题.\n```sql\n-- 注意:这里的server_id 是下划线\nshow variables like '%server_id%';\n```\n临时解决方案\n``` sql\n set global server_id=2;\n stop slave;\n start slave;\n```\n\n## QA\n\n1. mysql 无法远程访问.\n需要授权远程访问.\n如果 a 访问 b. 则在 b 主机上,进入 mysql.\n``` sql\n-- 授权p\n grant all previleges on *.* to 'root'@'%' identified by 'root' with grant option;\n\n -- 刷新\n flush previleges;\n```",
                    "title": "主从复制"
                  },
                  {
                    "path": "5.轮子索引/5.数据库.缓存.MQ.中间件/mysql/恢复 msyql 数据库.md",
                    "content": "#docs/how-to-guides  #mySQL \n \n如果拥有 ibdata1 *.frm  *.ibd 则直接将这 3 个文件拷到新数据库，重启即可\n\n",
                    "title": "恢复 msyql 数据库"
                  },
                  {
                    "path": "5.轮子索引/5.数据库.缓存.MQ.中间件/mysql/慢查询.md",
                    "content": "#docs/how-to-guides  #mySQL  \n \n## 开启\n\n先查看一下状态\n``` sql\nshow variables like '%slow_query_log%';\n```\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/2019-06-30-12-47-34.png)\n\n临时开启：\n  ``` sql \n  --  p在退出 mysql 服务,重启后将失效\n   set global slow_query_log = 1;  \n  ```\n\n永久开启：\n在 my.cnf 文件里\n``` ini\n[mysqld]\nslow_query_log =1 \nslow_query_log_file=/var/lib/mysql/localhost-slow.log\n```\n\n## 导出日志\n使用工具: mysqldumpslow \n``` bash\nmysqldumpslow --help \ns: 排序方式\nr: 逆序\nl: 锁定时间\ng: 正则匹配模式\n```\n\n举例:\n1. 获取返回记录最多的 3 个 SQL\n   ``` bash\n    mysqldumpslow -s r -t 3 /var/lib/mysql/localhost-slow.log\n   ```\n2. 获取访问次数最多的 3 个 SQL\n      ``` bash\n    mysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log\n   ```\n3. 按照时间排序,前 10 条包含 left join 的查询语句 SQL\n   ``` bash\n    mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/localhost-slow.log\n   ```\n\n ",
                    "title": "慢查询"
                  },
                  {
                    "path": "5.轮子索引/F2L.md",
                    "content": " \n#cube #docs/tutorials \n\nRU R' U'\n起始一层做好\n\n\n5 种场景\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115123536467.PZupM.jpg)\n\n\n\n\n\n\n\n\n\n## 情况1\n\n准备数据:\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115124321547.gUPjI.jpg)\n\n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115124755182.5gere.jpg)\n\n\nR' U2 R\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115124908842.EQ2sz.jpg)\n\n\nU' L' U L\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115125035374.7WeNp.jpg)\n\n\n\n\n\n\n##  情况 2\n⚠️upload failed, check dev console\n⚠️upload failed, check dev console\n⚠️upload failed, check dev console\n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221115125320391.ZLlqJ.jpg)\nRUR'\n\n\nhttps://www.youtube.com/watch?v=Hx9ZbPdX8zM&ab_channel=ParadoxCubing\n",
                    "title": "F2L"
                  },
                  {
                    "path": "5.轮子索引/JVM/JMX.md",
                    "content": "#JMX  #docs/tutorials \n \n\nJMX 可以 以 [[jconsole]] 为客户端，调用内部接口。\n\n1. 定义接口\n\n    1. 一定要以 MXBean 结尾。\n    2. getXXX 会映射成 attributes 方法\n    3. 除 setXXX 方法会映射成 operations\n\n\n    ```java\n    package com.zk;\n\n    public interface iUserMXBean {\n    \t// 映射成 attribute\n    \tString getName();\n            // 映射成 operation\n    \tpublic void refreshName();\n            // 映射成带参数的 operation， 要注意，只能是 primitive type 做参数，可以是多个\n    \tpublic void makeName(String name);\n    }\n    ```\n\n开 jconsole。连接即可看到相关信息\n\n‍\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223123949966.YiuIO.jpg)\n​\n\n‍\n",
                    "title": "JMX"
                  },
                  {
                    "path": "5.轮子索引/JVM/ea 参数.md",
                    "content": "#JVM  #docs/whatis-why-explanation \n\n\n在单元测试的时候，会发现-ea的vm options参数，这个参数是干什么的? 为什么会自动添加\n\n-ea 的参数  \n-ea就是中的ea就是enable assertion的意思，即 “启用断言”。加了-ea参数后可以使用 assert <表达式> 的写法。当然，不加-ea并不是不能写 assert xxx ，实际上依然是可以这么写，并且也能通过编译，只是在运行的时候实际是不起作用的。\n\n自动添加-ea，是因为IDEA中的单元测试模板（Templates）添加了这个参数，所有新开的junit测试就会自动带上这个参数。\n\n例子加深理解  \n下面是例子，以加深理解，有单元测试代码：\n\n@Test  \nvoid test1() {  \n  System.out.println(\"test1\");  \n  boolean flag = true;  \n  assert flag == true;  \n}\n\n@Test  \nvoid test2() {  \n  System.out.println(\"test2\");  \n  boolean flag = true;  \n  assert flag == false;  \n}  \n   \n当不加-ea参数时，依然可以使用 assert xxxx 并能通过编译，但是test1 和 test2 在执行的时候都是绿色通过的，实际 test2 应该是不通过。\n\n当加上-ea参数后，test1 在执行是绿色通过的，test2 是黄色不通过的（为什么不是红色不通过，暂不清楚）\n\n补充  \n在spring中使用单元测试，默认每个单元测试的方法都会加上-ea，如图\n\n为什么每个单元测试的方法都会自动配上 -ea?\n\n这是因为模板里配置了，所以每个junit的方法都会继承，如图\n\n‍\n",
                    "title": "ea 参数"
                  },
                  {
                    "path": "5.轮子索引/JVM/在 OOM 时自动 dump.md",
                    "content": "#JVM #docs/how-to-guides \n\n``` bash\n# 出错时,dump \n-XX:+HeapDumpOnOutOfMemoryError\n\n# 指定目录,可选,默认生成在工程下\n-XX:+HeapDumpPath=\"/Users/zk/\"\n```\n\n测试代码\n\n```java\npackage com.zk;\n\nimport java.util.ArrayList;\n \npublic class App \n{\n    byte[] byteArray = new byte[1024*1024];\n    public static void main( String[] args )\n    {\n        ArrayList<App> apps = new ArrayList<>();\n        while (true) {\n            apps.add(new App());\n        }\n    }\n}\n\n```\n\n[[OOM]] 异常可以通过 Throwable 抓到, 但在生产里不要用. 任何时候都不应该抓 Error 异常.\n\nDumping heap to java_pid78907.hprof ...\n\n可以通过 [[jvisualvm]] 打开.",
                    "title": "在 OOM 时自动 dump"
                  },
                  {
                    "path": "5.轮子索引/Vue 的双端 diff 算法.md",
                    "content": " \n#vue  #docs/whatis-why-explanation \n\n\n![聊聊 Vue 的双端 diff 算法](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b056fb8974d842b2a99ba53936f8fc43~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\nVue 和 React 都是基于 vdom 的前端框架，组件渲染会返回 vdom，渲染器再把 vdom 通过增删改的 api 同步到 dom。\n\n当再次渲染时，会产生新的 vdom，渲染器会对比两棵 vdom 树，对有差异的部分通过增删改的 api 更新到 dom。\n\n这里对比两棵 vdom 树，找到有差异的部分的算法，就叫做 diff 算法。\n\ndiff 算法是渲染器中最复杂的部分，也是面试的热点问题。今天我们就通过 Vue 的 diff 算法来探究下 diff 算法吧。\n\n## diff 算法\n\n我们知道，两棵树做 diff，复杂度是 O(n^3) 的，因为每个节点都要去和另一棵树的全部节点对比一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有的节点都是这样，再乘以 n，所以是 O(n * n * n) 的复杂度。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f0312e46cfa4d978397c429ab4c191b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样的复杂度对于前端框架来说是不可接受的，这意味着 1000 个节点，渲染一次就要处理 1000 * 1000 * 1000，一共 10 亿次。\n\n所以前端框架的 diff 约定了两种处理原则：**只做同层的对比，type 变了就不再对比子节点。**\n\n因为 dom 节点做跨层级移动的情况还是比较少的，一般情况下都是同一层级的 dom 的增删改。\n\n这样只要遍历一遍，对比一下 type 就行了，是 O(n) 的复杂度，而且 type 变了就不再对比子节点，能省下一大片节点的遍历。另外，因为 vdom 中记录了关联的 dom 节点，执行 dom 的增删改也不需要遍历，是 O(1)的，整体的 diff 算法复杂度就是 O(n) 的复杂度。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dbd325446ee4d219d6e8876219718c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n1000 个节点渲染一次最多对比 1000 次，这样的复杂度就是可接受的范围了。\n\n但是这样的算法虽然复杂度低了，却还是存在问题的。\n\n比如一组节点，假设有 5 个，类型是 ABCDE，下次渲染出来的是 EABCD，这时候逐一对比，发现 type 不一样，就会重新渲染这 5 个节点。\n\n而且根据 type 不同就不再对比子节点的原则，如果这些节点有子节点，也会重新渲染。\n\ndom 操作是比较慢的，这样虽然 diff 的算法复杂度是低了，重新渲染的性能也不高。\n\n所以，**diff 算法除了考虑本身的时间复杂度之外，还要考虑一个因素：dom 操作的次数。**\n\n上面那个例子的 ABCDE 变为 EABCD，很明显只需要移动一下 E 就行了，根本不用创建新元素。\n\n但是怎么对比出是同个节点发生了移动呢？\n\n判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的。\n\n最好每个节点都是有唯一的标识。\n\n所以当渲染一组节点的时候，前端框架会让开发者指定 key，通过 key 来判断是不是有点节点只是发生了移动，从而直接复用。\n\n这样，diff 算法处理一组节点的对比的时候，就要根据 key 来再做一次算法的优化。\n\n我们会把基于 key 的两组节点的 diff 算法叫做**多节点 diff 算法**，它是整个 vdom 的 diff 算法的一部分。\n\n接下来我们来学习一下多节点 diff 算法：\n\n## 简单 diff\n\n假设渲染 ABCD 一组节点，再次渲染是 DCAB，这时候怎么处理呢？\n\n**多节点 diff 算法的目的是为了尽量复用节点，通过移动节点代替创建。**\n\n所以新 vnode 数组的每个节点我们都要找下在旧 vnode 数组中有没有对应 key 的，有的话就移动到新的位置，没有的话再创建新的。\n\n也就是这样的：\n\n```javascript\nconst oldChildren = n1.children\nconst newChildren = n2.children\n\nlet lastIndex = 0\n// 遍历新的 children\nfor (let i = 0; i < newChildren.length; i++) {\n    const newVNode = newChildren[i]\n    let j = 0\n    let find = false\n    // 遍历旧的 children\n    for (j; j < oldChildren.length; j++) {\n      const oldVNode = oldChildren[j]\n      // 如果找到了具有相同 key 值的两个节点，则调用 patch 函数更新\n      if (newVNode.key === oldVNode.key) {\n        find = true\n        patch(oldVNode, newVNode, container)\n        \n        处理移动...\n        \n        break //跳出循环，处理下一个节点\n      }\n   }\n   // 没有找到就是新增了\n   if (!find) {\n      const prevVNode = newChildren[i - 1]\n      let anchor = null\n      if (prevVNode) {\n        anchor = prevVNode.el.nextSibling\n      } else {\n        anchor = container.firstChild\n      }\n      patch(null, newVNode, container, anchor)\n   }\n}\n复制代码\n```\n\n这里的 patch 函数的作用是更新节点的属性，重新设置事件监听器。如果没有对应的旧节点的话，就是插入节点，需要传入一个它之后的节点作为锚点 anchor。\n\n我们遍历处理新的 vnode：\n\n先从旧的 vnode 数组中查找对应的节点，如果找到了就代表可以复用，接下来只要移动就好了。\n\n如果没找到，那就执行插入，锚点是上一个节点的 nextSibling。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5389c6be37443318d71a9c09aefde7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那如果找到了可复用的节点之后，那移动到哪里呢？\n\n其实**新的 vnode 数组中记录的顺序就是目标的顺序。所以把对应的节点按照新 vnode 数组的顺序来移动就好了。**\n\n```javascript\nconst prevVNode = newChildren[i - 1]\nif (prevVNode) {\n    const anchor = prevVNode.el.nextSibling\n    insert(newVNode.el, container, anchor)\n}\n复制代码\n```\n\n要插入到 i 的位置，那就要取 i-1 位置的节点的 nextSibling 做为锚点来插入当前节点。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ac87eae8484d7c860bfacaaa8e0513~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但是并不是所有的节点都需要移动，比如处理到第二个新的 vnode，发现它在旧的 vnode 数组中的下标为 4，说明本来就是在后面了，那就不需要移动了。反之，如果是 vnode 查找到的对应的旧的 vnode 在当前 index 之前才需要移动。\n\n也就是这样：\n\n```javascript\nlet j = 0\nlet find = false\n// 遍历旧的 children\nfor (j; j < oldChildren.length; j++) {\n    const oldVNode = oldChildren[j]\n    // 如果找到了具有相同 key 值的两个节点，则调用 patch 函数更新之\n    if (newVNode.key === oldVNode.key) {\n        find = true\n        patch(oldVNode, newVNode, container)\n\n        if (j < lastIndex) { // 旧的 vnode 数组的下标在上一个 index 之前，需要移动\n          const prevVNode = newChildren[i - 1]\n          if (prevVNode) {\n            const anchor = prevVNode.el.nextSibling\n            insert(newVNode.el, container, anchor)\n          }\n        } else {// 不需要移动\n          // 更新 lastIndex\n          lastIndex = j\n        }\n        break\n    }\n}\n复制代码\n```\n\n查找新的 vnode 在旧的 vnode 数组中的下标，如果找到了的话，说明对应的 dom 就是可以复用的，先 patch 一下，然后移动。\n\n移动的话判断下下标是否在 lastIndex 之后，如果本来就在后面，那就不用移动，更新下 lastIndex 就行。\n\n如果下标在 lastIndex 之前，说明需要移动，移动到的位置前面分析过了，就是就是新 vnode 数组 i-1 的后面。\n\n这样，我们就完成了 dom 节点的复用和移动。\n\n新的 vnode 数组全部处理完后，旧的 vnode 数组可能还剩下一些不再需要的，那就删除它们：\n\n```javascript\n// 遍历旧的节点\nfor (let i = 0; i < oldChildren.length; i++) {\n    const oldVNode = oldChildren[i]\n    // 拿着旧 VNode 去新 children 中寻找相同的节点\n    const has = newChildren.find(\n      vnode => vnode.key === oldVNode.key\n    )\n    if (!has) {\n      // 如果没有找到相同的节点，则移除\n      unmount(oldVNode)\n    }\n}\n复制代码\n```\n\n这样，我们就完成了两组 vnode 的 diff 和对应 dom 的增删改。\n\n小结一下：\n\n**diff 算法的目的是根据 key 复用 dom 节点，通过移动节点而不是创建新节点来减少 dom 操作。**\n\n**对于每个新的 vnode，在旧的 vnode 中根据 key 查找一下，如果没查找到，那就新增 dom 节点，如果查找到了，那就可以复用。**\n\n**复用的话要不要移动要判断下下标，如果下标在 lastIndex 之后，就不需要移动，因为本来就在后面，反之就需要移动。**\n\n**最后，把旧的 vnode 中在新 vnode 中没有的节点从 dom 树中删除。**\n\n这就是一个完整的 diff 算法的实现。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5c723a59684ad7a846d3ae46539776~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个 diff 算法我们是从一端逐个处理的，叫做简单 diff 算法。\n\n简单 diff 算法其实性能不是最好的，比如旧的 vnode 数组是 ABCD，新的 vnode 数组是 DABC，按照简单 diff 算法，A、B、C 都需要移动。\n\n那怎么优化这个算法呢？\n\n从一个方向顺序处理会有这个问题，那从两个方向同时对比呢？\n\n这就是双端 diff 算法：\n\n## 双端 diff\n\n简单 diff 算法能够实现 dom 节点的复用，但有的时候会做一些没必要的移动。双端 diff 算法解决了这个问题，它是从两端进行对比。\n\n我们需要 4 个指针，分别指向新旧两个 vnode 数组的头尾：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958ae402338c4cf0a4aa6ff5a5484754~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n头和尾的指针向中间移动，直到 oldStartIdx <= oldEndIdx 并且 newStartIdx <= newEndIdx，说明就处理完了全部的节点。\n\n每次对比下两个头指针指向的节点、两个尾指针指向的节点，头和尾指向的节点，是不是 key是一样的，也就是可复用的。\n\n如果是可复用的话就直接用，调用 patch 更新一下，如果是头尾这种，还要移动下位置。\n\n也就是这样的：\n\n```javascript\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n  if (oldStartVNode.key === newStartVNode.key) { // 头头\n    patch(oldStartVNode, newStartVNode, container)\n    oldStartVNode = oldChildren[++oldStartIdx]\n    newStartVNode = newChildren[++newStartIdx]\n  } else if (oldEndVNode.key === newEndVNode.key) {//尾尾\n    patch(oldEndVNode, newEndVNode, container)\n    oldEndVNode = oldChildren[--oldEndIdx]\n    newEndVNode = newChildren[--newEndIdx]\n  } else if (oldStartVNode.key === newEndVNode.key) {//头尾，需要移动\n    patch(oldStartVNode, newEndVNode, container)\n    insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)\n\n    oldStartVNode = oldChildren[++oldStartIdx]\n    newEndVNode = newChildren[--newEndIdx]\n  } else if (oldEndVNode.key === newStartVNode.key) {//尾头，需要移动\n    patch(oldEndVNode, newStartVNode, container)\n    insert(oldEndVNode.el, container, oldStartVNode.el)\n\n    oldEndVNode = oldChildren[--oldEndIdx]\n    newStartVNode = newChildren[++newStartIdx]\n  } else {\n    \n    // 头尾没有找到可复用的节点\n  }\n}\n复制代码\n```\n\n头头和尾尾的对比比较简单，头尾和尾头的对比还要移动下节点。\n\n比如旧 vnode 的头节点是新的 vnode 的尾节点，那就要把它移动到旧的 vnode 的尾节点的位置。\n\n也就是：\n\n```javascript\ninsert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)\n复制代码\n```\n\n插入节点的锚点节点是 oldEndVNode 对应的 dom 节点的 nextSibling。\n\n如果旧 vnode 的尾节点是新 vnode 的头结点，那就要把它移动到旧 vnode 的头结点的位置。\n\n也就是：\n\n```javascript\ninsert(oldEndVNode.el, container, oldStartVNode.el)\n复制代码\n```\n\n插入节点的锚点节点是 oldStartVNode 对应的 dom 节点（因为要插在它之前）。\n\n从双端进行对比，能尽可能的减少节点移动的次数。\n\n当然，还要处理下如果双端都没有可复用节点的情况：\n\n如果双端都没有可复用节点，那就在旧节点数组中找，找到了就把它移动过来，并且原位置置为 undefined。没找到的话就插入一个新的节点。\n\n也就是这样：\n\n```javascript\nconst idxInOld = oldChildren.findIndex(\n  node => node.key === newStartVNode.key\n)\nif (idxInOld > 0) {\n  const vnodeToMove = oldChildren[idxInOld]\n  patch(vnodeToMove, newStartVNode, container)\n  insert(vnodeToMove.el, container, oldStartVNode.el)\n  oldChildren[idxInOld] = undefined\n} else {\n  patch(null, newStartVNode, container, oldStartVNode.el)\n}\n复制代码\n```\n\n因为有了一些 undefined 的节点，所以要加上空节点的处理逻辑：\n\n```javascript\nif (!oldStartVNode) {\n    oldStartVNode = oldChildren[++oldStartIdx]\n} else if (!oldEndVNode) {\n    oldEndVNode = newChildren[--oldEndIdx]\n}\n复制代码\n```\n\n这样就完成了节点的复用和移动的逻辑。\n\n那确实没有可复用的节点的那些节点呢？\n\n经过前面的移动之后，剩下的节点都被移动到了中间，如果新 vnode 有剩余，那就批量的新增，如果旧 vnode 有剩余那就批量的删除。\n\n因为前面一个循环的判断条件是 oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx，这样如果 old vnode 多了，最后 newStartIdx 会小于 newEndIdx。如果 new vnode 多了，最后 oldStartIdx 会小于 oldEndIdx。\n\n所以判断条件是这样的：\n\n```javascript\nif (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {\n  // 添加新节点\n  for (let i = newStartIdx; i <= newEndIdx; i++) {\n    patch(null, newChildren[i], container, oldStartVNode.el)\n  }\n} else if (newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx) {\n  // 移除操作\n  for (let i = oldStartIdx; i <= oldEndIdx; i++) {\n    unmount(oldChildren[i])\n  }\n}\n复制代码\n```\n\n这样就是一个完整的 diff 算法了，包括查找可复用节点和移动节点、新增和删除节点。\n\n而且因为从两侧查找节点，会比简单 diff 算法性能更好一些。\n\n比如 ABCD 到 DABC，简单 diff 算法需要移动 ABC 三个节点，而双端 diff 算法只需要移动 D 一个节点。\n\n小结一下：\n\n**双端 diff 是头尾指针向中间移动的同时，对比头头、尾尾、头尾、尾头是否可以复用，如果可以的话就移动对应的 dom 节点。**\n\n**如果头尾没找到可复用节点就遍历 vnode 数组来查找，然后移动对应下标的节点到头部。**\n\n**最后还剩下旧的 vnode 就批量删除，剩下新的 vnode 就批量新增。**\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de98767a75d04c0598e16738edc204de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n双端 diff 算法是 Vue2 采用的 diff 算法，性能还不错。\n\n后来，Vue3 又对 diff 算法进行了一次升级，叫做快速 diff 算法。这个后面再讲。\n\n## 总结\n\nReact 和 Vue 都是基于 vdom 的前端框架，组件产生 vdom，渲染器再把 vdom 通过增删改的 dom api 更新到 dom。\n\n当再次渲染出 vdom 时，就要新旧两棵 vdom 树做 diff，只更新变化的 dom 节点。\n\n两棵树的 diff 是 O(n^3) 的，时间复杂度太高，因此前端框架规定了只做同层 diff，还有 type 不一样就认为节点不一样，不再对比子节点。这样时间复杂度一下子就降到了 O(n)。\n\n但是对于多个子字节点的 diff 不能粗暴的删除和新增，要尽量复用已有的节点，也就是通过移动代替新增。\n\n所以多节点的时候，要指定 key，然后 diff 算法根据 key 来查找和复用节点。\n\n简单 diff 算法是依次根据 key 查找旧节点的，移动的话通过 lastIndex 判断，大于它就不用动，小于它才需要移动。剩下的节点再批量删除和新增。\n\n但是简单 diff 算法局限性还是比较大的，有些情况下性能并不好，所以 vue2 用的是双端 diff 算法。\n\n双端 diff 算法是头尾指针向中间移动，分别判断头尾节点是否可以复用，如果没有找到可复用的节点再去遍历查找对应节点的下标，然后移动。全部处理完之后也要对剩下的节点进行批量的新增和删除。\n\n其实 diff 算法最重要的就是找到可复用的节点，然后移动到正确的位置。只不过不同的算法查找顺序不一样。\n\nvue2 是用的双端 diff 的算法，而 vue3 则通过最长递增子序列的算法做了进一步的优化，关于优化后的 diff 算法，我们之后再聊。\n",
                    "title": "Vue 的双端 diff 算法"
                  },
                  {
                    "path": "5.轮子索引/Webpack sourcemap 配置.md",
                    "content": "\n#webpack #js #docs/how-to-guides \n \n\n![彻底搞懂 Webpack 的 sourcemap 配置原理](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d6eaa9ca9d447e48d03e559329ad9d3~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n用过 webpack 的都知道，webpack 的 sourcemap 配置是比较麻烦的，比如这两个配置的区别：\n\n-   eval-nosources-cheap-module-source-map\n-   hidden-module-source-map\n\n是不是分不清楚？\n\n其实它是有规律的。\n\n你把配置写错的时候，webpack 会提示你一个正则：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/555a210e48dc483ab153df2e33e166da~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n`^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$`\n\n这个就是配置的规律，是几种基础配置的组合。\n\n搞懂了每一种基础配置，比如 eval、nosources、cheap、module，按照规律组合起来，也就搞懂了整体的配置。\n\n那这每一种配置都是什么意思呢？\n\n我们分别来看一下。\n\n在讲基础配置之前，首先讲下 sourcemap 是什么：\n\n## sourcemap\n\n**sourcemap 是关联编译后的代码和源码的，通过一个个行列号的映射。**\n\n比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个 mapping。\n\nsourcemap 的格式如下：\n\n```javascript\n{\n　　　　version : 3,\n　　　　file: \"out.js\",\n　　　　sourceRoot : \"\",\n　　　　sources: [\"foo.js\", \"bar.js\"],\n　　　　names: [\"a\", \"b\"],\n　　　　mappings: \"AAgBC,SAAQ,CAAEA;AAAEA\",\n      sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']\n}\n```\n\nfile 是文件名，sourceRoot 是源码根目录，names 是转换前的变量名，sources 是源码文件，sourcesContent 是每个 sources 对应的源码的内容，mappings 就是一个个位置映射了。\n\n为什么 sources 可以有多个呢？\n\n因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。\n\n为什么要把变量名单独摘出来到 names 里呢？\n\n因为这样就可以通过下标来索引了，mapping 里面就不用保存变量名，只保留 names 的索引就行。\n\n重点是 mappings 部分：\n\nmappings 部分是通过分号`;` 和逗号 `,` 分隔的：\n\n```vbnet\nmappings:\"AAAAA,BBBBB;CCCCC\"\n复制代码\n```\n\n一个分号就代表一行，这样就免去了行的映射。\n\n然后每一行可能有多个位置的映射，用 `,` 分隔。\n\n那具体的每一个 mapping 都是啥呢？\n\n比如 AAAAA 一共五位，分别有不同的含义：\n\n-   转换后代码的第几列（行数通过分号 ; 来确定）\n-   转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引\n-   转换前的源码的第几行\n-   转换前的源码的第几列\n-   转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引\n\n然后经过编码之后，就成了 AAAAA 这种，这种编码方式叫做 VLQ 编码。\n\nsourcemap 的格式还是很容易理解的，就是一一映射编译后代码的位置和源码的位置。\n\n各种调试工具一般都支持 sourcemap 的解析，只要在文件末尾加上这样一行：\n\n```javascript\n//@ sourceMappingURL=/path/to/source.js.map\n复制代码\n```\n\n运行时就会关联到源码：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c2ccc72c774d0c8b8cf7e65ce2ed03~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nsourcemap 介绍完了，接下来一起来看下 webpack 的几种 sourcemap 配置。\n\n前面说过，webpack 的 sourcemap 配置是 eval、cheap、nosources、inline、source-map 等基础配置的组合。\n\n我们先分别来看下这几种基础配置：\n\n## eval\n\neval 的 api 是动态执行 JS 代码的。比如：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfb062059b1741e499aca44408da3019~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但有个问题，eval 的代码打不了断点。\n\n怎么解决这个问题呢？\n\n浏览器支持了这样一种特性，只要在 eval 代码的最后加上 //# sourceURL=xxx，那就会以 xxx 为名字把这段代码加到 sources 里。那不就可以打断点了么？\n\n比如这样：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9534f582a155414db5121065298ebde6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n执行以后，你会发现 sources 多了`光.js`的文件：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/719333197c224b3fba0db4c98f44a3af~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n它是可以打断点的，比如在 add 里打个断点，然后再执行 eval。\n\n你会发现它断住了！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/415163517c8e421598a195d5effe565b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n除了指定 source 文件外，还可以进一步指定 sourcemap 来映射到源码：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2289e65624b48fdaedafeaf56bfc0ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样，动态 eval 的代码也能关联到源码，并且能打断点了！\n\nwebpack 就利用了 eval 这个特性来优化的 sourcemap 生成的性能，比如你可以指定 devtool 为 eval：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26e7cfbd507044ac9403acb39fbc0f45~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n生成的代码就是每个模块都被 eval 包裹的，并且有 sourceUrl 来指定文件名：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e7f3f2de76496a92955e48f76a1e29~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样有啥好处呢？\n\n快呀，因为只要指定个文件名就行，不用生成 sourcemap。sourcemap 的生成还是很慢的，要一个个 mapping 的处理，做编码之类的。\n\n每个模块的代码都被 eval 包裹，那么执行的时候就会在 sources 里生成对应的文件，这样就可以打断点了：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bade1e87023423bad0f8516b2f926dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n不过这样只是把每个模块的代码分了出去，并没有做源码的关联，如果相关联源码，可以再开启 sourcemap：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b21957ef0ef4bd68259df27b31e7992~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会发现生成的代码也是用 eval 包裹的，但除了 sourceUrl 外，还有 sourceMappingUrl：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bfbd8e348a94a4398f3a190c95ccae5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n再运行的时候除了 eval 的代码会生成文件放在 sources 外，还会做 sourcemap 的映射：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90bcbd9707b24b0b89f9a6ddae502202~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nwebpack 的 sourcemap 的配置就利用了浏览器对 eval 代码的调试支持。\n\n所以为什么这个配置项不叫 sourcemap 而叫 devtool 呢？\n\n因为不只是 sourcemap 呀，eval 的方式也行。\n\n再来看下一个基础配置：\n\n## source-map\n\nsource-map 的配置是生成独立的 sourcemap 文件：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0818a2d08d5412d8b4d006e36ba2b55~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/969d8694aa104f0f98807a1e5ad238b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c25d125ecce41b4a9335fae5c31b77e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n可以关联，也可以不关联，比如加上 hidden，就是生成 sourcemap 但是不关联：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac79cd4bd1a24d3cb70a9d4636528362~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8276d39ffab449398c299621f3c8aa22~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n生产环境就不需要关联 sourcemap，但是可能要生成 sourcemap 文件，把它上传到错误管理平台之类的，用来映射线上代码报错位置到对应的源码。\n\n此外，还可以配置成 inline 的：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8cac66934140abb3b6773420a1004f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个就是通过 dataUrl 的方式内联在打包后的文件里：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03686b8c584045f2b26de6ea9ae8728c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这几个配置还是很好懂的，我们来看下一个基础配置：\n\n## cheap\n\nsourcemap 慢主要是处理映射比较慢，很多情况下我们不需要映射到源码的行和列，只要精确到行就行，这时候就可以用 cheap。\n\n不精确到列能提升 souremap 生成速度，但是会牺牲一些精准度：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11a26ae3ad444cfc80df5b65b9c60f91~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n我们再来看下一个基础配置：\n\n## module\n\nwebpack 中对一个模块会进行多次处理，比如经过 loader A 做一次转换，再用 laoder B 做一次转换，之后打包到一起。\n\n每次转换都会生成 sourcemap，那也就是有多个 sourcemap：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92b061529304c71a2e169da4f6ac93d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n默认 sourcemap 只是能从 bundle 关联到模块的代码，也就是只关联了最后那个 sourcemap。\n\n那如果你想调试最初的源码怎么办呢？\n\n那就把每一次的 loader 的 sourcemap 也关联起来，这就是 module 配置的作用。\n\n比如我们想调试 React 最初的源码，那就要先生成有 sourcemap 的代码：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ace62d22756a46db8d0a694efe6e9659~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n怎么生成有 sourcemap 的 React 代码可以看我[前面一篇文章](https://juejin.cn/post/7126501202866470949 \"https://juejin.cn/post/7126501202866470949\")。\n\n有了 sourcemap 之后，要配置下 sourcemap-loader：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b706d893224048a4bc05adaeaafa516c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n它的作用就是读取源码的 sourcemap，传递给后面的 loader。\n\n之后配置 devtool，加上 module：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f55eec43a0142b1847b858c8421123f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n再次运行，你就会发现 react 代码能映射到最初的源码了：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3974f1ba80754224a73a0ba86afff9bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n之前只能从 bundle.js 映射到编译后的模块代码，也就是这一步：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abe931167b143f7b0ff0608e0d29dc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\ndevtool 配置加上 module，就支持了 loader 的 sourcemap 映射，然后再加上 sourmap-loader 来读取源码的 sourcemap，这样就能一次性映射回最初的源码：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ae34f8d2a2e4684aaea97f93c1865d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n当你想调试最初的源码的时候，module 的配置就很有用了。\n\n接下来还有最后一个基础配置：\n\n## nosources\n\nsourcemap 里是有 sourceContent 部分的，也就是直接把源码贴在这里，这样的好处是根据文件路径查不到文件也可以映射，但这样会增加 sourcemap 的体积。\n\n如果你确定根据文件路径能查找到源文件，那不生成 sourceContent 也行。\n\n比如 devtool 配置为 source-map，生成的 sourcemap 是这样的：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60fd5402a0734779b0fae682dbee1e25~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n当你加上 nosources 之后，生成的 sourcemap 就没有 sourceContent 部分了：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b54fdd4d533d4db19d29e0d2ac6d7640~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nsourcemap 文件大小会小很多。\n\n基础配置讲完了，接下来就是各种组合了，这个就比较简单了，就算组合错了，webpack 也会提示你应该按照什么顺序来组合。\n\n它是按照这个正则来校验的：^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$\n\n接下来，我们讨论下最佳实践：\n\n线上的时候当然要启用 hidden，不关联 sourcemap，但要生成 sourcemap，不大需要 module 来映射回最初的源码，所以可能是 hidden-source-map 这种。\n\n开发的时候可以用 eval 的方式，这样是每个模块单独做映射，不用从 bundle.js 开始映射，然后 cheap 也可以开启，只映射到源码的某一行，提升生成速度，一般需要 module 来映射回最初的源码，所以可能是 eval-cheap-module-source-map 这种。\n\n当然，具体怎么配置是按照需求来的，我们理解了每个基础配置，知道怎么组合就可以了。\n\n不知道有没有同学会觉得这样写比较麻烦，能不能每个基础配置用 true、false 的方式配置呢？\n\n确实可以，有这样一个插件： SourceMapDevToolPlugin\n\n它有很多 option，比如 module、columns、noSources 等：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea11c70fe37498696496cec52711d56~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n相当于是 devtool 的另一种配置方式，启用它需要把 devtool 设置为 false。\n\n而且它可以控制更多东西，比如修改 sourcemap 的 url 和文件名等：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59b46b602b684b9e950cb253398d2b69~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n当你需要做更多的 sourcemap 生成方式的控制的时候，可以使用这个 webpack 插件。\n\n## 总结\n\nwebpack 的 sourcemap 配置比较麻烦，但其实也是有规律的。\n\n它是对一些基础配置按照一定顺序的组合，理解了每个基础配置，知道了怎么组合就理解了各种 devtool 配置。\n\n-   eval：浏览器 devtool 支持通过 sourceUrl 来把 eval 的内容单独生成文件，还可以进一步通过 sourceMappingUrl 来映射回源码，webpack 利用这个特性来简化了 sourcemap 的处理，可以直接从模块开始映射，不用从 bundle 级别。\n    \n-   cheap：只映射到源代码的某一行，不精确到列，可以提升 sourcemap 生成速度\n    \n-   source-map：生成 sourcemap 文件，可以配置 inline，会以 dataURL 的方式内联，可以配置 hidden，只生成 sourcemap，不和生成的文件关联\n    \n-   nosources：不生成 sourceContent 内容，可以减小 sourcemap 文件的大小\n    \n-   module： sourcemap 生成时会关联每一步 loader 生成的 sourcemap，配合 sourcemap-loader 可以映射回最初的源码\n    \n\n理解了这些基础配置项，根据 ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$ 的规律来进行组合，就可以实现各种需求下的 sourcemap 配置。\n\n当然，这种 sourcemap 配置还不够细致，比如 sourcemap 的 url 怎么生成，文件名是什么。如果想对这些做配置，可以关掉 devtool，启用 SourceMapDevToolPlugin 来配置。\n\n虽然 webapck 的 sourcemap 配置方式比较多，但最底层也就是浏览器支持的文件级别的 sourcemap 还有 eval 代码的 source 映射和 sourcemap 这两种机制。其余的方式都是基于这两种机制的封装。\n\n理解了浏览器 devtool的机制，webpack 封装出的基础配置，知道了组合规则，就可以应对各种需求的 sourcemap 配置。\n",
                    "title": "Webpack sourcemap 配置"
                  },
                  {
                    "path": "5.轮子索引/hot to create osx app in xcode.md",
                    "content": "#osx/app  #docs/how-to-guides \n\n\n\n\n## 创建工程\n\n现在都 2022 年了。但是，还是按最老式的来。用 xib。\n\n![image-20220212175248518](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212175248518.png)\n\n\n\n# osx_oc_demo2\n\n## 使用 xib 建 UI \n\n先手动建一个 MyViewController \n\n> 注意： 这个不需要继承自 VIewController， 只需要继承自 Object 即可\n\n``` objc\n@interface MyViewController : NSObject\n@end\n```\n\n在 UI 编辑器 里创建一个 object 来当做 MyViewController 的代理\n\n![image-20220212191801994](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212191801994.png)\n\n上面这个东西哪来的？点下面红圈圈\n\n![image-20220212195857691](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212195857691.png)\n\n\n\n关联一下 MyViewController 与 object\n\n![image-20220212191832027](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212191832027.png)\n\n\n\n加几个 UI 控件。\n\n![image-20220212191919869](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212191919869.png)\n\nctrl + drag 拖就完事了。 IBAction 拖到 m 文件里。 IBOutlet 拖到 h 里。\n\n![image-20220212191958553](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212191958553.png)\n\n右边这个代码窗口是 assitant 窗口。 可以这样打开\n\n![image-20220212192128460](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212192128460.png)\n\n连完后，长这样\n\n![image-20220212192233510](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212192233510.png)\n\n\n\n### xib 初始后的回调\n\n可以用来调整 UI 的一些属性细节。\n\n``` objc\n- (void)awakeFromNib{\n   // 改个字体啥的。\n   [self.mytext setFont:[NSFont fontWithName:@\"LXGW WenKai\" size:15]];\n}\n```\n\n\n\n> viewDidLoad 与 awakeFromNib 的区别\n>\n> viewDidLoad  是 controller 的回调。 所以，只有当参与了 UIViewController 生命周期时才有意义。 如 pushViewController 等\n>\n> awakeFromNib  是  NSObject 的回调。仅当加载 xib 时回调。\n\n \n\n## UI 自适应\n\n看 show the size inspector\n\n![image-20220212195245978](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212195245978.png)\n\n调整一下这东西，基本能懂\n\n![image-20220212195358843](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212195358843.png)\n\n\n\n# osx_oc_demo3\n\n## slide \n\n记得把这个勾了 ，会连续给值。 不然只会在 slide 结束时给值。 不符合直觉。\n\n![image-20220212200709461](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212200709461.png)\n\n# osx_oc_demo4\n\n## custom_view in xib\n\n使用 custom view 组件有个好处就是 UI 的部分可以托管给编辑器。 \n\n建一个类 MyView 继承自NSView \n\n拖一个 Custom View \n\n![image-20220212212631557](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212212631557.png)\n\n连接一下\n\n![image-20220212214924011](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212214924011.png)\n\n拖张图片 download.jpg 进工程，选以下选项\n\n![image-20220212213110140](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212213110140.png)\n\n\n\nMyView.m 里加入\n\n``` objc\n-(id)initWithCoder:(NSCoder*)coder{\n    self = [super initWithCoder:coder];\n    if(self){\n        NSRect rect = NSMakeRect(10, 10, 400, 400);\n        imageView = [[NSImageView alloc] initWithFrame:rect];\n        [imageView setImageScaling:NSScaleToFit];\n        [imageView setImage:[NSImage imageNamed:@\"download.jpg\"]];\n        [self addSubview:imageView];\n        \n    }\n    return self;\n}\n```\n\n\n\n运行， 哇啦\n\n![image-20220212214127628](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212214127628.png)\n\n\n\n也可以不拖 Custom View， 直接使用本来的 view，关联到 MyView。看你够不够懒\n\n![image-20220212215129737](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212215129737.png)\n\n\n\n\n\n# osx_oc_demo5\n\n拖一个 tableview，建一个 TableViewController\n\n连接这两。不贴图了。\n\n\n\n定义 Person 模型\n\n\n\n实现 datasource\n\n\n\n连接 datasource\n\n![image-20220212221857655](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220212221857655.png)\n\n\nhttps://www.youtube.com/watch?v=LJ6gP3HxVc8&list=PLE83F832121568D36&index=20&ab_channel=AppleProgramming\n",
                    "title": "osx_oc_demo2"
                  },
                  {
                    "path": "5.轮子索引/spring 原理.md",
                    "content": "\n #spring #docs/whatis-why-explanation \n\n没有什么动态能力是不能靠加一层抽象的.\n\nSpring 主要是两大步骤\n1. [[创建 SpringApplication]]\n2. [[SprinApplication.run]]\n3. [[getBean]]\n\n[一.spring源码分析 - 从图熟悉spring源码执行流程_名猿陈大浏的博客-CSDN博客_spring源码流程图](https://blog.csdn.net/qq_33743572/article/details/108859581)\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221029115251062.lEWz8.jpg)\n\n\n  ",
                    "title": "spring 原理"
                  },
                  {
                    "path": "5.轮子索引/spring/Controller 里使用 Callable 返回.md",
                    "content": "#spring  #async  #docs/how-to-guides \n\n\n这其实是与 [[@Async]] 做了同样的事。所以选一个就好。\n\nspring 可以处理多种返回值，包括 Callable 和 [[Spring 里的类/DeferredResult|DeferredResult]]\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223123632881.x8rnP.jpg)\n\n\n‍\n\n‍\n\n‍\n\n而配置它的线程池如下\n\n```java\n \n@Configuration\n@EnableAsync\npublic class AsyncConfiguration implements  AsyncConfigurer {\n \n \n    // for controller return callable\n    @Override\n    public void configureAsyncSupport(AsyncSupportConfigurer configurer) {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(4);\n        executor.setMaxPoolSize(4);\n        executor.setQueueCapacity(50);\n        executor.setThreadNamePrefix(\"R#Thread::\");\n        executor.initialize();\n        configurer.setTaskExecutor(executor);\n    }\n \n}\n```\n ",
                    "title": "Controller 里使用 Callable 返回"
                  },
                  {
                    "path": "5.轮子索引/spring/Spring MVC 请求流程.md",
                    "content": "#spring/mvc #docs/whatis-why-explanation \n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223125814974.Agnt0.jpg)\n​\n",
                    "title": "Spring MVC 请求流程"
                  },
                  {
                    "path": "5.轮子索引/spring/spring 里的接口/Aware.md",
                    "content": "#spring #docs/whatis-why-explanation \n\nAwareXxxx 类的父类，起一个统一管理作用。具体回调参数由子类实现。所以，类图上一定会有两个\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220914134549-6yf7dhv.png)​\n\n```java\npackage org.springframework.beans.factory;\n\n/**\n * A marker superinterface indicating that a bean is eligible to be notified by the\n * Spring container of a particular framework object through a callback-style method.\n * The actual method signature is determined by individual subinterfaces but should\n * typically consist of just one void-returning method that accepts a single argument.\n *\n * <p>Note that merely implementing {@link Aware} provides no default functionality.\n * Rather, processing must be done explicitly, for example in a\n * {@link org.springframework.beans.factory.config.BeanPostProcessor}.\n * Refer to {@link org.springframework.context.support.ApplicationContextAwareProcessor}\n * for an example of processing specific {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic interface Aware {\n\n}\n```\n",
                    "title": "Aware"
                  },
                  {
                    "path": "5.轮子索引/webapck 5.md",
                    "content": " \n#js #webpack  #docs/how-to-guides \n\n## 安装 webpack \nnpm install webpack webpack-cli --save-dev \n\n``` json\n{\n  \"name\": \"webpack-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"webpack\": \"^5.75.0\",\n    \"webpack-cli\": \"^5.0.0\"\n  }\n}\n\n```\n\n## 准备文件\nsrc/index.js \n``` js\nimport data from './data.json'\n\nfunction fn1() {\n    console.log('fn1')\n}\nfn1()\nconsole.log(data)\n```\n\nsrc/data.json\n``` json\n{\n    \"name\":\"zk\"\n}\n```\n\n\n### public/index.html\n```html\n\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n\n    <script src=\"../dist/main.js\"></script>\n</body>\n\n</html>\n```\n\n## 测试\n### dev 环境打包命令\nwebpack-cli ./src/index.js -o ./dist/ --mode=development \n\n### 打开 html \nopen pubic/index.html \n\n\n### 查看控制台\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221120160222655.YxZtc.jpg)\n\n\n### 生产 环境打包命令\nwebpack-cli ./src/index.js -o ./dist/ --mode=production\n\n> 多了压缩,与代码混淆\n\n\n\n## git 地址\n https://github.com/zk4/webpack-demo/tree/webpack-tutorial\n## Guide \n\n[webapck quick tutorial](webapck%20quick%20tutorial.md)  可以看到最简单的快速使用方式. 那一般我们会使用配置文件进行打包.\n基于以上工程,我们来看怎么通过配置文件打包.\n \n## 基础 config\n### 创建配置文件\n\nwebpack.config.js\n```js\nlet path = require(\"path\")\n\nmodule.exports = {\n    // entry \n    entry:\"./src/index.js\",\n    // output\n    output: {\n        filename: \"main.js\",\n        path: path.resolve(__dirname, 'dist')\n    },\n    // mode \n    mode: \"development\"\n}\n```\n\n### 执行命令\n\nwebpack-cli -c webpack.config.js\n\n将会看到与 tutorial 里命令行同样的效果\n\n##  管理 css (loader 使用)\n### 目标 \n1. js 里引用css\n2. js 里 css 自动注入到 index.html\n\n### 安装包\nnpm install css-loader style-loader --save-dev\n\ncss-loader 负责加载 css 到 js \nsytle-loade 的负责将 js 里的 css 整到 html 里\n\n### 编写 webpack.config.js\n``` js\nlet path = require(\"path\")\n\nmodule.exports = {\n    // entry \n    entry:\"./src/index.js\",\n    // output\n    output: {\n        filename: \"main.js\",\n        path: path.resolve(__dirname, 'dist')\n    },\n    // mode \n    mode: \"development\",\n    //loader 配置\n    module: {\n        // 对某个格式的文件进行转换处理\n        rules:[\n            {\n                // 匹配文件\n                test: /\\.css$/i,\n                // 匹配后的处理\n                use: [\n                    // use 数组里的 loader 的执行顺序是从下往上! \n                    // 2. 将 js 的样式内容插入到 html 的 style 标签里\n                    \"style-loader\",\n                    // 1. 将 css 文件转换为 js \n                    \"css-loader\"\n                ]\n            }\n        ]\n    }\n}\n```\n\n>  注意 \n>  1. use 的顺序, 是从下到上 \n>  2. 明明叫 loade , 却在 module 配置里\n\n\n### git 地址\nhttps://github.com/zk4/webpack-demo/tree/guide/webpack-loader-css\n\n## 自动注入 js 到 html (插件使用)\n### 目标\n自动注入 js 到 html\n\n### 安装包\nnpm install html-webpack-plugin --save-dev\n\n### webpack.config.js 增加配置\n``` js\n...\nconst HTML = require('html-webpack-plugin')\nmodule.exports = {\n   // ...\n   // module: { ... },\n \n    plugins: [\n        new HTML({\n            template: './index.html'\n        })\n    ]\n}\n```\n\n\n### 更新 index.html\n``` html\n\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n</body>\n\n</html>\n```\n\n\n### 打包\n\n\n## 打包图片资源\n### 目标 \n因为图片会经由打包, 需要管理所有图片的引用.\n\n### 安装包\nnpm install  url-loader html-loader --save-dev \n\n### 修改 html \n``` html\n<body>\n    <img src=\"./fruit.png\"/>\n</body>\n\n```\n### 增加 webpack.config.js \n``` js\n  {\n                test: /\\.(jpg|png|gif)$/,\n                loader: 'url-loader',\n                options:{\n                    // 当图片大小小于 8kb, base64 化\n                    limit: 8*1024,\n                    // 兼容问题\n                    esModule: false,\n                    // 打包后图片重命名\n                    name: '[hash:10].[ext]'\n                },\n                // 见下方注释说明\n                type: \"javascript/auto\"\n            },\n            {\n                test: /\\.html$/,\n                // 将 html 里引入的图片改成打包后的图片\n                loader:'html-loader'\n            },\n```\n\n> 当在 webpack 5 中使用旧的 assets loader（如 file-loader/url-loader/raw-loader 等）和 asset 模块时，你可能想停止当前 asset 模块的处理，并再次启动处理，这可能会导致 asset 重复，你可以通过将 asset 模块的类型设置为 ‘javascript/auto’ 来解决。\n\n\n\n## 热加载\n### 目标\n1. 开发时,自动打包,自动打开页面,\n2. 更新 js 时自动刷新\n\n### 安装包\nnpm install webpack-dev-server --save-dev \n\n### 增加 webpack.config.js\n与 plugins 同级\n``` js\n devServer: {\n        // dev server 打开的路径, webpack 5 后不再需要\n        // contentBase: path.resolve(__dirname,\"dist\"),\n        // 是否启动压缩\n        compress: true,\n        // 端口\n        port: 3000,\n        // 是否自动打开\n        open: true,\n        // HMR 热加载, 就一个开关, 不再像 webpack 4 一样需要插件 webpack.HotModuleReplacementPlugin\n        hot: true,\n    }\n```\n\n### 修改 package.json 并启动\n``` json\n  \"scripts\": {\n    // ....\n    \"dev\": \"webpack-dev-server\"\n  },\n```\n\nyarn dev\n\n\n### git 地址\nhttps://github.com/zk4/webpack-demo/tree/guide/webpack-dev-server",
                    "title": "webapck 5"
                  },
                  {
                    "path": "5.轮子索引/产品文档/百度盘直接代理.md",
                    "content": "#docs/how-to-guides  #baidupan \n\n代码:\n\n/Users/zk/git/pythonPrj/proxy.py\n\n启动:\n\n./start.sh\n\n思路:\n\n- 用官方的百度盘\n\n- 使用 https://pypi.org/project/proxy.py/ \n\n- 制作证书,导入,并信任\n\n- 拦截视频类请求\n\n- 将请求立刻返回完成\n\n  \n\n换个思路:\n- 嗅控采用 https://docs.mitmproxy.org/ 用 proxy.py 的接口太蛋痛 (搞定) \n- 将视频的下载请求拦截输送到 mpv\n\n\n\n## mpv 请求正确格式\n\n\nmpv --http-header-fields='User-Agent: netdisk;2.2.3;pc;pc-mac;10.12.6;macbaiduyunguanjia' https://qdall01.baidupcs.com/file/ddc5b41ba32ff4af868a1465e4940ef0?bkt=en-c58a217c5b5bf7b2b7c9612adc16ec8b323abd833f6a27fa9afc74dfd0c2928b4263f0af82787d15&fid=1744894658-250528-495132252639057&time=1582827522&sign=FDTAXGERLQlBHSKfWa-DCb740ccc5511e5e8fedcff06b081203-2zhlCYN0Eek%2F5zCgsZ5Dr2HEn6Q%3D&to=92&size=778333751&sta_dx=778333751&sta_cs=1316&sta_ft=mp4&sta_ct=5&sta_mt=5&fm2=MH%2CYangquan%2CAnywhere%2C%2C%E5%8C%97%E4%BA%AC%2Ccnc&ctime=1571920882&mtime=1579355800&resv0=-1&resv1=0&resv2=rlim&resv3=5&resv4=778333751&vuk=1744894658&iv=2&htype=offconn&randtype=&esl=1&newver=1&newfm=1&secfm=1&flow_ver=3&pkey=en-a62e7d16359dfd74481da95b94278fe0e865a511b1f621f8181c5e76112e06599035fc0be68d2f21&sl=69533774&expires=8h&rt=pr&r=776656507&mlogid=MjAyMDAyMjgwMjE4NDEzNzAsNzcxOGNkNDYwNzU0NTAxZWI0M2Y5YmNkMzkwNjViNzksNTc5Mg%3D%3D&vbdid=3816677860&fin=1.mp4&bflag=92%2C34-92&err_ver=1.0&check_blue=1&rtype=1&devuid=7718cd460754501eb43f9bcd39065b79&dp-logid=1659714951049867929&dp-callid=0.1&hps=1&tsl=250&csl=1000&fsl=-1&csign=xVshjG7Y4PlQdclZPB5P%2Fu7c3v8%3D&so=0&ut=1&uter=-1&serv=1&uc=3759752251&ti=2d3ed63abb82fd495d6eec5ae69768cb9ef69ccdcdb4d4c0&reqlabel=250528_l_0d379c25691f1db02fd2dff786ffd19a_-1_b47a1c84a207d217ae9410ea0984f09f&by=themis&gsl=1000&ec=1&method=download&gtchannel=0&gtrate=0\n\n \n\n\n\n## [关于证书格式](https://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file)\n\n\n\nSSL has been around for long enough you'd think that there would be agreed upon container formats. And you're right, there are. Too many standards as it happens. So this is what I know, and I'm sure others will chime in.\n\n- **.csr** - This is a Certificate Signing Request. Some applications can generate these for submission to certificate-authorities. The actual format is PKCS10 which is defined in [RFC 2986](https://tools.ietf.org/html/rfc2986). It includes some/all of the key details of the requested certificate such as subject, organization, state, whatnot, as well as the *public key* of the certificate to get signed. These get signed by the CA and a certificate is returned. The returned certificate is the public *certificate* (which includes the public key but not the private key), which itself can be in a couple of formats.\n- **.pem** - Defined in RFCs [1421](https://tools.ietf.org/html/rfc1421) through [1424](https://tools.ietf.org/html/rfc1424), this is a container format that may include just the public certificate (such as with Apache installs, and CA certificate files `/etc/ssl/certs`), or may include an entire certificate chain including public key, private key, and root certificates. Confusingly, it may also encode a CSR (e.g. as used [here](https://jamielinux.com/docs/openssl-certificate-authority/create-the-intermediate-pair.html)) as the PKCS10 format can be translated into PEM. The name is from [Privacy Enhanced Mail (PEM)](https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail), a failed method for secure email but the container format it used lives on, and is a base64 translation of the x509 ASN.1 keys.\n- **.key** - This is a PEM formatted file containing just the private-key of a specific certificate and is merely a conventional name and not a standardized one. In Apache installs, this frequently resides in `/etc/ssl/private`. The rights on these files are very important, and some programs will refuse to load these certificates if they are set wrong.\n- **.pkcs12 .pfx .p12** - Originally defined by RSA in the [Public-Key Cryptography Standards](https://en.wikipedia.org/wiki/PKCS) (abbreviated PKCS), the \"12\" variant was originally enhanced by Microsoft, and later submitted as [RFC 7292](https://tools.ietf.org/html/rfc7292). This is a passworded container format that contains both public and private certificate pairs. Unlike .pem files, this container is fully encrypted. Openssl can turn this into a .pem file with both public and private keys: `openssl pkcs12 -in file-to-convert.p12 -out converted-file.pem -nodes`\n\nA few other formats that show up from time to time:\n\n- **.der** - A way to encode ASN.1 syntax in binary, a .pem file is just a Base64 encoded .der file. OpenSSL can convert these to .pem (`openssl x509 -inform der -in to-convert.der -out converted.pem`). Windows sees these as Certificate files. By default, Windows will export certificates as .DER formatted files with a different extension. Like...\n- **.cert .cer .crt** - A .pem (or rarely .der) formatted file with a different extension, one that is recognized by Windows Explorer as a certificate, which .pem is not.\n- **.p7b .keystore** - Defined in [RFC 2315](https://tools.ietf.org/html/rfc2315) as PKCS number 7, this is a format used by Windows for certificate interchange. Java understands these natively, and often uses `.keystore` as an extension instead. Unlike .pem style certificates, this format has a *defined* way to include certification-path certificates.\n- **.crl** - A certificate revocation list. Certificate Authorities produce these as a way to de-authorize certificates before expiration. You can sometimes download them from CA websites.\n\n------\n\nIn summary, there are four different ways to present certificates and their components:\n\n- **PEM** - Governed by RFCs, its used preferentially by open-source software. It can have a variety of extensions (.pem, .key, .cer, .cert, more)\n- **PKCS7** - An open standard used by Java and supported by Windows. Does not contain private key material.\n- **PKCS12** - A Microsoft private standard that was later defined in an RFC that provides enhanced security versus the plain-text PEM format. This can contain private key material. Its used preferentially by Windows systems, and can be freely converted to PEM format through use of openssl.\n- **DER** - The parent format of PEM. It's useful to think of it as a binary version of the base64-encoded PEM file. Not routinely used very much outside of Windows.\n\n\n\n\n\n## 查看 pid 对应网络\n\nsudo lsof -Pan -p 49206 -i\n\n",
                    "title": "百度盘直接代理"
                  },
                  {
                    "path": "5.轮子索引/异步控制并发数.md",
                    "content": " #js  #concurrent #docs/how-to-guides \n \n\n```js\nfunction limitRequest(urls = [], limit = 3) {\n  return new Promise((resolve, reject) => {\n    const len = urls.length\n    let count = 0\n\n    // 同时启动limit个任务\n    while (limit > 0) {\n      start()\n      limit -= 1\n    }\n\n    function start() {\n      const url = urls.shift() // 从数组中拿取第一个任务\n      if (url) {\n        axios.post(url).then(res => {\n          // todo\n        }).catch(err => {\n          // todo\n        }).finally(() => {\n          if (count == len - 1) {\n            // 最后一个任务完成\n            resolve()\n          } else {\n            // 完成之后，启动下一个任务\n            count++\n            start()\n          }\n        })\n      }\n    }\n\n  })\n}\n\n// 测试\nlimitRequest(['http://xxa', 'http://xxb', 'http://xxc', 'http://xxd', 'http://xxe'])\n复制代码\n```",
                    "title": "异步控制并发数"
                  },
                  {
                    "path": "5.轮子索引/调试 Element UI 源码.md",
                    "content": " \n#debug #vue #elementUI #tools  #docs/how-to-guides \n\n\n\n![我是怎么调试 Element UI 源码的](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b23ffc38e504604ad59382ee2f33ff1~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n[上篇文章](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3OTYzMDkzMg%3D%3D%26mid%3D2247492344%26idx%3D1%26sn%3Da9187b4394b9d62d366974ed677f40fb%26chksm%3Dcf032dc3f874a4d5344b8c79057ad9e8859416c82f1b1efa9a56602b0778863667d445c27658%26token%3D1706144066%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492344&idx=1&sn=a9187b4394b9d62d366974ed677f40fb&chksm=cf032dc3f874a4d5344b8c79057ad9e8859416c82f1b1efa9a56602b0778863667d445c27658&token=1706144066&lang=zh_CN#rd\")写了怎么调试 antd 的源码，反响很不错：\n\n[![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9806f7558c40298bdaf85abcebfc5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3OTYzMDkzMg%3D%3D%26mid%3D2247492344%26idx%3D1%26sn%3Da9187b4394b9d62d366974ed677f40fb%26chksm%3Dcf032dc3f874a4d5344b8c79057ad9e8859416c82f1b1efa9a56602b0778863667d445c27658%26token%3D1706144066%26lang%3Dzh_CN%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492344&idx=1&sn=a9187b4394b9d62d366974ed677f40fb&chksm=cf032dc3f874a4d5344b8c79057ad9e8859416c82f1b1efa9a56602b0778863667d445c27658&token=1706144066&lang=zh_CN#rd\")\n\n但很多小伙伴是写 Vue 的，可能平时用的是 Element UI 的组件库，所以这篇文章就来讲下怎么调试 Element UI 的源码。\n\n首先，我们用 Vue CLI 创建一个 vue2 的项目：\n\n```sql\nyarn global add @vue/cli\n\nvue create element-vue-test\n复制代码\n```\n\n创建成功后，进入到项目目录\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67cdbcdd6cc4512a14d6ed204de26cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n安装 element ui 的库，并在入口引入：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f21e02b9044ccfaa6debfe96f38779~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n然后在 App.vue 里用一下 button 组件\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5a2477221f4f55888e1d1460c386ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n之后 yarn run serve 把开发服务跑起来，就可以看到这样的页面：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a178d9519fa4400186a9c8474156fdd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nElement UI 的组件正确的显示了。\n\n接下来调试 button 组件的源码，那问题来了，我怎么知道在哪里打断点呢？\n\n我们可以知道的是，这个 button 会处理点击事件，但是却不知道事件处理函数的代码在什么地方。\n\n这种情况可以加一个事件断点：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c16527387c14f5f89f74082ee2dee90~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n在 sources 面板的 Event Listener Breakponts 里勾选 Mouse 的 click 事件，也就是在所有 click 事件的处理函数处断住。\n\n然后你再点下那个按钮试试看：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d9259281a654640905b589957f6f9e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会发现它在事件处理函数处断住了。\n\n当你知道这个组件处理了什么事件，但却不知道事件处理函数在哪的时候就可以用事件断点。\n\n当然，这个事件处理函数并不是组件里的，因为 Vue 内部会先做一些处理，然后再交给组件处理。\n\n所以，我们要先走到组件的事件处理函数：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87fc57a2e2304f0eb3719b6f5bda832b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n单步执行、再进入函数内部，再单步执行、再进入函数内部，代码就会走到组件的事件处理函数：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93b3bb4e3ea44199155923ff916623c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nmethods、computed、props，这明显是源码里的了。但你再往上走两步，会发现又不是最初的源码：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f100a5b72a6e49cabd4d6c03c71c90e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\ntemplate 变成了 render 函数，而且还有其他组件的代码，这明显是被编译打包之后的代码。\n\n从文件名也可以看出来：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5ce7f055294cf09035b22b7b1f6bcc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这是一个把所有组件代码编译后打包到一起的文件。\n\n这样虽然也能调试，但肯定是不爽的，能不能直接调试组件最初的源码呢？就是带 template 的单文件组件那种？\n\n是可以的，这就要用到 sourcemap 了。\n\nsourcemap 是在编译过程中产生的：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0723a3baff44e9aa41673f3b228f8d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n里面记录了目标代码和源代码的映射关系，调试的时候可以通过它映射回源码：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f64c05cba545428d4b4a0cb1fd7a7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但是你去 node_modules 下看看，会发现没有这个文件的 sourcemap：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fa642fe63342fba5d3d47b1d5d2d7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那怎么生成它的 sourcemap 呢？\n\n这就要从源码重新编译了。\n\n我们从 github 把它的源码下载下来：\n\n```scss\ngit clone --depth=1 --single-branch git@github.com:ElemeFE/element.git\n复制代码\n```\n\n--depth=1 是只下载单个 commit，--single-branch 是下载单个 branch，这样下载速度能快几十倍，是一个加速小技巧。\n\n进入 element 目录，安装依赖，你会遇到一个前端经常头疼的问题，node-sass 安装报错了：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1196e4e8f8d4e02bf2b83d03e871c05~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个问题的解决方案就是把 node 版本切换到 node-sass 版本对应的那个。\n\npackage.json 中可以看到 node-sass 是 4.11.0\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4276f32f424f528c28eca5a2caec55~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n打开 node-sass 的 github 首页：\n\n你会看到这样一个版本对应关系表：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc73f359adce40eaa8b48ed353d9ef9e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n4.11 对应 node11，那就把 node 切换到 11 就可以了。\n\n然后再次 yarn 安装依赖就能成功了。\n\n之后开始编译，在 npm scripts 中可以找到 dist 命令，这就是构建源码用的：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71c358e9e00845449dfcc41753ab0491~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但是我们只需要 element-ui.common.js 这个文件：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b427dd52a9a543528e5fccb8792a83ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n其实只需要执行其中的一部分脚本，也就是这个：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e86d312ef9f49d8ab38841b4916b26f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n所以在项目下执行 npx webpack --config build/webpack.common.js 即可：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538d1089cab140f182940ab0a4f73b2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n然后在 lib 下就可以看到构建产物：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788f99ce7fcc4c5d8eaa7736eceb2e51~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但我们的目标是生成带有 source-map 的代码，所以要改下配置：\n\n修改 build/webpack.common.js，配置 devtool 为 cheap-module-source-map：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c167e20a6f4b0aa11c36e87d1433e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nsource-map 是生成 sourcemap 并关联，也就是这样：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1002b8dfdd9043eca35808af08b91845~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nmodule 是把中间 loader 产生的 sourcemap 也给合并到最终的 sourcemap 里，这样才能直接映射到源码。\n\ncheap 是加快编译速度用的，只保留行的映射信息。\n\n改完配置后再次 yarn run dist，就可以看到带有 sourcemap 的产物了：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a294a2d2c05e45f0a6d4eb1d31a07f01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n把这俩文件复制到测试项目的 node_modules/element-ui 下覆盖下之前的：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a418b72cd8ad4574b7bb3f1527e57b0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n之后清掉 node_modules/.cache 下的缓存，重新跑 dev server：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07cdb707c8c342ffb5009b79bb530582~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这时会报错提示你 node 版本太低了，你需要再把 node 版本换回来：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33d569e6e5114458814c6211b36f0cdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n跑起开发服务之后，再次用之前的方式调试 button 组件的源码：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/016ec8292bf44c6bb1e08fe8263910d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会发现现在的组件代码是带 template 语法的单文件组件的代码了！\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86839b26517b4f9ea63ac4f7180a7c8e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这就是 sourcemap 的作用。\n\n之后你会可以在这个组件里打断点然后调试。\n\n有的同学可能会问，通过事件断点进入组件内部，这样有点麻烦，有没有更简单的方式？而且 button 组件有点击事件，但有的组件没有呀，这些组件该怎么调试呢？\n\n确实，有了 sourcemap 之后就有更简单的调试方式了。\n\n你可以在 sources 左边看到 ELEMENT 目录下有很多 vue 文件，这其实就是 Chrome DevTools 解析 sourcemap 之后列在这里的：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db97f6a46c0d44cf8951cae15fe832d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你可以直接在里面打断点调试。\n\n比如我们加一个 tabs 组件：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488992edd28647a59601caf8501c75f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n把前面添加的那个事件断点去掉，在代码里手动打一个断点：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db63f9e63c804dfeb9ec1d2507bc08c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n然后你就会发现，这样就可以调试 Element UI 组件源码了！\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d002e966ffc640849b940f4cae20827c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n当然，有的组件找不到的时候，还是可以通过事件断点的方式来进入组件内部。\n\n我们是通过 Chrome DevTools 调试的，其实用 VSCode Debugger 来调试它也是一样的，在 Chrome DevTools 里打的断点，在 VSCode Debugger 里同样会断住。\n\n## 总结\n\n今天我们调试了 Element UI 的源码。\n\n定位到组件的代码，是通过事件断点的方式，因为我们知道它触发了什么事件，但却不知道事件处理函数在哪。\n\n但是组件的代码是被编译打包过的，不是最初的源码。\n\n为了调试最初的源码，我们下载了 Element UI 的代码，build 出了一份带有 sourcemap 的代码。\n\n覆盖项目 node_modules 下的代码，重新跑 dev server，这时候就可以直接调试组件源码了。\n\n有了 sourcemap 之后，Chrome DevTools 会直接把 vue 文件列在 sources 里，我们可以找到对应的 vue 文件来打断点，就不用通过事件断点来找了。\n\n能够调试 Element UI 源码之后，想知道组件内部都有哪些逻辑的话，就可以直接在源码断点调试了，就很香。\n",
                    "title": "调试 Element UI 源码"
                  },
                  {
                    "path": "5.轮子索引/调试 React 源码.md",
                    "content": "\n#react #debug #docs/how-to-guides \n\n![全网最优雅的 React 源码调试方式](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49dd6779c71d46d8a20fb564ee256760~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\n\n什么？调试 React 源码还有优雅和不优雅之分？\n\n别着急，我们先来听个故事：\n\n东东是一名前端工程师，主要用 React 技术栈，用了多年之后想深入一下，所以最近开始看 React 源码。\n\n他把 react 和 react-dom 包下载了下来，在项目里引入，开发服务跑起来后，打开 Chrome Devtools 打断点调试。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13036564429844188bfe6e42c7302ca8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样调试了一段时间之后，他有了一些困惑：\n\n这样调试是可以的，但是总感觉和源码有段距离，因为调试的是 react-dom.development.js\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09efe920c2514c6cad70fe10f2935ffd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n而源码里这些逻辑是分散在不同的包里的，所以就算搞懂了逻辑，也不知道这些逻辑在哪些包里，只能靠搜索来定位。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2194483a5cb64e709dcd0544e7d79511~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n所以他就在想，是不是有更好的调试方式，能够调试 React 最初的源码呢？\n\n于是，他跑来问我：光哥，你调试 React 源码会有这些问题么？你是怎么调试的呀？\n\n我说，确实，我最开始也是调试的 react-dom.development.js，但是现在已经能直接调试 React 最初的源码了，而且是在 VSCode 里调试的，点击调用栈能直接打开对应的 React 源码文件并定位到对应行列号：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7418d16f7c874f9cb25912f40deef10a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41e2219fd3546cda7a30bbe231cac3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n哇哦，这就是我想要的调试效果，这是怎么做到的呀。\n\n想实现这样的调试效果确实还有点复杂，我们一点点来看：\n\n首先，我们要做到在 VSCode 里调试 React 项目，而不是在 Chrome Devtools 里，这样才能做到直接打开对应的文件：\n\n## 用 VSCode 调试 React 项目\n\n我们用 create-react-app 创建一个 react 项目，然后 npm run start 跑起来。\n\n这时候浏览器访问就可以用 Chrome Devtools 调试了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab07f72ab99c47f686d6c20d5f134fd5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但我们的目标是在 VSCode 里调试，所以要添加一个 VSCode 的 debugger 配置：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9435be67eb764b4682034ce187c4466a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n在根目录下建一个 .vscode/launch.json 的文件，添加一个 chrome 类型的调试配置，输入调试的 url。\n\n然后点击 debug 启动：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b5ed86cd76417291424b8312e5f26c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这时候就可以在 VSCode 里直接打断点调试了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a890f4e5d246b2b8a96b161f338fdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n用 VSCode 调试肯定会比 Chrome Devtools 方便一些。但这不是我们最主要的目的，现在调试的依然是 react-dom.development.js：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bac7f31b42d4667bbd0793710b60ef5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那怎么调试 react 最初的源码呢？\n\n这就涉及到 sourcemap 的作用了：\n\n## sourcemap\n\nJS 代码经过编译，会产生目标代码，但同时也会产生 sourcemap。sourcemap 的作用就是映射目标代码中的位置和源码中的位置。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d166abdce288453fbdd2b47ccd719b33~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n比如源码中的第 3 行第 5 列的代码对应着编译后的第 1 行第 10 列的代码。\n\n类似这样的映射有很多，经过编码以后是这样的：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aec7abf0e6543749807378c0497891e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n在 js 文件最后一行，加上这样一行注释就可以关联 sourcemap：\n\n```ruby\n//# sourceMappingURL=http://example.com/path/to/your/sourcemap.map\n复制代码\n```\n\n调试工具支持解析 sourcemap 来映射调试的代码位置到源代码中的位置。\n\n比如 chrome devtools 的 Sources 面板就会提示从哪个文件 source mapping 过来的，点击链接还可以跳到映射之前的文件：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce84dde774244be9aedf9aa551b4464a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n同样，VSCode Debugger 也支持 sourcemap，有个 sourceMaps 的调试配置选项来开启和关闭 sourcemap 功能，默认开启。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d862671c14834c248ab345ec459fcefc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那这么说我们只要让 react-dom.development.js 关联上 sourcemap，就能调试最初的 React 源码了？\n\n理论上是这样的，但是现在下载的 react、react-dom 包里都不带 sourcemap，我们得把 React 源码下载下来自己 build：\n\n## build 出带有 sourcemap 的 react 包\n\n用 npm 下载的 react 包是这样的：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0930bf68605f4c269a721678ba511333~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n而我们需要的是带有 sourcemap 的代码，也就是这样的：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b7088ece3d24c279297e8aeebf675c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这就要下载 react 源码自己 build 了：\n\n```bash\ngit clone https://github.com/facebook/react\n复制代码\n```\n\n下载下来的代码执行 npm run build 就能看到 build 的产物：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d1883794b54d1f816c67019127d363~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这里的 build/node_modules 下的 react 和 react-dom 包就是我们需要的。\n\n但是现在 build 出的代码并没有带 sourcemap，需要改造下 build 流程。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27bc3fb2de0e4c3e820705e14add4453~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nbuild 命令执行的是 ./scripts/rollup/build.js，打开这个文件做一些修改。\n\n找到 rollup 的配置，添加一行 sourcemap: true，这个很容易理解，就是让 rollup 在构建时产生 sourcemap：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b325bb4d64c484e95fa2a848955d7b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n再跑 npm run build，会报这样的错误：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2aab90372c548a7b798e170cf9057a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n某个转换的插件没有生成 sourcemap。\n\n这个是因为构建的过程中会进行多次转换，会生成多次 sourcemap，然后把 sourcemap 串联起来就是最终的 sourcemap。如果中间有一步转换没有生成 sourcemap，那就断掉了，也就没法把 sourcemap 串联起来了。\n\n这个问题的解决只要找出没有生成 sourcemap 的那几个插件注释掉就可以了：\n\n在 getPlugins 方法里，把这样 4 个插件给注释掉：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3e7a66705147aeab5f172384155a2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个是删除 use strict 用的，可以去掉。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e37f2cda23c84ee19a89dd6799927830~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个是生产环境压缩代码的，也可以去掉。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/437749ca94a245e391e6e7415646bbeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个是用 prettier 格式化代码的，也可以去掉。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2bdadee106476696b8a1e0afacd699~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这个是添加一些头部的代码的，比如 Lisence 等，也没啥用，可以去掉。\n\n去掉这四个插件之后，再运行 npm run build，这时候就能正常进行构建了，然后产生的代码就是带有 sourcemap 的：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83161186ba7482bb0c51e7650f29d67~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/636c3ba1ec334eba8fe2c0245ffec58b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样我们就成功的 build 出了带有 sourcemap 的 react 包！\n\n接下来只剩最后一步，用上 sourcemap，实现直接调试 React 最初的源码，\n\n## 应用 sourcemap，调试 React 最初的源码\n\n我们已经 build 除了带有 sourcemap 的 react 和 react-dom 包，那把这俩包复制到测试项目的 node_modules 下，就可以直接调试最初的源码了么？\n\n还是不行。\n\n为什么呢？\n\n看下面这张图：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2910acd72c3a41d191492d440994ab6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n我们改造了 build 流程，对 react 源码进行了 build，产生了带有 sourcemap 的 react、react-dom 包，这些包最终导出的是 react-xx.development.js。\n\n之后在项目里引入，经过 webpack 打包，产生了 bundle.js 和 sourcemap。\n\n之后调试工具运行代码的时候，会解析 sourcemap，完成从 bundle.js 到 react-xxx.development.js 的映射：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc987f0b3c0a4c75825d9e82cb46e605~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n但是并不会再次做 react-xx.development.js 到 react 最初源码的映射呀。\n\n也就是调试工具只会解析一次 sourcemap。\n\n那怎么办呢？\n\n不打包 react 和 react-dom 这俩包不就行了。不经过 webpack 打包，那就没有 webpack 产生的 sourcemap，不就一次就映射到 React 最初的源码了么。\n\n那怎么不打包这俩模块呢？\n\nwebpack 支持 externals 来配置一些模块使用全局变量而不进行打包，这样我们就可以单独加载 react、react-dom，然后把他们导出的全局变量配置到 externals 就行了。\n\n要改动 webpack 配置的话，在 create-react-app 下要执行 npm run eject。\n\n然后项目下会多出 config 目录和 public 目录，这俩分别放着 webpack 配置和一些公共文件。\n\n修改 webpack 配置，在 externals 下添加 react 和 react-dom 包对应的全局变量：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e8674e738e145a6af6dcf5d43afe909~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n然后把 react.development.js 和 react-dom.development.js 放到 public 下，并在 index.html 里面加载这俩文件：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e61ecf9060d49fabad9699b06b85a3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样再重新 debug，你就会发现 sourcemap 映射到 React 最初的源码了：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4328e0c24784289ae518d4164f89a88~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n不再是 react-dom.development.js 下的代码，而是具体 react-xxx 包下的。\n\n这就达到了最开始的目的，能直接调试 React 最初的源码！\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e163d261da134940bd68841d2e9fc08e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n还记得我们这样做的意义么？\n\n能调试最初的源码才能知道哪段逻辑是在哪个包里的，不然要自己去搜索。\n\n这样已经能够达到我们的目的了，但是要想点击调用栈直接定位到 git clone 下来的 react 项目的文件，还需要再做一步。\n\n## 关联 react 源码项目\n\n看我最初演示的效果，点击调用栈是能直接定位到 react 源码项目的文件的：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41e2219fd3546cda7a30bbe231cac3e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这是怎么做到的呢？\n\n其实只要 sourcemap 生效，并且 map 到的文件是在当前 workspace 下，VSCode 就会打开对应的文件。\n\n现在 sourcemap 已经生效了，只不过 react 项目没有在 workspace 下。所以，如果想直接定位 react 源码项目的话，可以这样做：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4586e1e6847e49f7ad4d778070513f30~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n创建一个新的目录，把 react 源码项目和测试的项目放到一个 workspace 下，这样再调试的时候，map 到的文件就能在 workspace 找到了，也就会打开相应的文件。\n\n只不过现在 sourcemap 下都是这样的相对路径，会导致映射到的文件路径不对：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ce66f6c7e547c890c5e15fe4bb2e71~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n所以再去修改下 react build 流程，在 ./script/rollup/build.js 下，添加一个 sourcemap 的路径映射，把 ../../../packages 映射到 react 项目的绝对路径/pcakges ：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d9b961d876407db6b81efd8653cc3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这时候再重新 build，生成的 sourcemap 就是绝对路径了：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5853b6cbfec641f592519215ad9bd741~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n把新生成的 sourcemap 复制过去，覆盖一下。\n\n在新的 workspace 里 debug，你就会发现，路径映射对了：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfbd1497d3744398869ca78d7c40ad43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n点击调用栈能直接打开 react 源码项目的对应文件了！\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f336e59289b646dbb0bf557f9f9d6c1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n至此，我们就能优雅的调试 React 最初的源码了。\n\n## 总结\n\n用了 react 比较长时间后，自然会想调试下源码来深入下，但是常规的调试方式只能调试 react-dom.development.js，虽然能理清逻辑，但是对应不到源码里的哪些包哪些文件，总感觉和最初的源码还有一段距离。\n\n这个问题是有解决方案的，就是会有点复杂：\n\n首先要把 react 源码项目下载下来，修改 build 流程来生成带有 sourcemap 的 react 和 react-dom 包，并且修改 sourcemap 映射的路径为绝对路径。\n\n然后把 react 和 react-dom 配置到 webpack 的 externals 里，不进行打包，而是单独在 index.html 里引入。\n\n因为 sourcemap 只会映射一次，而 webpack 已经生成了一次 sourcmap，只有跳过这俩模块的打包才能让 react 和 react-dom 的 sourcemap 生效。\n\n之后用 VSCode Debugger 来调试 React 项目，就能映射到最初的 React 源码了。\n\n如果想点击调用栈直接打开对应 React 源码项目的文件，那就新建一个 workspace，把测试项目和 React 源码项目包含就行了。因为 VSCode 如果在 workspace 下找到了 source map 到的文件，就会直接打开对应的文件。\n\n东东：最终的调试效果是很完美，但这个流程有点复杂\n\n我：确实挺复杂，但其实都是围绕 sourcemap 来的，怎么生成 sourcemap，怎么让 sourcemap 生效，怎么找到 sourcemap 对应的文件等，理解了 sourcemap，也就很容易理解这个流程了。\n\n毫不夸张地说，这应该是全网最优雅的 React 源码调试方式了。\n",
                    "title": "调试 React 源码"
                  },
                  {
                    "path": "5.轮子索引/调试 antd 的源码.md",
                    "content": "\n#tools #vscode  #debug #react #antd #docs/how-to-guides \n \n \n首先，我们用 create-react-app 创建一个 react 项目：\n\n``` bash \nyarn create react-app antd-react-test\n```\n\n \n然后我们安装 antd，在入口组件里引入样式和 Button 组件：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580004c0963a4f7f9f751d8990a6981b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n页面会显示这个 Button：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090b9202b7554b1abe778161e50ea0a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那怎么调试这个 Button 组件的源码呢？\n\n可以这样：\n\n首先，创建一个 VSCode 调试配置：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06d00ecc08424b92904d86f8b771faae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n指定调试的 URL，然后启动调试。\n\n在组件里打个断点，代码会在这里断住：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42630455be204e3fa9c9a99f97ed095e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n可以看到调用栈中上一帧是 renderWithHooks，这就是 react 源码里调用函数组件的地方。\n\n点击那个调用栈，你就会看到：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27bb45bd9697475482467c15b5fd0ced~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n它调用了 App 的函数组件，传入了参数，拿到渲染后的 children 做后续处理。\n\n所有函数组件都是在这里被调用的，而 antd 的组件也全部是函数组件，那么我们在这里加个断点，打名字为 Button 的函数组件被调用的时候断住不就行了？\n\n这种在某种条件下才断住的情况可以用条件断点：\n\n右键选择添加条件断点：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b78d519594745ad82b9b868e62fd9e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n输入断住的条件：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f898d245230e45cea83cf52b2dff7160~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n当组件名字包含 Button 的时候才断住。\n\n然后刷新：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380913abe42748e1965b667b0792d53a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会看到 App 组件明明也是函数组件，却没有在这里断住，而 InternalButton 在这里断住了。\n\n这就是条件断点的作用。\n\n这个 InternalButton 就是 antd 里的 Button 组件。\n\nstep into 进入函数内部：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd4847777e5476c8e1f28b72e2544a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会发现这确实是 Button 组件的源码，但却是被编译后的，比如 jsx 都被编译成了 React.createElement：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/013f8b594fcc47098061254bafc5fbe3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这样是可以调试 Button 组件源码的，但是比较别扭。\n\n那能不能直接调试 Button 组件对应的 tsx 源码呢？\n\n可以的，这就要用到 sourcemap 了。\n\n我们得把 antd 的源码下载下来(我下载的时候是 4.23）：\n\n```scss\ngit clone --depth=1 --single-branch git@github.com:ant-design/ant-design.git\n复制代码\n```\n\n下载的时候加个 --single-branch 是下载单个分支， --depth=1 是下载单个 commit， 这样速度会快几十倍，是个有用的加速小技巧。\n\nantd 下载下来，安装完依赖之后，我们开始 build。\n\n但你会发现 package.json 中有 build 命令，有 dist 命令，该执行哪个呢？\n\n这个就需要了解下 antd 的几种入口了。\n\n去 react 项目的 node_modules 下，找到 antd 的 package.json 看一下，你会发现它有三种入口：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4149cf082614376a80c511466607a1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n-   main 是 commonjs 的入口，也就是 require('antd') 的时候会走这个。\n    \n-   module 是 esm 的入口，也就是 import xx from 'antd' 的时候会走这个。\n    \n-   unpkg 是 UMD 的入口，也就是通过 script 标签引入的时候或者 commonjs 的方式等都可以用。\n    \n\n分别对应了 lib、es、dist 的目录。\n\n所以 antd 项目里的 dist 命令就是单独生成 UMD 代码的，而 build 命令是生成这三种代码。\n\n这三种形式的代码都是可用的，这里我们选择构建 UMD 形式的代码，因为它会用 webpack 打包，而另外两种是通过 gulp 构建的。我对 webpack 更熟悉一些。\n\n执行 npm run dist，就会构建出 dist 目录，下面是 UMD 的代码：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a1b6580d0564b58adb118516d8027e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4035e640277f4dc38cafd24d87897879~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你会发现默认的构建就是会生成 sourcemap 的，其实你去那个 react 测试项目里看下，从 npm 下载的 antd 包也带了 sourcemap：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95b6de880b3946adbbde8bb0e9162b40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n那直接用 dist 入口的代码就能调试源码了么？\n\n我们试一下：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2884f766bf464ff2b72b06d562040635~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n把引入组件的地方换成 dist 目录下，也就是用 UMD 形式的入口。\n\n重新跑调试：\n\n你会发现代码确实比之前更像源码了。\n\n之前前面是这样的：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/416b90dedfe44a43a1365c303c87f039~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n现在是这样：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52b35096ca87411299d3f4951a4d7214~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n也就是没了 babel runtime 的代码，这明显是源码了。\n\n但是你往后看：\n\n之前是这样的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a11926873524c60afb482efbef97917~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n现在是这样： ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bad94a64d110428497be3f55d74be02e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n依然还是 React.createElement，而不是 jsx，也没有 ts 的代码。\n\n说明它还不是最初的源码。\n\n为什么会出现这种既是源码又不是源码的情况呢？\n\n因为它的编译流程是这样的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea239ead77974ea5bfe0f21a8f09bdc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n代码经过了 tsc 的编译，然后又经过了 babel 的编译，最后再通过 webpack 打包成 bundle.js。\n\ntsc 和 babel 的编译都会生成 sourcemap，而 webpack 也会生成一个 sourcemap。\n\nwebpack 的 sourcemap 默认只会根据最后一个 loader 的 sourcemap 来生成。\n\n所以说上面我们用了 sourcemap 之后只能关联到 babel 处理之前的代码，像 ts 语法、jsx 代码这些都没有了。\n\n因为没有关联更上一级的 ts-loader 的 sourcemap，自然是没法直接映射回源码的。\n\n所以想映射回最初的 tsx 源码，只要关联了每一级 loader 的 sourcemap 就可以了。而这个是可以配置的，就是 devtool。\n\ndevtool 可以设置 soruce-map，就是生成 sourcemap，但是这个不会关联 loader 的 sourcemap。\n\n还可以设置 cheap-module-source-map，这个 module 就是关联 loader 的 soruce-map 的意思。（那个 cheap 是只保留行的 sourcemap，生成速度会更快）\n\n思路理清楚了，我们去改下编译配置：\n\nantd 的编译工具链在 @ant-design/tools 这个包里，从 antd/node_modules/@antd-design/tools/lib/getWebpackConfig.js 就可以找到 webpack 的配置：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a563792958264bc0894fd2ae3dc7914c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n搜一下 ts-loader，你就会看到这段配置：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87e44b989e84182a94fbadae88b00e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n确实就像我们分析的，tsx 会经过 ts-loader 和 babel-loader 的处理。\n\n搜一下 devtool，你会发现它的配置是 source-map：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca68066fce84506971d31e8b6e92dea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n这就是 antd 虽然有 sourcemap，但是关联不到 tsx 源码的原因。\n\n那我们给它改一下：\n\n把 devtool 改为 cheap-module-source-map。\n\n并且改一下 [[babel 配置]]，设置 sourceMap 为 true，让它生成 sourcemap。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae0c63384904921b49a3932aab8286d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nts也同样要生成 sourcemap，不过那个是在根目录的 tsconfig.json里改：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea02551cef7480684fa8ac0b2b55664~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n改完这三点之后，再重新跑 npm run dist。\n\ndist 目录下会生成新的 antd.js 和 antd.js.map。\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc155ace2a64817bc76930cf0688912~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n把它复制到 react 项目的 node_modules/antd/dist 下，覆盖之前的。\n\n清一下 babel-loader 的缓存，删除整个 .cache 目录：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ca1e6d79b5411b8c250032b6501056~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n重新跑 dev server。\n\n注意，这里要用 dist 下的代码：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a00e5b1f034e4e43a3defbede3fa1fab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n然后再跑到断点的位置，进入组件源码，你会进入一个新世界：\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1285723e2374833b29d492754c5637c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\nts 类型、jsx 的语法，熟悉的感觉又回来了，这不就是 antd 组件的源码么！\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da58cdf18a4b47a88134e19a81e36393~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\n你可以断点调试 antd 的参数是怎么处理的，什么参数会走什么逻辑等。\n\n这个完全不影响正常开发，也就是把 antd 换成了从 antd/dist/antd 引入而已，开发完了换回去就行。\n\n现在开发 antd 组件还有看文档么？\n\n直接看源码它不更香么！\n\n有的同学可能会担心 node_modules 下的改动保存不下来。\n\n这个也不是问题，可以执行下 npx patch-package antd，会生成这样一个 patch 文件:\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548502b7a9124ec6a2913189a9740436~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n\npatch 文件里记录了你对 antd 包的改动，这个可以上传到 git 仓库，其他小伙伴拉下来再执行 npx patch-package 就会自动应用这些改动。\n\n至此，我们成功的调试了 antd 组件的 tsx 源码。\n\n为什么说 90% 的前端不会调试它的源码呢？\n\n主要是涉及的技术比较多：\n\n-   VSCode Chrome Debugger 调试网页，这个知道的人就不多\n-   react 源码里 renderWithHooks 是调用函数组件的地方\n-   条件断点可以在满足条件的时候断住\n-   antd 的 esm、commonjs、UMD 三种入口\n-   sourcemap 是干啥的，虽然经常接触，但还是有很多前端没用过\n-   webpack 的 cheap-module-source-map 的含义，为什么需要关联 loader 的 sourcemap\n\n而调试 antd 的组件源码需要综合运用这些技术，难度还是比较高的。\n\n## 总结\n\nantd 是 react 主流组件库，我们经常使用它但可能并没有调试过它的源码。\n\n我们可以在 renderWithHooks 里调用函数组件的地方打个条件断点，在调用想调试的组件时断住，这样我们就可以 step into 到该组件定义的地方。\n\n但是这样调试的并不是最初的源码，没有 jsx 和 ts 语法。\n\n想调试最初的 tsx 源码需要用 sourcemap。\n\nantd 有三种入口：es 目录对应 esm 入口，lib 目录对应 commonjs 入口，dist 目录对应 UMD 入口。\n\n把 antd 代码下载下来，执行 npm run dist 就可以生成 UMD 形式的代码。\n\n想要 sourcemap 映射到 tsx 源码，需要把 devtool 设置成 cheap-module-source-map，然后开启 babel-loader 和 ts-loader 的 sourcemap。\n\n把产物覆盖 antd 的 dist 下的产物，再调试就可以直接调试 antd 组件的 tsx 源码了。\n\n用 antd 组件写业务逻辑之余，对什么组件感兴趣，可以顺便去看看它的源码，它不香么？\n\n最后打个小广告，更多调试相关技术可以看我的调试小册 [《前端调试通关秘籍》](https://juejin.cn/book/7070324244772716556 \"https://juejin.cn/book/7070324244772716556\")",
                    "title": "调试 antd 的源码"
                  },
                  {
                    "path": "5.轮子索引/运维/日志解决方案.md",
                    "content": "#docs/how-to-guides  #log \n \n\n传统日志方案\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221004192129-9si1raj.png)​\n\n‍\n\n \n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221004205312-u2v20tj.png)​\n\n‍\n\n## 收集\n\n### 端采集\n\n### 存储\n\n### 索引\n\n## 监控\n\n## 报警\n\n‍\n\n‍\n\n‍\n\n## 参考\n\n（纯干货）3小时搞定Prometheus普罗米修斯监控系统\n\n[https://www.bilibili.com/video/BV16J411z7SQ/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=ca0ebcf87af35e0804e0df7cb43b9758](https://www.bilibili.com/video/BV16J411z7SQ/?spm_id_from=333.788.recommend_more_video.1&vd_source=ca0ebcf87af35e0804e0df7cb43b9758)\n\n‍\n\nk8s + loki 日志解决方案 (持续更新中)\n\n[https://www.bilibili.com/video/BV1nY4y137nv/?spm_id_from=..search-card.all.click&amp;vd_source=ca0ebcf87af35e0804e0df7cb43b9758](https://www.bilibili.com/video/BV1nY4y137nv/?spm_id_from=..search-card.all.click&vd_source=ca0ebcf87af35e0804e0df7cb43b9758)\n\n‍\n\n‍\n\n（纯干货）Prometheus+Grafana（Kubernetes）企业级运维监控\n\n[https://www.bilibili.com/video/BV1Rd4y1u7sd?p=2&amp;vd_source=ca0ebcf87af35e0804e0df7cb43b9758](https://www.bilibili.com/video/BV1Rd4y1u7sd?p=2&vd_source=ca0ebcf87af35e0804e0df7cb43b9758)\n",
                    "title": "日志解决方案"
                  },
                  {
                    "path": "6.实战案例/Sentinel.md",
                    "content": "\n#spring #libs #docs/tutorials \nSentinel 配置\n## 介绍\n\n对标的是 hystrix，但更加强大\n\n- **查看机器列表以及健康状态**，与 nacos 有重复的功能～\n- **监控**\n- **规则管理和推送**\n- **鉴权**\n\n### 主要特性\n\n![image-20190909101447103](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190909101447103.png)\n\n\n\n### 开源生态\n\n![image-20190909101320114](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190909101320114.png)\n\n\n\n## Dashboard 启动\n\n### 下载\n\n找到最新版本 https://github.com/alibaba/Sentinel/releases\n\n\n\n### 启动\n\n```bash\n#!/bin/bash\njava -Dserver.port=8082 -Dcsp.sentinel.dashboard.server=lolcahost:8082  -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.6.2.jar  \n```\n\n\n\n### 登陆\n\n账号密码： sentinel/sentinel\n\n初次打开可能是空界面。需要启动一下其他的服务，比如启动 service-client.\n\n\n\n## 熔断\n\n\n\n### application.yaml\n\n```yaml\nspring:\n  application:\n    name: service-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8848\n    sentinel:\n      transport:\n        dashboard: 127.0.0.1:8082\n\n\nfeign:\n  sentinel:\n    enabled: true\n      \nserver:\n  port: 10106\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n\n\n\n###  实现 Feign  的接口\n\nfallback 类需要由 spring 管理，加上 @Service 或 @Component 注解。\n\n```java\n@Service\npublic class HelloServiceFallback implements HelloService {\n    @Override\n    public String hello(String str) {\n        return \"请联系管理员\";\n    }\n    @Override\n    public int lb() {\n        return -1;\n    }\n}\n```\n\n\n\n### 指定 Feign 的 fallback\n\n```java\n@FeignClient(value = \"service-provider\",fallback = HelloServiceFallback.class)\npublic interface HelloService {\n     ...\n}\n\n```\n\n\n\n### 测试\n\n不启动 service-provider\n\n![image-20190909113137097](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190909113137097.png)\n\n\n\n启动 servcie-provider",
                    "title": "Sentinel"
                  },
                  {
                    "path": "6.实战案例/企业项目最佳实践/SPI 怎么用？.md",
                    "content": "#java    #docs/how-to-guides  #spring \n\n\nSpringBoot毋庸置疑是目前流行度最高的框架。而这原因，即是大家最清楚的0配置化，不需要配置便可以启动一个tomcat服务。\n\n我相信，只要你用过Spring Boot，就会对这样一个现象非常的好奇：\n\n```\n引入一个组件依赖，加个配置，这个组件就生效了。\n```\n\n为了故事的发展，我们举个例子来说，比如我们常用的Redis, 在Spring Boot中就是这样使用的\n\n**引入依赖**\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n复制代码\n```\n\n**配置yml文件**\n\n```yml\nspring:\n  redis:\n    host: 127.0.0.1\n    port: 6379\n    password: 123456\n复制代码\n```\n\n这就配置OK了，可以直接引用了，神奇嘛\n\n```java\n@Autowired\nprivate RedisTemplate redisTemplate;\n复制代码\n```\n\n就这样，两步搞定，中间没有做任何事情。这里面我们应该提出几个问题。\n\n第一，pom文件redis是在哪里，怎么连版本号都没有，reids版本是什么\n\n第二，RedisTemplate 是怎么交给Spring注入管理的，怎么就能用了呢。\n\n不知道你们刚接触Boot的时候，有没有听说过`约定大于配置`。我们要明白一个道理，事情总要有人做，自己不做，肯定是别人帮着做了，我们带着这些疑问去深入看源码。\n\n## SPI\n\n先不着急，讲流程源码之前，我们先来学习下SPI，这个非常重要，Boot里面大都是靠这个机制在做事情。上一篇只是简单提了下，今天发现绕不开了。\n\n> SPI ，全称为 Service Provider Interface(服务提供者接口)，是一种服务发现机制。它通过在classpath路径下的`META-INF/services`文件夹查找文件，自动加载文件中所定义的类。\n\n为了故事的继续发展 我们建个工程\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/8b62a9ac766d43578bf99ca868ce1480~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n我们用医生给我们做核酸的场景：\n\n```\nspi-doctor 为服务提供方，可以理解为我们的框架\nspi-person 为使用方，因为我的服务提供接口叫PlayHeSuan（做核酸），所以所有实现都是人～\n```\n\n**我们看下代码**\n\n在spi-doctor模块中定义接口`PlayHeSuan`\n\n```java\n/**\n * 服务提供者，做核酸\n * @Date 2022/4/29 5:50 下午\n * @Author shushi\n */\npublic interface PlayHeSuan {\n    //做核酸\n    void playHeSuan();\n}\n复制代码\n```\n\n在spi-person模块中定义两个实现类`ZhangSan`,`Lisi`\n\n```java\n/**\n * 李四做核酸\n * @Date 2022/4/29 5:57 下午\n * @Author shushi\n */\npublic class Lisi implements PlayHeSuan {\n\n    @Override\n    public void playHeSuan() {\n        System.out.println(\"李四做核酸~~~~\");\n    }\n}\n复制代码\n/**\n * 张三做核酸\n * @Date 2022/4/29 5:56 下午\n * @Author shushi\n */\npublic class ZhangSan implements PlayHeSuan {\n\n    @Override\n    public void playHeSuan() {\n        System.out.println(\"张三做核酸 ~~~~\");\n    }\n}\n复制代码\n```\n\n### 编写配置文件\n\n```\n新建文件夹META-INF/services\n在文件夹下新建文件cn.shushi.spi.doctor.PlayHeSuan\n```\n\n> 这里要特别说明 建配置文件一定要直接写 META-INF/services，不能直接写META-INF.services，否则会无效\n\n文件里面写实现类的全路径\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/6e2c4a40305e49d7a3276b8c4bba70ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n### 测试\n\n```java\npublic class SpiTest {\n    public static void main(String[] args) {\n        ServiceLoader<PlayHeSuan> load = ServiceLoader.load(PlayHeSuan.class);\n        load.forEach(PlayHeSuan::playHeSuan);\n    }\n}\n复制代码\n```\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/9cb421c684764e4cb1fa3779fc56eafd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\nSPI就讲到这里，我们回过头来结合实例理解下。SPI的目的就是借助SPI理解自动装配\n\n## 借助SPI理解自动装配\n\n回顾一下我们做了什么，我们在resources下创建了一个文件，里面放了些实现类，然后通过`ServiceLoader`这个类加载器就把它们加载出来了。\n\n假设有人已经把编写配置之类的前置步骤完成了，那么我们是不是只需要使用下面的这部分代码，就能将`PlayHeSuan`有关的所有实现类调度出来。\n\n```java\n// 使用Java的ServiceLoader进行加载\nServiceLoader<PlayHeSuan> load = ServiceLoader.load(PlayHeSuan.class);\nload.forEach(PlayHeSuan::playHeSuan);\n复制代码\n再进一步讲，如果再有人把上面这部分代码也给写了，然后把这些实现类全部注入到Spring容器里，那会发生什么？\n```\n\n相信到这里大家看到这里心里都已经有个谱了，我们接下来进入SpringBoot开始深入理解\n\n## SpringBoot的配置文件\n\n在回想下SPI机制，他们都是通过在组件下放入一个配置文件完成的，那么Spring Boot是不是也这样的呢？。\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/a82d130c01ef4f4cb9b32150a721cf87~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n是的 没错，我们可以通过pom文件的组名称来maven看到在这个下面，我们可以看到`spring.factories`,翻译过来是spring工厂，是不是有那个感觉了，这个就是实例化的呗\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1e5803d5c9a14f22a08544a7683dde46~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n很明显的看到最下面有个自动配置的注释，`key还是个EnableAutoConfiguration，开启自动配置！`找到了！\n\n我们接着找我们最开始说的redis\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1c35d76f58b24e8f985ac79981c0fe1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n进入RedisAutoConfiguration类，看看里面是些什么代码\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/154eb9b12a464e12a6479fe5849167d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n哈哈 破案了，终于破案了，这里不就是加载进去了嘛，`配置文件我们也找到了：spring.factories，也实锤了就是通过这个配置文件进行的自动配置。`\n\n接下来，我们来尝试还原一下案情经过：\n\n- `第一 通过某种方式读取spring.factories文件，紧接着把里面所有的自动配置类加载到Spring容器中`\n- `第二 然后就可以通过Spring的机制将配置类的@Bean注入到容器中了。`\n\n那接下来,我们就看是通过什么样的方式读取spring.factories,并且注入的，看到这里是不是感觉刚要进去的感觉，坚持看，相信都能看明白\n\n## 如何注入\n\n其实读取配置，就是注入，我们一起来看下看看Spring中有哪些`注入方式`\n\n类似于@Component，@Bean这些，阿鉴就不说了，大家肯定见过一种这样的注解：`EnableXxxxx`\n\n比如：`EnableAsync`开启异步，大家好不好奇这样的注解是怎么生效的？一起来看下\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/e549f3dbb3bf4534b7fe3f27f4524110~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n大家有没有发现，框架中到处是Import注解，这里先不展开细讲，到时候讲Spring的时候，再细说，`总之一句话，import就是将该类交给Spring管理，实例化该bean。`\n\n那回过头来进去 `AsyncConfigurationSelector`，接着进去`ProxyAsyncConfiguration`\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/d1b78eb2aba74b38a890eb8d0f65e754~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n真相了，`EnableAsync`就是通过这里（`AsyncAnnotationBeanPostProcessor`）生效的\n\n好的 我们接着研究最后一个注解，也是SpringBoot的启动核心注解\n\n## SpringBootApplication注解\n\n我们在使用SpringBoot项目时，用到的唯一的注解就是@SpringBootApplication，所以我们唯一能下手的也只有它了，打开它看看吧。\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/04cc524a01394e42b39814c4e6562861~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/b54d23a8711646efb5d68b6391934133~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n进入`AutoConfigurationImportSelector`核心逻辑`selectImports`\n\n```java\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n   if (!isEnabled(annotationMetadata)) {\n      return NO_IMPORTS;\n   }\n   AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n         .loadMetadata(this.beanClassLoader);\n   AnnotationAttributes attributes = getAttributes(annotationMetadata);\n   \n   // 获取候选的配置类，这个其实就是开始去拿配置类去了\n   List<String> configurations = getCandidateConfigurations(annotationMetadata,\n         attributes);\n         \n   // 移除重复的配置     \n   configurations = removeDuplicates(configurations);\n   \n   // 获取到要排除的配置\n   Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n   checkExcludedClasses(configurations, exclusions);\n   \n   // 移除所有要排除的配置\n   configurations.removeAll(exclusions);\n   \n   //过滤掉不具备注入条件的配置类，通过Conditional注解\n   configurations = filter(configurations, autoConfigurationMetadata);\n   \n   //通知自动配置相关的监听器\n   fireAutoConfigurationImportEvents(configurations, exclusions);\n   \n   //返回所有自动配置类\n   return StringUtils.toStringArray(configurations);\n}\n复制代码\n```\n\n### 如何从配置文件读取的（getCandidateConfigurations）\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n      AnnotationAttributes attributes) {\n      //是不是有刚才那个SPI感觉了\n   List<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n         getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n         \n         //通过这个也能看出来 是去读取META-INF/spring.factorie\n   Assert.notEmpty(configurations,\n         \"No auto configuration classes found in META-INF/spring.factories. If you \"\n               + \"are using a custom packaging, make sure that file is correct.\");\n   return configurations;\n}\n复制代码\n```\n\n**getSpringFactoriesLoaderFactoryClass**\n\n```java\nprotected Class<?> getSpringFactoriesLoaderFactoryClass() {\n  return EnableAutoConfiguration.class;\n}\n复制代码\n```\n\n> 结合上一步，就是加载配置文件，并且读取key为EnableAutoConfiguration的配置\n\n**接下来再看loadFactoryNames**\n\n```java\npublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n  String factoryTypeName = factoryType.getName();\n  return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n}\n\nprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\n  try {\n    // FACTORIES_RESOURCE_LOCATION的值为：META-INF/spring.factories\n    // 这步就是意味中读取classpath下的META-INF/spring.factories文件\n    Enumeration<URL> urls = (classLoader != null ?\n                             classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n                             ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n    // 接下来就是读取出文件内容，封装成map的操作了\n    result = new LinkedMultiValueMap<>();\n    while (urls.hasMoreElements()) {\n      URL url = urls.nextElement();\n      UrlResource resource = new UrlResource(url);\n      Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n      for (Map.Entry<?, ?> entry : properties.entrySet()) {\n        String factoryTypeName = ((String) entry.getKey()).trim();\n        for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {\n          result.add(factoryTypeName, factoryImplementationName.trim());\n        }\n      }\n    }\n    cache.put(classLoader, result);\n    return result;\n  }\n  catch (IOException ex) {\n    throw new IllegalArgumentException(\"Unable to load factories from location [\" +\n                                       FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n  }\n}\n复制代码\n```\n\nok， 后面的过滤逻辑就不在这里说了，毕竟本节的重点是自动装配机制，小伙伴明白了原理就ok啦\n\n好的 今天的自动装配原理就讲到这里，我们下期见\n\n## 总结回顾\n\n```\n本篇介绍了关于SpringBoot的自动装配原理，我们先通过SPI机制进行了小小的热身，然后再根据SPI的机制进行推导Spring的自动装配原理，中间还带大家回顾了一下@Import注解的使用，最后成功破案~\n```\n\n最后给张图做下总结\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/9ec02acdcc634a16ae239b684471b8e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n",
                    "title": "SPI 怎么用？"
                  },
                  {
                    "path": "6.实战案例/企业项目最佳实践/判断线程池已完成所有任务.md",
                    "content": "#docs/how-to-guides  #thread \n \n很多场景下，我们需要等待线程池的所有任务都执行完，然后再进行下一步操作。对于线程 Thread 来说，很好实现，加一个 join 方法就解决了，然而对于线程池的判断就比较麻烦了。\n\n我们本文提供 4 种判断线程池任务是否执行完的方法：\n\n1. 使用 isTerminated 方法判断。\n2. 使用 getCompletedTaskCount 方法判断。\n3. 使用 CountDownLatch 判断。\n4. 使用 CyclicBarrier 判断。\n\n接下来我们一个一个来看。\n\n## 不判断的问题\n\n如果不对线程池是否已经执行完做判断，就会出现以下问题，如下代码所示：\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolCompleted {\n    public static void main(String[] args) {\n        // 创建线程池\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 20,\n                0, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024));\n        // 添加任务\n        addTask(threadPool);\n\t\t\t\t// 打印结果\n        System.out.println(\"线程池任务执行完成！\");\n    }\n  \n    /**\n     * 给线程池添加任务\n     */\n    private static void addTask(ThreadPoolExecutor threadPool) {\n        // 任务总数\n        final int taskCount = 5;\n        // 添加任务\n        for (int i = 0; i < taskCount; i++) {\n            final int finalI = i;\n            threadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        // 随机休眠 0-4s\n                        int sleepTime = new Random().nextInt(5);\n                        TimeUnit.SECONDS.sleep(sleepTime);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(String.format(\"任务%d执行完成\", finalI));\n                }\n            });\n        }\n    }\n}\n复制代码\n```\n\n以上程序的执行结果如下： ![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/37cd70ce7fae4afd84574e374237be0c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 从上述执行结果可以看出，程序先打印了“线程池任务执行完成！”，然后还在陆续的执行线程池的任务，这种执行顺序混乱的结果，并不是我们期望的结果。我们想要的结果是等所有任务都执行完之后，再打印“线程池任务执行完成！”的信息。\n\n> 产生以上问题的原因是因为主线程 main，和线程池是并发执行的，所以当线程池还没执行完，main 线程的打印结果代码就已经执行了。想要解决这个问题，就需要在打印结果之前，先判断线程池的任务是否已经全部执行完，如果没有执行完就等待任务执行完再执行打印结果。\n\n## 方法1：isTerminated\n\n我们可以利用线程池的终止状态（TERMINATED）来判断线程池的任务是否已经全部执行完，但想要线程池的状态发生改变，我们就需要调用线程池的 shutdown 方法，不然线程池一直会处于 RUNNING 运行状态，那就没办法使用终止状态来判断任务是否已经全部执行完了，它的实现代码如下：\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 线程池任务执行完成判断\n */\npublic class ThreadPoolCompleted {\n    public static void main(String[] args) {\n        // 1.创建线程池\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 20,\n                0, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024));\n        // 2.添加任务\n        addTask(threadPool);\n        // 3.判断线程池是否执行完\n        isCompleted(threadPool); // 【核心调用方法】\n        // 4.线程池执行完\n        System.out.println();\n        System.out.println(\"线程池任务执行完成！\");\n    }\n\n    /**\n     * 方法1：isTerminated 实现方式\n     * 判断线程池的所有任务是否执行完\n     */\n    private static void isCompleted(ThreadPoolExecutor threadPool) {\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) { // 如果没有执行完就一直循环\n        }\n    }\n\n    /**\n     * 给线程池添加任务\n     */\n    private static void addTask(ThreadPoolExecutor threadPool) {\n        // 任务总数\n        final int taskCount = 5;\n        // 添加任务\n        for (int i = 0; i < taskCount; i++) {\n            final int finalI = i;\n            threadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        // 随机休眠 0-4s\n                        int sleepTime = new Random().nextInt(5);\n                        TimeUnit.SECONDS.sleep(sleepTime);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(String.format(\"任务%d执行完成\", finalI));\n                }\n            });\n        }\n    }\n}\n```\n\n> 方法说明：shutdown 方法是启动线程池有序关闭的方法，它在完全关闭之前会执行完之前所有已经提交的任务，并且不会再接受任何新任务。当线程池中的所有任务都执行完之后，线程池就进入了终止状态，调用 isTerminated 方法返回的结果就是 true 了。\n\n以上程序的执行结果如下： ![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/db029c5e30e94e98b6ba0f611bbcc01d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n#### 缺点分析\n\n需要关闭[[线程池]]。\n\n \n\n## 方法2：getCompletedTaskCount\n\n我们可以通过判断线程池中的计划执行任务数和已完成任务数，来判断线程池是否已经全部执行完，如果**计划执行任务数=已完成任务数**，那么线程池的任务就全部执行完了，否则就未执行完，具体实现代码如下：\n\n```java\n/**\n * 方法2：getCompletedTaskCount 实现方式\n * 判断线程池的所有任务是否执行完\n */\nprivate static void isCompletedByTaskCount(ThreadPoolExecutor threadPool) {\n    while (threadPool.getTaskCount() != threadPool.getCompletedTaskCount()) {\n    }\n}\n```\n\n以上程序执行结果如下： ![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/866c4e96f5d949e9b88ab07bac1c8e93~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n#### 方法说明\n\n- getTaskCount()：返回计划执行的任务总数。由于任务和线程的状态可能在计算过程中动态变化，因此返回的值只是一个近似值。\n- getCompletedTaskCount()：返回完成执行任务的总数。因为任务和线程的状态可能在计算过程中动态地改变，所以返回的值只是一个近似值，但是在连续的调用中并不会减少。\n\n#### 优缺点分析\n\n此实现方法的优点是无需关闭线程池。 它的缺点是 getTaskCount() 和 getCompletedTaskCount() 返回的是一个近似值，因为线程池中的任务和线程的状态可能在计算过程中动态变化，所以它们两个返回的都是一个近似值。\n\n## 方法3：CountDownLatch\n\nCountDownLatch 可以理解为一个计数器，我们创建了一个包含 N 个任务的计数器，每个任务执行完计数器 -1，直到计数器减为 0 时，说明所有的任务都执行完了，就可以执行下一段业务的代码了，它的实现流程如下图所示：\n\n ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/ad72e5add2314796918a8254f6a15751~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 具体实现代码如下：\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 20,\n    \t0, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024));\n    final int taskCount = 5;    // 任务总数\n    // 单次计数器\n    CountDownLatch countDownLatch = new CountDownLatch(taskCount); // ①\n    // 添加任务\n    for (int i = 0; i < taskCount; i++) {\n        final int finalI = i;\n        threadPool.submit(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    // 随机休眠 0-4s\n                    int sleepTime = new Random().nextInt(5);\n                    TimeUnit.SECONDS.sleep(sleepTime);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(String.format(\"任务%d执行完成\", finalI));\n                // 线程执行完，计数器 -1\n                countDownLatch.countDown();  // ②\n            }\n        });\n    }\n    // 阻塞等待线程池任务执行完\n    countDownLatch.await();  // ③\n    // 线程池执行完\n    System.out.println();\n    System.out.println(\"线程池任务执行完成！\");\n}\n复制代码\n```\n\n代码说明：以上代码中标识为 ①、②、③ 的代码行是核心实现代码，其中： ① 是声明一个包含了 5 个任务的计数器； ② 是每个任务执行完之后计数器 -1； ③ 是阻塞等待计数器 CountDownLatch 减为 0，表示任务都执行完了，可以执行 await 方法后面的业务代码了。\n\n以上程序的执行结果如下： ![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/a16af56b8f5b4b49890e524e7cd3166b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n#### 优缺点分析\n\nCountDownLatch 写法很优雅，且无需关闭线程池，但它的缺点是只能使用一次，CountDownLatch 创建之后不能被重复使用，也就是说 CountDownLatch 可以理解为只能使用一次的计数器。\n\n## 方法4：CyclicBarrier\n\nCyclicBarrier 和 CountDownLatch 类似，它可以理解为一个可以重复使用的循环计数器，CyclicBarrier 可以调用 reset 方法将自己重置到初始状态，CyclicBarrier 具体实现代码如下：\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 20,\n    \t0, TimeUnit.SECONDS, new LinkedBlockingDeque<>(1024));\n    final int taskCount = 5;    // 任务总数\n    // 循环计数器 ①\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(taskCount, new Runnable() {\n        @Override\n        public void run() {\n            // 线程池执行完\n            System.out.println();\n            System.out.println(\"线程池所有任务已执行完！\");\n        }\n    });\n    // 添加任务\n    for (int i = 0; i < taskCount; i++) {\n        final int finalI = i;\n        threadPool.submit(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    // 随机休眠 0-4s\n                    int sleepTime = new Random().nextInt(5);\n                    TimeUnit.SECONDS.sleep(sleepTime);\n                    System.out.println(String.format(\"任务%d执行完成\", finalI));\n                    // 线程执行完\n                    cyclicBarrier.await(); // ②\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n}\n```\n\n以上程序的执行结果如下： ![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/0e898282fc734a4e8d937b2a858c46de~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n#### 方法说明\n\nCyclicBarrier 有 3 个重要的方法：\n\n1. 构造方法：构造方法可以传递两个参数，参数 1 是计数器的数量 parties，参数 2 是计数器为 0 时，也就是任务都执行完之后可以执行的事件（方法）。\n2. await 方法：在 CyclicBarrier 上进行阻塞等待，当调用此方法时 CyclicBarrier  的内部计数器会 -1，直到发生以下情形之一：\n   1. 在 CyclicBarrier 上等待的线程数量达到 parties，也就是计数器的声明数量时，则所有线程被释放，继续执行。\n   2. 当前线程被中断，则抛出 InterruptedException 异常，并停止等待，继续执行。\n   3. 其他等待的线程被中断，则当前线程抛出 BrokenBarrierException 异常，并停止等待，继续执行。\n   4. 其他等待的线程超时，则当前线程抛出 BrokenBarrierException 异常，并停止等待，继续执行。\n   5. 其他线程调用 CyclicBarrier.reset() 方法，则当前线程抛出 BrokenBarrierException 异常，并停止等待，继续执行。\n3. reset 方法：使得CyclicBarrier回归初始状态，直观来看它做了两件事：\n   1. 如果有正在等待的线程，则会抛出 BrokenBarrierException 异常，且这些线程停止等待，继续执行。\n   2. 将是否破损标志位 broken 置为 false。\n\n#### 优缺点分析\n\nCyclicBarrier 从设计的复杂度到使用的复杂度都高于 CountDownLatch，相比于 CountDownLatch 来说它的优点是可以重复使用（只需调用 reset 就能恢复到初始状态），缺点是使用难度较高。\n\n## 总结\n\n我们本文提供 4 种判断线程池任务是否执行完的方法：\n\n1. 使用  isTerminated 方法判断：通过判断线程池的完成状态来实现，需要关闭线程池，一般情况下不建议使用。\n2. 使用 getCompletedTaskCount 方法判断：通过计划执行总任务量和已经完成总任务量，来判断线程池的任务是否已经全部执行，如果相等则判定为全部执行完成。但因为线程个体和状态都会发生改变，所以得到的是一个大致的值，可能不准确。\n3. 使用 CountDownLatch 判断：相当于一个线程安全的单次计数器，使用比较简单，且不需要关闭线程池，是**比较常用的判断方法**。\n4. 使用 CyclicBarrier 判断：相当于一个线程安全的重复计数器，但使用较为复杂，所以日常项目中使用的较少。\n\n",
                    "title": "判断线程池已完成所有任务"
                  },
                  {
                    "path": "6.实战案例/企业项目最佳实践/服务端压测怎么做.md",
                    "content": "#test #docs/how-to-guides \n \n可能很多QA、RD同学跟我都一样，对服务端压测一直没有系统的认知，印象停留在使用压测工具如Jmeter对单接口发压，调整线程数和循环数来制造不同压力，最后计算一下TPS和成功率等就完事了？网上虽然有不少压测相关的文章，但多数是压测工具的入门级使用，有的是压测流程和指标的简单解释，或者就是几个大厂牛逼的[[全链路压测]]能力和压测平台的介绍。这些文章要不缺少系统性阐述，要不过于抽象不好理解，对没怎么接触过压测的同学不太友好。\n\n本文尝试在QA角度梳理一次完整的压测过程，尝试总结更为普适的压测思路，给大家提供更有意义的参考。\n\n------\n\n## 压测背景\n\n测试分很多种，网上很多文章[[1\\]](https://juejin.cn/post/6844904147729252366#fn1)会玩弄概念，搬出来3个名词：压力测试（Stress Testing）、性能测试（Performance Testing）、负载测试（Load Testing）。一般情况下并不需要做这么细粒度的概念区分，这3个概念我觉得是没办法完整区分各自边界的，至少在程序逻辑上难以做得到，更多差异只是来自于不同的压测策略，所以尽管忽略这几个概念的区别，都叫它压测或者性能测试即可。\n\n### 为什么需要压测\n\n拿技术人熟知的阿里举例，应该是国内做压测最好的一个大厂。外界熟知的阿里2012双11活动，2012年11月11日零点，阿里各种系统报错、立刻下单报错、购物车支付报错、支付系统报错、购物车的东西丢失，系统显示交易成功率不到50%，产生了大量超卖，给阿里带来很大的损失。那一年的双11后，库存、商品、退款和相应数据库的同学，为了处理超卖导致的问题，没日没夜加了两周的班，同时给了用户不少糟糕购物体验。\n\n为什么出现这么严重的问题？因为对整个全交易链路上的各个子系统的承受能力不清楚，并且错误预估了可能会达到的流量，也没有完善的预案，兵败如山倒。\n\n2013年阿里首次提出了全链路压测方案：一方面可让链路的各个系统知道自己的承压极限；另一方面可让各个系统有个明确的优化目标，了解到整个链路的瓶颈并评估资源情况。\n\n### 单系统压测与全链路压测\n\n为什么只做单系统压测还不够呢？\n\n在活动开始的瞬间，各系统都面临自身服务的巨大的压力，而系统之间是有互相依赖关系的，单机压测没有考虑到依赖环节压力都比较大的情况。一个系统出现故障，故障会在链路流转过程中层层累加，会造成无法评估的影响。\n\n所以最可靠的方式是完全模拟真实场景来压测，通过线上全链路压测提前发现问题。\n\n### 压测流程\n\n完整的压测流程一般包含下面几个步骤，引用自[文末参考资料](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F721643)：\n\n1. 压测目标的制定\n2. 压测链路的梳理\n3. 压测环境的准备\n4. 压测数据的构造\n5. 发压测试\n6. 瓶颈定位及容量微调\n7. 压测总结\n\n\n\n![常规压测流程](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/171db0b32ecc8ba0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n\n\n------\n\n## 压测目标\n\n### 压测作用\n\n- 新服务，无预估目标，需要通过压测得到服务基准数据或找到系统瓶颈进行优化\n- 有明确的压测目标，需要通过压测确定服务的各项指标是否达标\n- 常态化压测，为后期性能优化指导方向或提供参考依据\n\n### 压测指标\n\n列举一些常用指标，并不一定都需要关注，根据业务考虑指标的细化粒度。\n\n- QPS：Query Per Second，每秒处理的请求个数\n- TPS：Transactions Per Second，每秒处理的事务数，TPS <= QPS\n- RT： Response Time，响应时间，等价于Latency RT分平均延时，Pct延时（Percentile分位数）。平均值不能反映服务真实响应延时，实际压测中一般参考Pct90，Pct99等指标\n- CPU使用率：出于节点宕机后负载均衡的考虑，一般 CPU使用率 < 75% 比较合适\n- 内存使用率：内存占用情况，一般观察内存是否有尖刺或泄露\n- Load指标：CPU的负载，不是指CPU的使用率，而是在一段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，表示CPU的负载情况，一般情况下 Load < CPU的核数*2，更多参考[链接1](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2011%2F07%2Flinux_load_average_explained.html)和[链接2](https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F02825a66e46f)\n- 缓存命中率：多少流量能命中缓存层（[[../../redis|redis]]、memcached等）\n- 数据库耗时：数据库就是业务的生命，很多时候业务崩掉是因为数据库挂了\n- 网络带宽：带宽是否瓶颈\n- 接口响应错误率 or 错误日志量\n\n这里要说明一下QPS和TPS的区别：\n\n- QPS一般是指一台服务器每秒能够响应的查询次数，或者抽象理解成每秒能应对多少网络流量\n- TPS是指一个完整事务，一个事务可能包含一系列的请求过程。举个🌰，访问一个网页，这是一个TPS，但是访问一个网页可能会对多个服务器发起多次请求，包括文本、js、图片等，这些请求会当做多次QPS计算在内，因为它们都是流量\n\n性能测试中，*平均值的作用是十分有限的*，平均值代表前后各有50%的量，对于一个敏感的性能指标，我们取平均值到底意味着什么？是让50%的用户对响应时间happy，但是50%的用户感知到响应延迟？还是说50%的时间系统能保证稳定，而50%的时间系统则是一个不可控状态？\n\n平均响应时间这种指标，只有在你每次请求的响应时间都是几乎一样的前提下才会有一样。再来个例子，人均财富这个概念有多沙雕相信大家也明白，19年有个很搞笑的新闻——[腾讯员工平均月薪七万](https://link.juejin.cn/?target=http%3A%2F%2Ffinance.sina.com.cn%2Froll%2F2019-05-16%2Fdoc-ihvhiqax9049380.shtml)，明白平均值多不靠谱了吧😂。下图是现实世界中一个系统的响应时间柱状图，RT在前20%的请求数较少，但是因为耗时特别短（拉高了均值可能是命中缓存，也可能是请求的快速失败），而大多数RT是在均值之下，那才是系统的实际性能情况。\n\n\n\n![均值并不能反映实际情况，引用自：https://www.dynatrace.com/news/blog/why-averages-suck-and-percentiles-are-great/](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/171db0b3bed1badb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n\n\n所以说，我们不应看最好的结果，相反地，应该控制最坏的结果，用户用得爽他不保证会传播好口碑，但是用户用到生气他保证变为键盘侠肆意大骂，这也是为什么平均值无法带来足够的参考，因为happy的结果蒙蔽了我们的双眼，平均值在压测中丢失太多信息量。\n\n总结一下，较为科学的评估方法应该将`指标-成功率-流量`三者挂钩在一起的：\n\n> xx%的响应在xx毫秒内返回，其中成功率为xx%。\n\n根据这个方针，可以得到一些测试思路：\n\n1. 在响应时间的限制下，系统最高的吞吐量（这里不对吞吐量做严格定义，当成是QPS或TPS即可）\n2. 在成功率100%的前提下，不考虑响应时间长短，系统能承受的吞吐量\n3. 容忍一定的失败率和慢响应，系统最高能承受的吞吐量（95%成功率，前95%的请求响应时间为xx毫秒时的最大QPS）\n4. 在上面的场景下还要考虑时间和资源，比如最高吞吐量持续10分钟和持续1小时是不一样的，不同的时间持续长度下，机器资源（cpu、内存、负载、句柄、线程数、IO、带宽）的占用是否合理\n\n### 目标预估\n\n压测开展前是需要有目标的，也就是有期望的性能情况，希望接口或系统能达到的性能预期，没有目的的压测是浪费人力，下面给出几种目标预估的方法。\n\n#### 历史监控数据\n\n已经上线并且有历史监控数据的接口，可以查看历史数据，找出峰值QPS和PCT99。🌰 若接口A已经上线并且做了监控，在经过某次大活动或者上线时间足够长后，存量监控数据就可以使用了。\n\n#### 类比\n\n新接口或者线上未监控的接口，不存在历史数据，但存在类似功能接口的历史监控数据，可以通过类比得出压测的目标。🌰 假设上一年淘宝双十一下订单接口QPS=x，RT=y，这一年天猫平台整起来了，双十一活动与上年淘宝双十一活动场景类似，也沿用QPS=x，RT=y的目标（例子不严谨，理解即可）。\n\n#### 估算\n\n新接口或者线上未监控的接口，不存在历史数据，且不存在类似功能接口的数据可供参数考，此时需要估算峰值，常用方法有`8/2原则`——一天内80%的请求会在20%的时间内到达。\n\ntop QPS = (总PV * 0.8) / (60 * 60 * 24 * 0.2)\n\nRT如无特殊要求，一般采用默认值：\n\n- 单服务单表类，RT<100ms\n- 较复杂接口，RT<300ms\n- 大数据量或调用链较长的接口，RT<1s\n\n🌰-1 电商秒杀活动，预估同时有1000w人参与，简单起见假设总QPS是1000w。由于前端不同的秒杀倒计时形式使得请求有2s的打散，再加上nginx等webserver做了20%几率拒绝请求的策略，所以下单接口总QPS = 1000w / 2 * (1 - 0.2) = 400w/s，最终压测目标为400w/s的QPS。\n\n🌰-2 电商全天低价抢购活动，屠龙宝刀，点击就送，一刀99级，emmmmm跑题了。根据8/2原则，预估在午休（12-1）和晚上下班后（7-10）共4h是流量高峰，估算接口峰值QPS = 活动全天接口PV / (4*3600s)。\n\n#### 其他\n\n除了前面说到的情况，肯定还有一些我们无法下手的三无接口，无参考、无预估、无历史数据，这时候只能一点一点来，慢慢把压力提上去的同时收集数据，最终得出接口的最优处理能力。\n\n\n\n![常见性能折线图](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/171db0b40cbc0832~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n\n\n------\n\n## 压测准备\n\n### 压测场景\n\n压测是有目的的压测，也就是说不是随便找些接口发一通压力，而压测全部的接口也是做不到的或者说无意义的，得有压测的优先级，所以梳理压测场景是很重要的。高优场景主要有下面几个：\n\n1. 高频业务场景（今日头条首页下拉刷新）\n2. 关键业务场景，使用频率低，一旦出问题就很严重（微信账号登录）\n3. 性能高消耗场景（淘宝下单）\n4. 曾经出现过问题的场景\n\n压测有分单接口压测和场景化压测，前者会简单一些，后者一般是多个接口混合操作以组成一个业务场景，两者在方法上是相通的。\n\n梳理场景时QA需要与RD对齐，确认不同接口的RD负责人、需要压测的接口、系统性能现状以及压测目标；在确定每个接口的压测目标时，要考虑到压测对象是单实例单机房还是集群；在细节上也要确认是单接口压测还是场景化压测，每个接口的流量占比以及优先级，需不需要发足够的压力来触发系统的自动扩容或降级等更进一步的运维能力。\n\n### 压测环境\n\n在梳理完压测场景后，就要确认压测链路是否完整或符合预期。从一个服务到另一个服务，是不是链路上每一个服务都要压到？下游服务如审计安全等是不是已经考虑到？压测过程中产生的脏数据是否会影响线上数据？可能还要细化到具体下游某个服务不参与压测，如何处理呢？以上种种问题，可能需要推动整个链路相关的业务方进行对应业务改造来适配压测流量，改造完后还要自测验证才能正式开始压测，下面讲一些重点问题，部分内容引用自[文末的参考资料][全链路压测的大概思路]。\n\n脏数据问题\n\n- 如果是在独立的一套环境中操作，不存在该问题\n- 影子表：如果是在线上操作，一般将数据写入影子表（与原数据表在schema上一致的不同名表）而非原数据表，实现压测数据与线上数据隔离\n- 白名单：指定测试id或者测试账号，在入库后通过统一id区分压测数据，统一处理\n- 各类存储层的压测改造，包括缓存层、消息队列、离线数据库等隔离问题。常规方法在压测链路中透传压测标记（也叫流量染色，挺形象的），比如json数据中加`is_stress`标记，存储层根据标记区分压测流量，对压测数据添加指定前后缀再入库等特殊处理\n\n不参与压测的服务如何处理\n\n- mock server：通过录制request和response的方式，对业务的代码实现无侵入\n- 服务stub：针对压测流量做处理，类似单测stub，代码stub模拟服务返回response，需要修改代码\n\n\n\n![主流的业务架构压测图，引用自：https://lishoubo.github.io/2018/07/15/全链路压测的大概思路/](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/171db0b459a44d0b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n\n\n可以独立部署一套线下环境进行压测。在不影响线上环境的前提下，确保机房，网络，存储，上下游服务与线上保持一致，部署一套独立的环境进行测试，机器与线上隔离，机器出问题不会影响线上。这种方式压测只是针对较少的几个系统进行，因为很难把整个链路所有系统都独立再部署一套，所以应用范围有限。\n\n> 备注：上游、下游如何定义？ [RFC 2616](https://link.juejin.cn/?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc2616%23section-1.3)\n>\n> Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.\n>\n> 下游的输入来自于上游的输出，假设有服务A、B，A调用了B（或者说A依赖B），那B就是A的上游，A就是B的下游，因为A的输入来自于B的输出（A调用了B，获取B的输出）。\n>\n> 更简单地理解，越接近用户的东西，越是下游。\n\n更常见的方法是直接使用线上环境压测，在机器负载低的时间段（如深夜）人工发起或定时发起压测。\n\n### 压测监控体系\n\n确认好压测流程的技术支持和Mock数据的支持后，还要确认压测链路的监控体系是否完整，一来方便在压测过程中及时发现问题，二来是为了积攒历史压测数据，三来顺便确认监控系统本身是否可靠且全部到位。一般监控项包括（也就是压测指标）：\n\n- 核心接口和核心依赖的流量、响应耗时、成功率\n- 消息队列、缓存、数据库\n- 机器物理资源\n\n### 压测数据\n\n压测数据其实没什么神秘的，网上说什么按照业务模型产出数据，表达上做了过度抽象反而不好理解，其实意思就是按照业务核心场景将所需要的数据构造出来。关键是要如何科学地模拟线上数据分布，引用[文末参考资料](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F721643)，阿里双十一大促中有如下的业务流量漏斗模型，需要给不同场景科学地分配流量比例，这个比例是分析出来的而不是拍脑袋的。可以想象，阿里大促的流量不可能全部最后都走到付款流程，必然很多流量会在前面的流程就结束了，也就意味着，你把全部压测数据都构造成【走到付款场景】的话，你的压测结果是不准确的。\n\n\n\n![阿里大促业务流量漏斗图](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/171db0b4a66339a9~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n\n\n为了更好模拟线上真实的用户使用场景和数据，dump线上数据用来压测是很常见的手段，有两种简单思路：\n\n- 直接回放提前录制的线上流量到压测链路\n- 将现成流量copy一部分引流到压测链路\n\n数据dump下来是不能直接用的，一来没加压测标记会污染线上数据，二来涉及用户隐私数据。可以将线上数据作为数据源，经过采集、过滤、脱敏等操作后转变为压测数据，注意点有：\n\n1. 确保数据已添加压测标记\n2. 账户数据要提前完成登录认证等准备工作\n3. 数据要尽可能跟真实数据保持一致，比如，价格，图片等\n4. 数据是否有不同设备型号等特殊要求\n5. 尽量保持和线上相同缓存的命中率\n6. 其他业务特性上的特殊要求……\n\n------\n\n## 压测过程\n\n基本思路跟做质量保障是一样的，从细粒度开始慢慢集成到整个大系统，就像`单测->接口测试->集成测试`，压测也是先从简单的开始，一步一步走向全资源全链路，可以参考过程：`单接口单机->单接口1/4资源->场景化1/4资源->全量资源压测->拨测`。\n\n### 单接口单机\n\n在单核（或物理资源少）机器上部署单个服务，排除外部链路、网络等因素，得出自身服务的单核性能情况（单位QPS/core），后续根据此单核性能指标结合压测目标值进行扩容。另外由于是压的单接口单机，无其他接口请求影响，上下游在足够资源的情况下也不会造成瓶颈，所以能确保服务的性能真实值。\n\n单接口单机可以在正式开始大规模压测前提前发现问题，方便RD做针对的性能优化并快速检验优化效果。一部分问题会先在单接口单机压测环节中发现，而一些隐藏得更深的问题，需要延后到全链路大流量压测才能暴露。\n\n### 单接口1/4资源\n\n单接口单机压测环节，服务端已经完成了部分性能优化，接下来可以进入单接口1/4资源压测，这样是为了验证在单接口单机压测中得到的单核性能数据，在扩容1/4资源下性能是否会线性增长，是否存在性能损耗以及定位损耗源。\n\n### 场景化1/4资源\n\n单接口压测局限很明显，场景化压测由于引入了上下游服务的其他接口的因素，可以发现单接口压测无法发现的问题，更接近线上用户场景。\n\n### 全量资源全链路\n\n全部资源到位后，预估的线上压力是否能承受，这一步也是内网压测过程的最后一步。\n\n### 拨测\n\n除了做内网压测，还要进行拨测验证用户从客户端到服务端的整个带宽资源是否满足预期，内网压测已经确认了业务性能是否达标，因此拨测可以只选择了一个场景进行验证即可。（简单来说拨测相当于压测cdn，检查各地cdn节点资源是否充足）\n\n### 压测策略\n\n压测过程也要提前规划好，然后加入一定的人工策略调整。阿里大促还会有预热环节，预先跑一部分流量使得该缓存的数据提前缓存起来。正式压测时细分有几种压测策略，引用自[文末参考资料](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F721643)：\n\n- 峰值脉冲：流量是逐渐变大的一个小坡，还是骤升后保持高峰\n- 系统摸高：关闭熔断降级限流等fallback功能，提高压力观察系统性能转折点\n- fallback策略验证：开启熔断限流等fallback功能，这些功能是否生效，系统是否还能扛得住\n- 破坏性测试：主要为了验证预案的有效性，类似于容灾演练时的预案执行演练，验证后手抢救方案\n\n除了关注前面讲到的指标外，还需要关注各机房流量是否均匀（若不均匀要确认负载均衡是否work）。\n\n------\n\n## 压测收尾\n\n发压环节的结束并不代表压测就到此为止。\n\n### 数据清理\n\n如果使用了影子表，可能收尾工作会简单一些，只需要下掉影子表即可。如果数据直接落到了线上数据库，可能一大堆压测数据要清理，压测时会对数据染色（比如指定测试账号或流量携带压测标记），逐层透传，最后根据标志识别删除。\n\n### 常见问题\n\n举例一些可能会发现的典型问题：\n\n1. 存在多余的http header，导致额外带宽占用\n2. spin_lock对RT影响大，优化锁的方式\n3. 调整nginx worker数量可提高性能\n4. 不恰当的长链接数\n5. 代码实现上对象没有较好复用\n6. cache命中率不符预期\n7. 业务流程上存在冗余\n8. 缺少一层cache\n9. 响应码or错误码可能要继续规范\n10. 下游服务资源不足（其他监控、存储）\n11. 内部系统对压测的限流，需要变更配置或者协商解除限制\n\n……\n\n------\n\n## 压测总结\n\n给出一个完整的压测过程例子：\n\n1. 确定本次的压测目标，预估各项指标的达标值\n2. 根据服务接口的优先级和使用场景，确认出需要压测的接口\n3. 梳理压测链路上的服务，确认链路完整性\n4. 针对压测链路设计的服务进行压测改造\n5. 准备压测数据，确认压测策略\n6. 开始压测，监控各项指标，多轮压测检验性能优化效果\n7. 压测环境清理\n8. 压测总结报告输出\n\n压测最终应该输出一份报告总结，其实也就是把整个压测方案、过程、结论记录下来，写明压测目标、压测接口、压测数据、压测结论，给出发现的问题并提供优化方案。往往在压测报告完成时，性能问题已经基本被解决了，报告的意义在于梳理前面的整个流程，给后续的压测提供经验指导。\n\n------\n\n## 参考资料\n\n[Why Averages Suck and Percentiles are Great](https://link.juejin.cn/?target=https%3A%2F%2Fwww.dynatrace.com%2Fnews%2Fblog%2Fwhy-averages-suck-and-percentiles-are-great%2F)\n\n[CoolShell-性能测试怎么做](https://link.juejin.cn/?target=https%3A%2F%2Fcoolshell.cn%2Farticles%2F17381.html)\n\n[全链路压测的大概思路](https://link.juejin.cn/?target=https%3A%2F%2Flishoubo.github.io%2F2018%2F07%2F15%2F%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E7%9A%84%E5%A4%A7%E6%A6%82%E6%80%9D%E8%B7%AF%2F)\n\n[独家揭秘 | 阿里怎么做双11全链路压测？](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F721643)\n\n[亲历流量尖峰时刻：一名阿里技术员工的双11十年](https://link.juejin.cn/?target=https%3A%2F%2Fm.huxiu.com%2Farticle%2F271340.html)\n\n[What is Upstream and Downstream in Software Development?](https://link.juejin.cn/?target=https%3A%2F%2Freflectoring.io%2Fupstream-downstream%2F)\n\n[一个阿里技术男经历的六年“双11”：技术改变阿里](https://link.juejin.cn/?target=https%3A%2F%2Fm.huxiu.com%2Farticle%2F270730.html)",
                    "title": "服务端压测怎么做"
                  },
                  {
                    "path": "7.公司事宜/中科泰岳/他人简历/技术简历.md",
                    "content": " #resume  #docs/tutorials \n# 技术简历\nhttps://www.bilibili.com/video/BV16q4y1n7Fd?p=72&spm_id_from=pageDriver&vd_source=ca0ebcf87af35e0804e0df7cb43b9758\n\n![image-20220615001951099](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220615001951099.png)\n\n![image-20220615002002445](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220615002002445.png)\n\n![image-20220615002122194](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220615002122194.png)\n\n![image-20220615002142055](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220615002142055.png)\n\n![image-20220615002202383](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220615002202383.png)",
                    "title": "技术简历"
                  },
                  {
                    "path": "7.公司事宜/中科泰岳/面试题/后端面试问题.md",
                    "content": "#interview  #docs/how-to-guides  #java \n\n\n核心点:\n\n1. 当前工作能力。\n2. 学习能力。\n3. 协作能力。\n\n面试题目：\n\n[https://javaguide.cn/](https://javaguide.cn/)\n\n[https://github.com/doocs/source-code-hunter?utm_source=gold_browser_extension](https://github.com/doocs/source-code-hunter?utm_source=gold_browser_extension)\n\n根据经验来判断应该具有的基本水平，来确认是否超出或者低于预期\n\n三个问题选人:\n\n1. 你过去做过什么成功的项目?  能够描述清项目，并了解自己的职责，并解决了困难的事。\n2. 假如重新让你去解决你之前遇到的问题，有没有改进方案?\n3. 你认为服务端开发未来 5 到 10 年会有什么变化?\n\n---\n\n根据简历项目聊一些具体的技术细节.\n\n重点考察点: \n\n## 算法\n\n## JAVA 基础\n\n### 字符串\n\n1、解释一下发生了什么,越详细越好\n\n```\npublic class DemoString {\n   public static void main(String[] args) {\n     String st1 = new String(\"abc\");\n     String st2 = \"abc\";\n     String st3 = \"a\" + \"b\" + \"c\";\n     String st4 = \"ab\";\n     String st5 = st4 + \"c\";\n     \n     System.out.println(st1 == st2);\n     System.out.println(st1.equals(st2));\n     \n     System.out.println(st2 == st3);\n     System.out.println(st2.equals(st3));\n     \n     System.out.println(st2 == st5);\n     System.out.println(st2.equals(st5));     \n   }\n}\n```\n\n---\n\n考察点:\n\n1. 编译原理\n2. 常量静态化\n3. 内存模型\n\n答案：false 和 true\n\n判断结果输出false，两者不相等。​==比较的st1和st2对象的内存地址，由于st1指向的是堆内存的地址，st2看到“abc”已经在常量池存在，就不会再新建，所以st2指向了常量池的内存地址，所以==\n\n第二个​[equals](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247491299&idx=2&sn=a0f523badfd3a1997bb89296cd78393d&chksm=eb539bd5dc2412c3304e7099328782529122564afff7ba22246df3b33aced5209de7c9df9305&scene=21#wechat_redirect)比较，比较是两个字符串序列是否相等，由于就一个“abc”，所以完全相等。\n\n```\npublic class Demo2_String {\n \n   public static void main(String[] args) {\n     String st1 = \"a\" + \"b\" + \"c\";\n     String st2 = \"abc\";\n     System.out.println(st1 == st2);\n     System.out.println(st1.equals(st2));\n   }\n}\n```\n\n答案是：true 和 true \n\n```\npublic class Demo2_String {\n \n   public static void main(String[] args) {\n     String st1 = \"ab\";\n     String st2 = \"abc\";\n     String st3 = st1 + \"c\";\n     System.out.println(st2 == st3);\n     System.out.println(st2.equals(st3));\n   }\n}\n```\n\n答案：false 和 true\n\n原因 + 仅当连接 char 时才会判断是否在常量池\n\n### 类加载\n\n解释一下下面会发生了什么\n\n```\npackage com.a.b;\n \n\npublic class String{\n    public static void main(String[] args){\n        Class<String> stringClass = String.class;\n        System.out.println(\"com.example.demo.model.String的类加载器：\" + stringClass.getClassLoader());\n        System.out.println(\"com.example.demo.model.String的类名：\" + stringClass.getName());\n    }\n}\n```\n\n```\ncd com/a/b\njavac String.java\njava -cp . com.hello.String\n```\n\nError: Could not find or load main class String\n\nCaused by: java.lang.NoClassDefFoundError: com/example/demo/model/String (wrong name: String)\n\n---\n\n参考答案:\n\n会报找不到 main 方法. 原因是 String 被覆盖.\n\n### IO\n\n说说你对 IO 的理解? 为什么会有这么多 IO 形式? 原因是什么? 有哪些中间件或库是相同的功能,但仅仅是 IO 处理的不同?\n\n---\n\n### 数据一致性\n\n 什么是锁？从根上讲它是怎么实现的 ？\n\n锁的本质是什么, 锁的实现需要硬件支持吗? \n\n考察点:\n\n1. 操作系统\n2. 硬件\n\n### 事务\n\n以下代码在高并发下有问题么? 事务的开启是在 lock 前还是 lock 后? 事务的提交是在 unlock 前还是 unlock 后?\n\n```\n@Service\npublic class OrderSerice {\n    public Lock lock = new ReentrantLock(true);  \n    @Transactional \n    public Result func(long seckillId, long userId){     \n        lock.lock();\n        // busineess \n        // 数据库操作， 查询商品数量\n        // 如果数量 ok， 数据库减少库存\n        lock.unlock();\n    }\n}\n```\n\n---\n\n事务的启动有哪些方式呢？\n\n* 第一种：使用启动事务的语句，这种是显式的启动事务。比如 begin 或 start transaction 语句。与之配套的提交语句是 commit，回滚语句是 rollback。\n* 第二种：autocommit 的值默认是 1，含义是事务的自动提交是开启的。如果我们执行 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。\n\n很显然，在 Spring 里面采用的是第二种方式。\n\n前面说的 begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才算是真正启动。\n\n如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。需要注意的是这个命令在读已提交的隔离级别（RC）下是没意义的，和直接使用 start transaction 一个效果。\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1656045295621-0e57dd19-dcc6-4bf4-8e33-4a357394bd66.png)​\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1656045324631-113c11c1-5897-4c7f-bff8-133ba1dfbfe1.png)​\n\n事务开启时机, 是在执行第一条操作 InnoDB 的语句.  所以在 lock.lock() 后. \n\n除非 使用 start transaction with consistent snapshot 这个命令。需要注意的是这个命令在读已提交的隔离级别（RC）下是没意义的\n\n而事务提交时机, 是在 unlock 后.\n\n哪怎么解决以上问题呢?\n\n```\n@Transactional \npublic void lockProduct(){\n    try {\n        lock.lock();\n        sellProduct();\n    } finally {\n        lock.unlock();\n    }\n}\n\n@Transactional\npublic void sellProduct(){\n    // business \n}\n```\n\n如果是以上方案, 哪说说什么场景下事务会失效?\n\n### out of box\n\n为什么 service 要用接口, 不用可不可以？\n\n### \n\n### 网络\n\n当连接 https://www.baidu.com 连接时, 发生了什么?  有什么办法修改报文吗?\n\n考察点:\n\n1. http 原理\n2. 对称加密与非对称加密原理\n3. 网络安全机制\n4. ‍\n\n事务本质上是要解决什么问题？\n\n数据一致性问题\n\n### Spring 基础\n\n1. Sping getBean 时发生了什么? \n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1656904380278-bc720b68-ac77-4e90-bff8-e2d57a23b282.png)​\n\n## 分布式基础\n\n### 数据一致性\n\n分布式锁怎么保障生效，要解决哪些问题？\n\n---\n\n能不能列举一下你觉得计算机里哪些技术属于解决数据一致性的问题？\n\n锁，zookeeper，tcp 协议。raft 协议， paxos 协议。mysql 里的缓存。\n\n---\n\n你知道哪些分布式解决方案，它们各自区别是什么？\n\nxt， tcc，saga，最终一致性。\n\n假如让你来做一个分布式的方案，你会怎么做？ （如果利用已存在的库，请说明它的原理，具体要解决哪些问题）\n\n能用本地事务解决分布事务的问题吗? 现实中有没有可以类比的场景?\n\n怎么设计分布式缓存？\n\n1. 高可用  CAP 用哪两\n2. 高性能（数据结构，IO）\n3. 可伸缩\n\n伸缩时怎么保障缓存最小失效. 怎么保障数据库在伸缩时不受太大影响.\n\n### \n\n### 消息队列\n\n消息, 消息系统的作用是什么, 优点与缺点是什么?\n\n（根据不同的队列，答案不同，以kafka举例）\n\n1.  如何防止消息丢失  \n    a. 生产者：保障投递，一定要拿到ack。而 broker 的 ack 机制设成1 或者 -1/all。 min.insync.replicas 配置成分区备份数。 实在有漏网之鱼，人工介入。  \n    b. 消费者： 改自动提交为手动提交\n2.  如何防止重复消费：[https://segmentfault.com/a/1190000039737646](https://segmentfault.com/a/1190000039737646)  \n    a. 生产者：  \n    ⅰ. 有可能重复投递。比如，broker 收到了消息，但通知生产者失败。 生产者又重试，收到多条重复消息。  \n    b. 消费者：  \n    ⅰ. 要解决幂等问题，（只考虑C， 不考虑RUD）\n\n    1. 消息要带业务code。先查再创建。 （ 不适合高并发场景）\n    2. 加悲观锁，比如在支付中f'f .. for update 锁住用户。 （ 不适合高并发场景）\n    3. 加乐观锁\n    4. 加唯一索引\n    5. 建防重表，有些时候并非所有场景下不允许重复数据。\n    6. 通过分布式锁，不存在业务code时，锁住业务 code 一段时间。防重。\n    7. 服务端分发token。\n3.  如何做到顺序消费 （场景不多，rocketMQ有专门设计，kafka只能说能实现）  \n    a. 生产者：需要保证按顺序发送到一个分区，同步发送，必须ack  \n    b. 消费者：保证只消费某个分区\n4.  如何解决消息积压，kafka 比较狗，举个例子， 1个topic下 2 分区积压了1亿条  \n    a. 单机加多线程  \n    b. 增加搞性能消费组处理最新消息。  \n    c. 历史消息中转，为何要这样搞呢，为何不直接增加消费组呢？因为kafka 一个分区只能由一个消费组里的消费者消费，单机如果性能就这样了，必须要想办法扩充分区。（这个方案其实不常用，非常麻烦）  \n    ⅰ. 创一个新 topic，多搞些分区，比如200个。  \n    ⅱ. 整一个新消费组，对旧topic做转发到新topic。  \n    ⅲ. 再整一个消费组，处理新topic。\n5.  延时队列 (kafka 做不合适）  \n    a. 创建多个topic，每个topic 只负责一段时间延迟。\n\n## 架构能力\n\n你是怎么看 ddd 这种架构设计？ 你觉得它的好处与坏处在哪？ 它的使用场景又在哪？\n\n单体与微服务基于什么做选择,  如果是微服务形式, 解决了哪些问题, 会遇到哪些问题. 这些问题又都是怎么解决的? \n\n你会怎么设计统一接口返回?  是 json 里包 code 还是? 有什么优缺点?\n\n站在技术管理者的角度, 怎么保障开发人员的代码质量.\n\n## 学习能力\n\n面对各种后端技术, 你会有学不完的感觉么? 如果没有, 你是怎么克服的?\n\n## 业务能力\n\n如果现在是微服务架构, 现在有订单, 支付, 库存, 商品服务, 秒杀场景如何设计?\n\n综合考察点:\n\n1. 对状态机的了解\n2. 对分布式事务的考量(分布式事务)\n3. 对全局锁的了解\n4. 对性能的考量, 能与会 benchmark\n5. 对异步处理的设计\n6. 对于数据库的设计\n\n如果在此电商系统上加上优惠券的功能,  你会怎么设计?\n\n考察点:\n\n1. 动态业务设计\n2. 规则引擎的了解\n\n## 参考\n\n[https://z.itpub.net/article/detail/18A4D9564A61EC7AF8EAA66FCA251444](https://z.itpub.net/article/detail/18A4D9564A61EC7AF8EAA66FCA251444)\n\n[https://github.com/Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)\n\n---\n\n[https://blog.csdn.net/Doit_kang/article/details/107159232](https://blog.csdn.net/Doit_kang/article/details/107159232)\n",
                    "title": "后端面试问题"
                  },
                  {
                    "path": "7.公司事宜/中科泰岳/项目/3.海昌会员项目/标书问题.md",
                    "content": "#zkty/project/haichang  #docs/bidding \n\n## 内部咨询问题\n\n## 问题汇总\n\n1. 数据库规模. QPS 数量级, TPS 数量级?\n2. 运维环境? 是裸机还是k8s? \n3. 有没有必须要用的集团中间件或服务? 如缓存, MQ, CDN 等\n4. 标书\n   1. 第二章技术标要求: 项目总体目标与范围中：    年卡系统、商餐系统对接方式：是否是指我们提供接口，由外部系统调用?\n   2. 第二章技术标要求: 项目目标范围: 系统实现：　用户接受测试脚本指什么？\n   3. 第二章技术标要求: 项目目标范围: 上线支持：　年卡会员系统知识转移 指什么?\n\n\n产品侧:\n\n1. 是否要和集团主数据对接，运营端的人员和组织数据是有来源还是自管。\n\n   \n\n## 甲方技术要求\n\n后端:\n\n- 系统采用主流技术架构，阐述年卡会员项目建设方案，方案应包括现状分析、总体方案设计及关键设计。\n\n客户端:\n\n- 支持至少微信生态体系发布小程序；\n\n权限控制:\n\n- 支持基于集团化组织架构的权限控制，集团总部—项目公司—商店三级权限；\n- 支持菜单级、按钮级的操作权限控制；\n- 支持机构控制机构以下所有权限、参数设置；\n- 支持角色权限==一键复制==、批量授权等功能；\n\n运维:\n\n- 提供测试环境，方便后续系统升级和系统对接等测试工作。\n- 私有化部署方案\n\n测试:\n\n- 提供压力测试、性能测试、==安全性测试==等质量保证手段证明；支持系统扩展性，\n\n\n监控:\n- 提供生产环境的监控，包括应用（中间件）和数据库。\n\n## 乙方文档输出\n\n### 技术偏离表\n\n| 序号 | 技术 & 功能要求序号 | 技术 & 功能要求规格                                          | 软件商技术 & 服务规格                    | 偏离   | 说明 |\n| ---- | ------------------- | ------------------------------------------------------------ | ---------------------------------------- | ------ | ---- |\n|      | 技术要求.1          | 系统采用主流技术架构，阐述年卡会员项目建设方案，方案应包括现状分析、总体方案设计及关键设计 |                                          |        |      |\n| 1    | 技术要求.2          | 应用软件系统应建立在成熟的应用软件开发平台上，软件源代码可以开放或支持甲方对软件进行二次开发，以适应业务快速变化的需要。 | 基于spring cloud / alibaba cloud　开发。 | 无偏离 |      |\n| 2    | 技术要求.3          | 软件系统应采用主流的架构方案，具备稳定性、高可用性和可扩展性。 | 采用　ddd　软件架构设计。                |        |      |\n|      | 技术要求.4          | 应准确理解本项目业务需求，有文旅、新零售、电商行业相关信息系统建设经验，且能提供用户证明材料。 |                                          |        |      |\n| 4    | 技术要求.5          | 软件系统使用SQLSERVER、ORACLE、MYSQL等中大型 DBMS；（商业数据库应有原厂授权）；支持对数据库版本升级。 | MYSQL 5.7                                | 无偏离 |      |\n|      |                     | 满足甲方私有化部署的需要，并免费提供私有化部署服务及技术支持，明确操作系统、硬件、网络等支持环境 |                                          |        |      |\n| 4    |                     | 提供生产环境的监控，包括应用（中间件）和数据库。             | 基于　Druid　监控数据库。                |        |      |\n| 5    |                     | 支持至少微信生态体系发布小程序                               | 基于　Taro　开发相关小程序               |        |      |\n| 6    |                     | 提供压力测试、性能测试、安全性测试等质量保证手段证明；支持系统扩展性，免费提供标准产品接口清单及技术文档 | 将提供 JMeter　测试脚本。                |        |      |\n| 7    |                     | 签订合同后，任何时期我公司需进行系统对接，系统所有数据及功能模块需完全开放数据接口，不得以任何理由拒绝同其他系统任何功能的对接。并根据我公司要求同第三方公司商讨制定解决方案、并根据解决方案提供合理报价，如提供的报价不合理，我公司有权对系统进行修改、二次开发等操作以满足同其他系统的对接要求，且不构成“知识产权保护”、“禁止反编译”、“禁止二次开发”等合同条款的违约 |                                          |        |      |\n| 8    |                     | 提供标准产品、二开部分详细的数据字典                         |                                          |        |      |\n| 9    |                     | 提供的系统如为加密狗、license授权等形式，系统安装时需提供无时间、功能限制的授权 |                                          |        |      |\n| 10   |                     | 在标准产品上做的接口、二次开发等功能，如系统版本升级、系统更新，需免费将二开部分功能同步更新。如因接口第三方公司系统升级，需配合第三方公司免费对本系统接口做相应调整 |                                          |        |      |\n| 11   |                     | 需提供检核系统使用的各类报表，可对任一时段的用户登录情况、系统关键数据统计分析，能多维度评测系统使用情况 |                                          |        |      |\n| 12   |                     | 支持系统BUG终身免费处理                                      |                                          |        |      |\n\n\n\n### 系统技术设计文档\n\n会员营销系统\n\n\n\n",
                    "title": "标书问题"
                  },
                  {
                    "path": "7.公司事宜/中科泰岳/项目/3.海昌会员项目/海昌.md",
                    "content": "#zkty/project/haichang  #docs/how-to-guides \n# 海昌\n\n[用户操作手册v3.0.zip](assets/用户操作手册v3.0-20221004164817-wxfrowc.zip)\n\n‍\n",
                    "title": "海昌"
                  },
                  {
                    "path": "7.公司事宜/中科泰岳/项目/3.海昌会员项目/负载容量-要多少硬件问题.md",
                    "content": "#devOps #docs/how-to-guides \n\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220311231543-84lvnuc.png)\n\n需要数据：\n\n当前用户数量 \n\n用户平均访问\n\n‍\n\n业务量的估算公式是：\n\n     (1)当前业务月发生总量 ＝ 用户当前数量 × 用户月平均访问数\n\n     (2)当前主要业务月发生总量 ＝当前业务月发生总量× 比例係数\n\n     (3)当前月高峰期N天中主要业务总量 ＝ 当前主要业务月发生总量×N天发生的比例\n\n     (4)当前月高峰期每秒处理量=当前月高峰期N天中主要业务总量 ×M小时发生的比例/N天/ M小时/60分钟/60秒\n\n     (5)当前月峰值业务量 ＝当前月高峰期每秒钟处理量×5倍\n\n     (6)L年高峰期每分钟处理量＝当前月高峰期每秒处理量×用户量增长率×业务量增长率\n\n     (7)L年峰值业务量＝ L年高峰期每秒钟处理量×5倍\n\n以不超过 CPU 负载 50% 为基准\n\n内存公式 = CPU核数 * 4G\n\n稳定的网络使用率大约是70% ， 因此1Mb/s = 112.64KB/s * 0.7 = 78.848 KB/s。可以把这个值作为一个常量即可。\n\n服务器（Windows平台）内存= （操作系统佔用内存+应用佔用内存+应用并发网络连接佔用内存+其他软件佔用内存）/ 55%\n\n并发量 =当前月高峰期每秒钟处理量\n\n并发量峰值 =并发量 * 5\n\n‍\n\n‍\n\n[https://www.jianshu.com/p/264852641743](https://www.jianshu.com/p/264852641743)\n",
                    "title": "负载容量-要多少硬件问题"
                  },
                  {
                    "path": "7.公司事宜/藤蔓瑜伽/藤蔓瑜伽-开店指南.md",
                    "content": "#docs/how-to-guides  #tenwan \n## 开店策略\n\n### 选址\n\n选址要求：\n\n1. 周边小区\n      1. 数量\t(电子地图)\n      2. 人群标签 \n      3. 人均消费 (大众数据，链家数据)\n2. 周边健身 (大众数据)\n      1. 数量 (大众数据)\n      2. 办卡价格 (二手卡转让数据，上门暗访) \n      3. 营销手段 (大众部分数据)\n      4. 客户满意度 (大众数据)\n3. 交通便利性\n   1. 公共交通工具点与馆的步行距离\n   2. 停车场一周内每天可用报告\n\n### 开店前\n\n1. 租房合同签定\n2. 工商税务完备\n3. 装修\n   1. 设计方案\n   2. 装修队伍\n   3. 时间成本 \n      1. 装修时间\n         1. 采购装修物品\n      2. 净味时间\n         1. 采购店内物品\n   4. 镜子问题： 一定要做背板找平。\n4. 招聘工作人员\n   1. SOP 培训\n   2. 销售上岗\n5. 业务系统准备\n   1. 内部管理\n   2. 营销系统\n6. 预售\n   1. 营销策略准备\n      1. 一定要交小额定金.\n   2. 营销渠道准备\n   3. 营销成本核算\n\n### 正式开业\n\n1. 数据收集与订正\n   1. 到访率\n   2. 成单率\n   3. 客户反馈\n\n### 稳定运营 \n\n \t1. 流量\n      \t1. 体验款可做抵扣办卡费用\n \t2. 拉回\n      \t1. 第一次尽量电话邀约, 可以快速进入话术, \n      \t2. 退而求次微信.(用做发有效信息渠道,比如个人身体评测)\n           \t1. 用做关心, \n\n## 销售策略\n\n### 团购 vs 直接上课\n\n如果直接上课办卡\n\n1. 大课，减免100 元。\n2. 私教，减免 200 元。\n\n\n\n# 藤蔓瑜伽-开店指南\n\n## 客户流程\n\n看到广告\n\n听朋友介绍\n\n咨询\n\n准备衣服\n\n找店位置\n\n到站-停车 -> 步行 \n\n开门 进楼 \n\n招待\n\n换衣服\n\n上课\n\n招待\n\n离开 \n\n步行  -->  公交, 停车位\n\n回家\n\n\n\n## 招聘策略\n\n1. 了解需要什么样才能的人\n2. 找到了人, 要给应聘者定工作年限,工资优势.未来目标,个人成长.\n\n\n\n## 退卡流程\n\n**多种的退卡处理方式**\n\n在遇到会员要求退卡时，我们读者群里的一些瑜伽馆主有自己的心得，一起来学习一下：\n\n**@杭州馆主思敏**我们在遇到退卡问题时，会要求退卡会员填写清楚退卡原因，所有退款需经过店长签字同意；\n\n如果会员在未开卡前办理退卡，需在卡项规定时间内申请办理退卡手续。\n\n**@馆主 青叶：**我们在接到会员要退卡的要求时，会询问会员退卡原因。如果是不满意瑜伽老师和馆里其他人，我们会通过沟通了解会员的需求，然后看能否通过调整来解决会员的需求。\n\n如果会员执意要退卡，我们也安排会籍专门给会员打电话，询问情况，其实这也是一个留住会员的方法。\n\n**@馆主 齐飞：**我们一般采取“不纠缠”战略，在了解会员退卡原因并且得到反馈之后，会将剩余课时换算后协商退给会员。当然，如果年卡用到还剩1个季度，不论会员是否还继续练习，都不予退。\n\n**02**\n\n**我们怎么做才算妥善？**\n\n以上瑜伽馆主的分享都很有自己的特色，由此，我们总结了4个退原则：\n\n**1. 签订协议**\n\n首先，瑜伽馆在办理会员入会时，几乎都会签订入会协议。协议中我们应该明确告诉会员哪些情况不退，尽到告知对方的义务。\n\n那该怎么制定协议，能最大限度的保护好我们瑜伽馆呢？比如我们可以这样设定入会协议：\n\n•退卡时，一定将完整发票或者收据完整退回。\n\n• 退卡，需扣除xx元制卡费（材料费）；\n\n• 不予退卡有三种情况：年卡使用超卡时的三分之二，不予退卡；短期卡开卡后，不论会员上课与否，不予退卡；开卡后，由于会员自身原因缺课，会馆不予延期，过期作废；\n\n• 优惠券仅限报名使用，不可兑换现金，每次仅限使用一张。报名时使用优惠券或已享受折扣，一概不退卡。\n\n那如果会员单方面不遵守协议，坚持要退卡，否则就在瑜伽馆里闹该怎么处理呢?\n\n如果碰到一定要纠缠退卡的会员时，我们在签订入会协议中还要写明违约的处理办法。比如，某位短期卡会员最近工作有所调动，一定要求退卡，我们只需要根据协议告知其需要承担违约金，问题就很容易解决了。\n\n这样的协议，保护了会员和瑜伽馆双方的利益，是比较合理的。\n\n**2. 态度诚恳**\n\n整个服务业遇到退卡退费的情况，都属于正常情况。不要觉得有会员退卡是件很糟糕的事，退卡的原因多种多样，不一定就是我们的问题。\n\n在出现问题后，我们最重要的不是手足无措，而是该积极寻找解决办法。比如将退卡流程优化，同时提高退卡标准。\n\n其实退卡并不是一件坏事情，它能够逼迫瑜伽馆更好地发展。因此，要平常心看待退卡问题。当会员出现情绪的问题时，我们最重要的是积极的处理沟通，而不是意气用事，将矛盾激化扩大事件的影响。\n\n大部分会员退卡可能是因为：\n\n• 瑜伽教学效果不明显\n\n• 怀疑不满意瑜伽馆的服务\n\n• 会员自身原因，如搬家、生病、怀孕等\n\n这时，如果我们态度好，根据协议又能很积极的沟通，爽快地流程化退卡，以后有给流失会员打电话的机会，很有可能让她们再重新回来。\n\n但如果为了阻止会员退卡，故意将退卡的机制设置的很复杂。给会员留下坏印象，那她有可能就真的流失了。\n\n因此，在会员要求退卡时，我们要让带课瑜伽老师（会籍）询问清楚退卡原因，如果是服务和瑜伽老师教学等原因，我们可以尝试劝说会员。\n\n比如：刚开始学习瑜伽要慢慢来，身体才能有变化，可能张老师的教学风格偏向于力量不适合您， xx老师的课比较温和，不如我们试试她的课？\n\n总之要态度诚恳的尽量去挽留，体现我们对会员的重视。在挽留之后，如果会员说什么也要退卡，那就不用再纠缠下去了，免得会员厌烦。\n\n**3. 及时爽快地退卡**\n\n在我们答应会员退卡时，就要尽快把钱退给她。很多会员抱怨退卡时间太长，因为等待是一件让人很没安全感的事。\n\n如果我们退钱慢，会员就会产生质疑和“她在骗我吧？”“太墨迹了，没诚意。”“收钱倒收挺快。”等怨言。既然要退卡了，就爽快退卡给会员。\n\n**4. 加强平时的管理**\n\n开瑜伽馆最重要的，是从教学和服务上打动会员。平时多注重这些，就不用太担心退卡的问题。而这就需要对我们瑜伽馆的每个工作人员提出更高的要求，让每个人重视这些事。\n\n总之，退卡虽惹人心烦，但只要在会员入会前将规定制度告知对方，并做好瑜伽教学服务再加以人性化考量，相信面对退卡你将不再“手忙脚乱”。\n\nPS：关于有瑜伽老师辞职另起炉灶，煽动会员退卡到她那学习的问题，还可以延伸阅读：\n\n瑜伽老师辞职还带走了会员，怎么办？\n\n\n\n## 硬要退卡\n\n版权归作者所有，任何形式转载请联系作者。\n作者：变成瑜伽的样子（来自豆瓣）\n来源：https://www.douban.com/note/703962542/\n\n1\n\n会员报名入会时，一定是有自己的一个需求的。不是想减肥就是给自己找事情做，要不然就是缓解身体压力或者调整自己的气质。\n\n因此，我们首先要做到满足她的这些需求，才能留住她。比如开维密小班塑形课、开香薰瑜伽、舞韵瑜伽，或者组织其他的集体活动等等。\n\n但是，做到这些只是最初级的瑜伽馆经营。因为，会员很快就开始感觉厌倦、没有新意、失去兴趣，于是产生要停卡和退卡的想法。\n\n很多瑜伽馆主这个时候的做法，常常是寻找新鲜的课程，来填补到下一期的课程表中。\n\n看到这里，你就会明白。这样的做法，只暂时消除了【没有新意】的念头。而不是，解决了她们入会时真正的需求。\n\n我们正确的做法应该是怎么做呢？\n\n正确的做法应该是：\n\n1：在每一位会员入会前，了解她入会的真实需求，并做好备注。\n\n2：在每隔一个阶段，引导会员去发现自己学瑜伽以来的变化。\n\n3：再由瑜伽老师去指出，她当下存在的问题，并说明问题存在的重要性。\n\n4：顺势给出适合她的课程，为续费和开私教做铺垫。\n\n做得好以上4点，足可以挽回一个“下定决心要退瑜伽卡”的会员。\n\n在“做法2”这里，有1个细节需要注意。\n\n我们会在日后文章里详细给大家解析，心急的馆主可以先在后台回复【58】查看\n\n2\n\n要退卡的这位会员是40左右的一位女性，这个阶段的人，工作和家庭一般都已经稳定，缺乏对未来变化的警惕。\n\n要让这些会员不退卡甚至续费，该怎么做呢？\n\n正确的做法是：\n\n梳理她这个年龄段女性容易出现的问题，将这种问题化为近期、迫在眉睫的压力和威胁。\n\n比如，话术可以是这样设计：\n\n“我一位朋友的孩子刚读高一，今天特别胖，总是觉得很自卑。我朋友一边担心孩子在这个年龄段出现心理问题，一边担心孩子上高三时顶不住压力。为了孩子的事，弄得自己都精神衰弱了。\n\n你也知道，女人一旦过了35+岁，就容易身材变形，这个年龄段的女性得乳腺癌、卵巢癌的人又特别多。结果，孩子没有减下来，自己却变胖了。孩子看到妈妈整天昏昏沉沉的，反而压力更大了。\n\n就这样，上个季度她母女俩被我劝着来练瑜伽。我们还用私教课帮她和孩子减下10多斤，现在母女俩的状态简直就像换了一个人。你说，孩子状态好了，离好大学是不是更近了一步”。\n\n这一段话，除了给会员传达瑜伽可以塑造身型以外，还顺带暗示了自己的瑜伽私教很有效果。\n\n即便会员一定要退会员卡，我们还可以引导她改为私教课来耗卡。\n\n3\n\n很多瑜伽馆主在面对会员提出退瑜伽卡、退费时，都会感到有些恐慌。\n\n要么一口回绝不退，导致纠纷；要么找各种理由，临时收取%的退会费。\n\n但根据我的了解，这样做的后果常常是，让会员觉得“这家瑜伽馆的老板很功力，我要对我朋友们说，千万不要来她家练瑜伽”。\n\n因此，当会员提出要退卡退费时，我们还可以这么做：\n\n1：根据会员的属性，用案例来说教。比如:\n\n如果，会员是位35+的女性就用上面的话术；会员是为孕妇，就修改为产后发胖、代谢出现问题的话术；会员是为上班族，再修改为职场竞争大的话术。\n\n总之，用案例的说教，既不会引起反感，还能暗示她转卡和继续续卡。\n\n2：利用从众心理。比如：\n\n一位会员用“家中有急事急需钱”来要求退卡，我们可以用：\n\n“最近我们瑜伽馆新推出了XX课程，这个课程特别适合你们这类（35+女性、宝妈、职场人士等等）人群。\n\n而且，这几天我们的价格马上就要上涨1000元，所以大家都抢着报名上课。跟你一起上课的Xxx，都直接给她朋友代交了5份定金。\n\n你现在就退卡，能退多少钱先不说，以后再想报名还要多花1000多，多不值”。\n\n总之，利用瑜伽馆会员大多数人都报名的心理暗示，让退卡的会员形成“自己也要随大流”的心理。同时，还要暗示她，即便硬要退钱，也退不了多少。\n\n相信到了这里，很多会员都会慎重的考虑自己要退卡的行为对还是不对。我们这时再用“名额有限、限价最低、马上涨价”之类的话术去催促她收回要退卡的决定。\n\n结语：\n\n以上的做法是靠我们主动去引导会员思考的，如果你学不会，可以提前找个人帮你私下多加练习。\n\n这样，在面对会员提出退费时，就不会再手忙脚乱、头脑发懵了。",
                    "title": "藤蔓瑜伽-开店指南"
                  },
                  {
                    "path": "8.个人与家庭/music/好和弦/如何練好「二對三」和「三對四」節奏？ .md",
                    "content": "#docs/how-to-guides  #chords \n\n\n\n \n\n23 练法\n\n左手，右手分开打， 并且脑袋要习惯任何一个拍子。\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20211225222607-xyl9bbg.png)\n\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20211225222936-g94il55.png)\n\n[如何練好「二對三」和「三對四」節奏？ - YouTube](https://www.youtube.com/watch?v=b9mUd6vJ_vU&ab_channel=NiceChord%28%E5%A5%BD%E5%92%8C%E5%BC%A6%29)",
                    "title": "如何練好「二對三」和「三對四」節奏？ "
                  },
                  {
                    "path": "8.个人与家庭/music/好和弦/讓你的副屬和弦更漂亮的小技巧！.md",
                    "content": "#docs/tutorials #music #chords\n\n\n \n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20211211170320-d2ttjtj.png)\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20211211170359-uiglde0.png)\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20211211170626-5rx4ysw.png)\n\n‍\n\n# 小调要插入半减七和弦\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20211211170646-yqnd9pw.png)\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20211211170615-sitayac.png)\n\n[讓你的副屬和弦更漂亮的小技巧！ - YouTube](https://www.youtube.com/watch?v=yMcz-w_jRhQ)",
                    "title": "小调要插入半减七和弦"
                  },
                  {
                    "path": "8.个人与家庭/music/练琴/快速找根音.md",
                    "content": "---\naliases: [fastest way to find root note]\n---\n#docs/how-to-guides  #chords \n\n\n我们在基本乐理与传统和声中接触的和弦一般都像这样子：\n\n![](https://pic1.zhimg.com/80/v2-06bcf522a9c9dff6ebfa0d3bca655430_720w.jpg)\n\n假设在C大调，那么，这些和弦有自然音体系的（前两个），也有更复杂的半音体系的（后三个），**但它们都有一种共同的简单性，就是，它们都可以重新排列为原位三度叠置和弦的形式，从而很轻松地找到根音：**\n\n![](https://pic3.zhimg.com/80/v2-7739b49702864b04edb41fb9e689489a_720w.jpg)\n\n然而， **放到“任意** （十二律）**和弦”范围，以上方法就对此束手无策了：**\n\n![](https://pic3.zhimg.com/80/v2-40a7fe675048d09bdaded666f8645c42_720w.jpg)\n\n这时，我们就需要借助支持判断任意和弦的根音的方法来找出和弦的根音，其中一个有名的方法，就是**保罗·欣德米特（Paul Hindemith，1895～1963）提出的欣德米特根音判别法。**\n\n![](https://pic2.zhimg.com/80/v2-122ce808ffb27997260095198b1f65dd_720w.jpg)  \n保罗·欣德米特（Paul Hindemith，1895～1963）\n\n## 欣德米特的方法\n\n用欣德米特法对任意和弦根音的判断步骤如下：\n\n### 先找纯五、纯四\n\n* 先寻找**纯五度**或 **纯四度** 。\n* 如有，则 **五度的下方音** ，或 **四度的上方音** ， **即是和弦的根音** 。\n* 如有 **多个五度** ，或 **五度和四度兼有** ，则以**最低一个**为准。\n\n举例：\n\n![](https://pic3.zhimg.com/80/v2-4b293e5b9a8f1b8028770b6eab28ae8e_720w.jpg)\n\n### **没有则找三六度**\n\n* 如果 **没有五度或四度** ，则寻找 **三度** （大三度优先）或 **六度** （小六度优先）。\n* 六度是三度的转位（小三大六，大三小六）。根音： **三度取下方音，六度取上方音** 。\n* 如 **四五度和三六度兼有** ，则 **取最低的优先音** 。\n\n举例：\n\n![](https://pic3.zhimg.com/80/v2-c72e441fbd9ee1b463e9fbff46a43ee6_720w.jpg)\n\n### 还是没有？最后这步总能找着\n\n* 复杂的情况：**音数杂多，音程相隔很近或没有四五度和三六度只有二七度的情况**\n\n![](https://pic1.zhimg.com/80/v2-297a20b3c91cc5eebadc97c64a4738f4_720w.jpg)\n\n### 还是找不着，则这个和弦没有根音\n\n* **特别地，当音集中的音程完全平均分布，即音集是单个或多个八度的等分时，根音不确定，或说没有根音（从欣德米特法的角度看）。**\n\n![](https://pic1.zhimg.com/80/v2-337d5200d2127c9d07f8b703e7f79748_720w.jpg)\n\n**这样，对十二律下的所有和弦，都可以找到它们的根音了。**\n\n现在，试试用这个方法，来寻找一下我们在前文中举的那些非传统和弦的根音？（答案略）\n\n![](https://pic3.zhimg.com/80/v2-40a7fe675048d09bdaded666f8645c42_720w.jpg)\n",
                    "title": "快速找根音"
                  },
                  {
                    "path": "8.个人与家庭/resume/write resume.md",
                    "content": "#resume  #docs/how-to-guides \n\n1. 使用其他公司的简历描述\n2. 上领英，看牛 b 的人怎么写简历\n\n[[写简历]]\n[[怎么写经历]]",
                    "title": "write resume"
                  },
                  {
                    "path": "8.个人与家庭/resume/写简历.md",
                    "content": " \n#resume #docs/how-to-guides #excerpt \n \n写简历是为了找工作，看到简历会不会给你面试机会的是 HR，所以：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-fd780211d1a66400793cf4c7407088a7_720w-20220321031619064.jpg)\n\n简历没有真正的统一规范。没有机构鉴定。没有行业标准。所以谁都可以拿他的一套逻辑来跟你讲怎么样美观，怎么样“脱颖而出”，怎么样“高水平”。\n\n\n\n高水平人才的简历，他们的简历长什么样。\n\n我有幸被清华大学聘为职业生涯计划导师，发现原来清华会统一给学生发放简历模板，教大家如何用统一的专业格式写简历。\n长这样：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-631913ca5532b124ea21e433a1065e38_720w.jpg)\n\n\n\n高质量的简历基本上就是这样，白纸黑字，英文的更是连头像都没有，纯靠文字硬货。\n你觉得太闷也好，性冷淡也好，但是招聘方看到这份简历只会觉得专业。\n\n工作几年后的简历也一样，就是把工作经历和教育经历调换顺序，然后把上学时的奖项、实习、兼职、校内活动等已经不那么有价值的信息删除，把工作、项目经历的篇幅加长。\n\n样式就是这么简单经典，接下来讲高质量简历的制作细节。\n \n\n一份简历最重要的是<span style=\"font-size:50px\">匹配</span>，是否匹配是由你的背景/经历/经验/技能和岗位需求决定的，而能够准确、有效的传达出去你的匹配就是一份高质量的简历，它需要满足5个基本规则： \n\n- 篇幅一页\n- 排版整洁\n- 重点突出\n- 文字精炼\n- 无格式错误\n\n \n## 1 - 篇幅一页\n\n为什么简历一定要一页纸？\n\n因为当HR收到几百份格式类似的简历时，TA会希望简历的格式能够标准化。尽管简历都是以电子形式发送，但面试的时候大多数企业都还是会打印出来给面试官，不会有荧幕挡在面试官和求职者中间，也方便记笔记。\n\n试想在几个面试官拿着打印出的纸质简历面试时，候选人A的简历1页、B的2页、C的3页，HR要么得拿个订书机手动装订，要么就等着B和C的简历在面试过程中被搞混。\n\n我在一年前开始学编程的时候就想着要把一页纸自动化，不再需要手动调整。半年前，我们将这个功能上线。\n\n不多说，看图：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-0ea91faf2188d5dc0969a93160040f97_720w.jpg)\n\n\n\n\n\n写少了可以“一键排版”拉满至一页纸\n\n写多了可以“一键排版”缩小至一页纸\n\n\n\n不要再为了把简历调成一页纸浪费生命调格式。\n\n[>>>点击这里，立即上传你的简历，自动一页纸排版](https://link.zhihu.com/?target=https%3A//datayi.cn/w/L9GK1yX9)\n\n\n\n经常看到有人问，不是篇幅一页，不是PDF文件，难道就会被直接Fail掉吗？\n\n可能不会，但是会增加HR筛选简历的工作量，部分很习惯看一页纸简历的HR还会有强烈不适感。如果你很强他们又很缺人，那这不是问题。但是如果竞争很激烈，你应聘的是个初级岗位或者实习生，就这么一点小问题，你的简历可能就不会再被打开了。\n\n毕竟不遵守规则，意味着要么根本不知道这个规则，要么知道却不遵循，两者都不是招聘方想看到的。\n\n\n\n## 2 - 排版整洁\n\n简单来说，版面整洁不是有什么，而是没有什么：\n\n- 没有五颜六色的图标和模块分割线\n- 没有[可视化](https://www.zhihu.com/search?q=可视化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A248492078})图标来展示技能或兴趣爱好\n- 没有浪费空间去写没有用的信息\n\n\n\n这里简单讲一下为什么简历上不要有可视化的图表。\n\n“可视化”跟“大数据”这个词一样在过去几年越来越烂大街。但数据的确是需要可视化的，因为右边的图比左边的数容易看懂：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-f584a7517660844499f69a1e0110e0eb_720w-20220321031624221.jpg)\n\n\n\n当你简历上写着“Excel（精通）”的时候，背后是哪几千条数据呢？\n\n没有数据。\n\n你的技能或爱好背后没有数据。\n\n只有你对自己的一个谈不上客观的衡量，然后花了一大块空间放了一张根本没有任何价值的图：\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-33c5ad205cbd35e698f9e5fd26f05058_720w-20220321031624748.jpg)\n\n\n\n空间，是简历上的黄金。你的经历越丰富，简历空间就跟北京的房价一样，寸土是金，绝对不能浪费。\n\n所以这些传统的“人力资源表格”会让每一个收到简历的人抓狂：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-59822de39af4669b4ba10b506ad66889_720w-20220321031626069.jpg)\n\n\n\n表格简历的真正有效信息可能只占据了简历的30%。\n\n在过去十几年间，为了节省简历上的空间，名校精英们逐渐统一了简历罗列的格式，删掉所有无效信息，将最重要的“公司名称”、“职位”、“部门”等信息做成清晰明确的标题行，并且将“日期”、“地点”这类必须写但又不是最关键的信息放在对应的右边。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-2886b2f206582aaf6332c2a10c1feb65_720w-20220321031627222.jpg)\n\n\n\n\n## 3 - 重点突出\n\n尽管标准、专业的简历模板被全球名企HR和名校精英推崇，但却依然经常有人想要学设计师做出自己独一无二的、有创意的、显得自己高水平的简历。\n\n前面我提到了换位思考，那我们再想象一下HR收到几十上百份简历时候的场景：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-696584f9a545a5fde4439c5663f7e93a_720w-20220321031631605.jpg)\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-210226f78a01d427bc05df0d6623dd40_720w-20220321031632327.jpg)\n\n\n\n你认为一个企业HR会在乎收到的简历是用的A模板还是B模板吗？\n\n不会。\n\n\n\nHR只会在乎你的简历是否易读。\n\n全天下所有的简历长一样反而更方便，更好筛选。\n\n所谓的创意、设计等追求，先不说你的审美和招聘老师眼中的审美是否一致，那些颜色、图片、还有不能清晰表达的图表，都会分散掉简历内容的重点。\n\n你要做的是通过合理排版的简历帮助HR节省时间，而不是通过一堆乱七八糟的色块和图标让HR花多几秒钟找你的学校和实习经历。\n\n最易读的模板就是格式统一、规范，白纸黑字重点清晰的模板。\n\n\n简历上突出重点体现在：\n\n位置、篇幅、和关键信息\n\n\n\n「位置」  \n\n\\1. 各模块的位置：\n\n学生要突出教育经历，所以要放在前面。而工作1年以上的就应该重点突出工作内容，所以教育经历放在工作经历后面。\n\n不建议网络上流行的左右排版，可能好看但没有好处，反而会造成注意力分散而忽略掉一些重点内容。左右排版要是阅读最佳体验的排版，书籍干嘛不左右排版？合同为毛不左右排版？红头文件怎么不左右排版？\n\n若想要信息易读，谢绝左右排版，正常按模块重要性上下排版就好。\n\n还有一个原因就是正常排版的简历更容易被大企业的ATS系统读取。但可能读这篇的朋友都还不知道ATS是啥，等回头有空再科普吧。\n\n\n\n\\2. 每段经历的位置：\n\n时间倒序是标准简历的通用规范，因为最近的经历对招聘方来说是最重要的。\n\n不要认为因为某一段经历“最相关”就跳出时间顺序放到最前面，因为每个HR打开简历的时候都会默认为是时间倒序排列，直到突然发现顺序不是时间倒序，又需要重新在脑海中组织候选人的整体背景故事（“原来是中间离开了这个行业然后后来又回来”），其实就变成了减分项。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-20b44e03dbdf15066516beae6460df6c_720w.jpg)\n\n\n\n\n\n\\3. 时间和城市的位置：\n\n刚刚说了，这部分属于不是最重要但是必须有的信息。放在简历的右侧，非常易识别并且方便阅读。一般情况下时间更重要，所以放在上面的主标题行。\n\n有的时候也需要根据自己需求更换排版，调换日期和城市顺序来突出城市信息，比如读过的学校、交换的学校、工作实习过的地方都在不同城市，则可以通过这种排版发挥优势。或者如果教育和工作背景全部都在一个城市，可以用一行经历标题展示来忽略城市信息。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-d50ef077e1c864a195ed00d17e9a82d5_720w.jpg)\n\n\n\n\n\n\n「篇幅 」\n\n学生写简历最容易犯的错误之一就是大篇的自我总结、奖项、活动、研究论文、课程、技能描述，然后工作实习经历写一点点。\n\n感觉就像是炒菜忘了放菜。\n\n这种情况除非有人看了简历并且提出建议否则自己很难察觉。因为作为学生的我们都认为那些奖项、论文都很有含金量，很值得自豪。但HR最在乎的是你以前做过的工作内容，其他学业上的成绩基本上看个GPA就能知道你的学习情况了。\n\n\n\n通常我会推荐简历的教育经历篇幅不推荐超过1/3，工作/实习经历最好能占到整个简历的一半以上。\n\n\n\n为了让每个人都能自主察觉到这类问题，我们做出了智能识别篇幅长度并作出提醒：\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-15fa6329008ac301b94eb74a037d9607_720w-20220321031633595.jpg)\n\n\n\n「关键信息」 \n\n公司、学校名称等关键信息需要加粗，因为这是HR在5秒钟之内需要在简历上找到的信息。\n\n除非简历当中刚好有跟招聘要求上面非常冷门的要求匹配的内容（比如JD要求要有西班牙语工作经历，然后在某一段工作中曾外派到墨西哥半年），不推荐在简历上进行过多的加粗/下划线/斜体，更不要用别的颜色画出重点（比如知乎就不提供黑色以外的选择）。\n\n其实真正有用的重要信息写到经历的第一个bullet即可，根本无需加粗。\n\n请记住，重点太多 = 没有重点。同样，我们研发的超级简历机器人也会对过多重点标示做出提醒： \n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-8d2c45dae04d8ab87768a704c3b17bd5_720w-20220321031634632.jpg)\n\n\n\n## 4 - 文字精炼\n\n从文字总结中完全可以看出一个人到底做过什么，有没有相关的素质和能力。在简历中虚无的自我评价是没有意义的。\n\n“团队能力强” 你跟哪些团队如何协调过什么事情？\n\n“2年自媒体经验” 你做出了什么成果？跟其他99份背景类似的简历有什么不同？\n\n\n文字精炼的意思就是 “除去杂质,提取精华”、“用心琢磨使精炼”的文字去描述你的经历。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-0d96495de259ae7dfd75641b0ed8e2a0_720w-20220321031635288.jpg)\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-29048685a85b9acdf64173978f499b78_720w.jpg)\n\n如果能精确、简洁的写出来每一段经历中你做成了什么事情，那你就已经战胜了市面上90%的求职者。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-fa975dc7178e125acebebdd5cd4ce1bb_720w-20220321031639668.jpg)\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-75236788095c822351252cbf331fa95f_720w-20220321031640151.jpg)\n\n \n我对STAR法则进行了优化，总结出了真正适合写简历的公式：\n超级简历公式：动词 + 工作内容 + 方法 + 结果\n\n实际撰写形式如下：\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-5a6101aed3df022ccfde064abc592483_720w-20220321031640759.jpg)\n\n\n\n并且，我们筛选出了优质的案例、词库和填写贴士给你参考：\n\n「案例库」\n\n不仅是对工作的描述需要参照物，对于简历上的每个模块，其实都需要合理的引导和提示： \n\n> 教育经历：GPA、荣誉奖项、相关课程的详细说明和中英文案例\n> 工作经历：添加了10个行业的中英文案例，涵盖对于实习和全职经历的描述\n> 活动经历：学生会、赛事和公益3种类型活动的中英文案例\n> 其他：分为语言、技能、证书执照、兴趣爱好、活动5个部分，每个部分都有针对不同模板的中英文案例\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-a199997b8b20e74116b1ff9ecfce7be6_720w-20220321031641554.jpg)\n\n\n从大一写人生的第一份简历开始，我就经常在网上搜 “resume action verbs”（适合在简历上使用的关键词）帮助我对经历描述增加灵感。我当时就想，要是Word里面能自动出现这些关键字库该有多好。\n\n所以我们把这种常用动词放在了填写经历描述的手边，这样写简历的时候永远不再会“词穷”，在填写过程中能够轻易的使用更准确的文字描述：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-0a5f05f8f96a56289b90e6c6122f6553_720w-20220321031642078.jpg)\n\n\n\n「填写贴士 」 \n\n除了参考案例之外，写简历的时候经常会碰到一堆问题：GPA多少才算高？实习没有含金量怎么写？工作经历中有一段空白怎么办？\n\n你当然可以在知乎上来提问，然后慢慢等待大牛的答复（许多立刻答题的都是随手一写根本不负责任），或者可以在网上慢慢搜。\n\n为了让这一切效率变得更高，我们将所有简历相关的常见问题全部整理出来，针对每个填写的模块嵌入简历编辑器当中。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-2e0b245adb1f0ff5af3bdb2de66be422_720w-20220321031643211.jpg)\n\n\n\n## 5 - 无格式错误\n\n细节决定成败。这句话用在简历、面试、实习的整套求职过程中，真的再适合不过。\n\n很多人会在“自我评价”中说自己“认真负责”、“关注细节”，结果简历上各种中英文标点符号混用、日期格式不一致、甚至把“Email”拼成“emial”。\n\n\n\n不用怀疑甲方的挑剔，更不用怀疑那些被甲方折磨出来的优秀乙方的工作习惯。举个例子就能看出一个资深的职场人士对于细节的把控能有多么的丧心病狂。\n\n\n\n下面的每一条中英文日期和技能描述都存在格式问题，试试看你能不能在5秒钟之内找出来：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-444e1da2913ea4e1adf665331c26173b_720w-20220321031644243.jpg)\n\n\n\n看完了吗？公布答案了：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/v2-62da265897280acb8dea8aea48680dec_720w-20220321031644783.jpg)\n\n\n\n答案详解：\n\n> ·     中文日期格式多了一个空格\n> ·     英文日期格式前后不统一\n> ·     中文技能标签括号全半角标点混用（而且列举一串标签最好用顿号而不是逗号）\n> ·     英文技能标签括号前面需要空格 + 技能程度描述第一个字需要首字母大写\n\n\n\n这只是举个例子，可以试想一下在你的简历中要花多长时间才能找出所有的小错误，而在简历中可能出现的格式错误还有很多种。\n\n\n\n自我评价“细心踏实”是没有用的，真正做到细心才是根本，90%的实习工作、初级工作招聘方都会看重“细心”这个能力。\n\n也许你的简历版面已经获得了HR的好感，也许你的经历描述已经帮你获得了面试机会，但是在面试时一边聊一边看着你的简历的HR可能就因为一些格式错误皱起了眉头，对你的能力产生了质疑。\n\n",
                    "title": "写简历"
                  },
                  {
                    "path": "8.个人与家庭/resume/怎么写经历.md",
                    "content": "#resume #docs/how-to-guides \n\n- Workload（工作量）\n- Difficulty（难度）\n- Specialty（特殊性）\n- Understanding（理解）\n- Value（价值）",
                    "title": "怎么写经历"
                  },
                  {
                    "path": "8.个人与家庭/保险/保费豁免.md",
                    "content": "#insurance  #docs/whatis-why-explanation \n\n\n**什么是豁免？**\n\n【豁免】其实就是【豁免保费】。\n\n简单来说，**如果发生了保险公司约定的某些事故，剩余的保费就不用交了，保障继续有效**。\n\n举个栗子：\n\n小明买了个【交30年保终身】的重疾险，带轻症豁免功能。\n\n假如小明交了3年保费后，不幸得了轻症。\n\n那么他后续27年的保费就都不用交了，保险公司继续保障他到终身。\n\n非常人性化的设计有木有，可以**避免患病之后工作收入下降，无力承担后续保费**。\n\n豁免的玩儿法蛮多的，咱们主要搞清楚两个问题就OK了：\n\n**首先要知道是【豁免谁】。**\n\n**豁免分【投保人豁免】和【被保人豁免】。**\n\n小明给老婆投保，小明是投保人，小明老婆是被保人。\n\n![图片](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1625210712655746.png)\n\n投保人豁免是指，小明作为投保人发生了事故的话，可以豁免后续保费。\n\n而被保人豁免则是，小明老婆作为被保人发生了事故，才豁免后续保费。\n\n要区分清楚哈。\n\n大部分重疾险都有被保人豁免，有的是可选项，有的是默认自带。\n\n而投保人豁免一般需要我们主动附加，不选就没有。\n\n另外，**如果自己给自己投保，自己既是投保人也是被保人，有被保人豁免就可以了**。\n\n**其次要知道【有哪些项目可以触发豁免】。**\n\n具体哪些事故可以触发豁免条件，要看我们跟保险公司的约定。\n\n**比如轻症豁免就是得了轻症，触发豁免，**\n\n\n\n**重疾豁免是得了重疾触发，**\n\n\n\n**而身故豁免是去世了才触发…**\n\n可以是一项也可以是多项，有些重疾险自带被保人轻症和中症豁免。\n\n如果被保人得了50种轻症或25种中症中的任意一种，免交后续保费。\n\n因此，我们在看豁免的时候，要搞清楚【豁免谁】和【什么情况可以豁免】这两个问题。\n\n**双豁免/夫妻豁免又是啥？**\n\n听起来很高级，其实就是**既有投保人豁免，又有被保人豁免**。\n\n有些重疾险，自带被保人豁免，另外可以选择附加投保人豁免。\n\n假设小明作为投保人给他老婆投保，而他老婆又作为投保人给小明投保，都附加投保人豁免。\n\n**之后他俩人其中任何一个人得了轻症中症重疾或去世了，俩人的保单后续就都不用再交费。**\n\n比如小明得了轻症，首先触发了自己保单的被保人豁免，自己的保单不用再交钱。\n\n然后也触发了老婆保单的投保人豁免，老婆的保单也不用再交钱。\n\n有点绕哈，看下面这个图试试：\n\n![图片](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1625210712997430.jpg)\n\n\n\n**豁免需要注意什么？**\n\n附加投保人豁免需要注意三个问题：\n\n**1）直系亲属**\n\n**想附加投保人豁免，必须得是对方的直系亲属才有这个资格**，比如父母、子女、配偶。\n\n像小宝和女朋友还没有领证，小宝就不能作为配偶给她投保，也就不能选投保人豁免。\n\n**2）完全符合健康告知**\n\n附加投保人豁免的话，**投保人需要完全符合健康告知**。\n\n绝大部分产品，都**不支持投保人进行智能核保和人工核**。\n\n所以像有些宝妈有甲状腺结节，给孩子投保的话就不能附加投保人豁免，建议换身体健康宝爸作为投保人再附加。\n\n**3）不用买同一个公司的产品**\n\n想要夫妻双豁免功能的，并不意味着俩人都得买同一个公司的产品才行。\n\n**买不同公司的也可以，只要各自配置的产品都支持附加投保人豁免就好**。\n\n双方任意一个人不幸得病，俩人的保单一样可以豁免后续保费。\n\n不明白的可以再看看上面小宝画的图~",
                    "title": "保费豁免"
                  },
                  {
                    "path": "B=MAP 理论.md",
                    "content": "#docs/how-to-guides \n这是一个指导如果触发做事的模型。 \n所谓如果做事，\n\nBehavior = Motivation + Availbility + Prompt\n\n\n",
                    "title": "B=MAP 理论"
                  },
                  {
                    "path": "Big Data/Block 副本旋转策略.md",
                    "content": "#bigdata  #distribution  #docs/whatis-why-explanation \n\n第二个副本马上出机架\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005174535-bf6nt16.png)​\n",
                    "title": "Block 副本旋转策略"
                  },
                  {
                    "path": "Big Data/DataNode.md",
                    "content": "#bigdata  #docs/whatis-why-explanation \n\n![image-20200104003311563](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20200104003311563.png)\n\n1. DataNode 启动时,会向 [[NameNode]] 注册自己.\n2. 每隔一段时间(默认 1 小时)上报所有块信息.\n3. DataNode 会定时向 NameNode 发心跳\n4. 超过一定时间没收到心跳, NameNode 判定 DataNode 掉线\n\n判定 DataNode 掉线 Timeout 公式\n\n```\nTimeout = 2* dfs.namenode.heartbeat.recheck-interval  + 10 * dfs.heartbeat.interval\n```",
                    "title": "DataNode"
                  },
                  {
                    "path": "Big Data/HDFS 写流程.md",
                    "content": "#HDFS  #bigdata #docs/whatis-why-explanation \n\n1. client 首先跟 nn 通信，拿到比如说 3 个 dn 的例表\n2. client 只跟例表里第一个 传输数据。\n3. 而 dn 之间会转递数据。\n4. dn 传递完会向 nn 汇报，nn 才会认为数据更新\n\n好处： client 不需要知道有多少副本。 dn 之间的速度通常比较 client -> dn 要快\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005174907-t4ujymk.png)​\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005175346-16blaep.png)​\n\n \n",
                    "title": "HDFS 写流程"
                  },
                  {
                    "path": "Big Data/HDFS 安全策略.md",
                    "content": "#bigdata  #HDFS  #docs/whatis-why-explanation \n\n对比 redis 有 RDB(快照), AOF(操作记录)\n\nHadoop 有 Fsimage(快照), edits.log(操作记录),\n\n但这备份两种模式都有缺点, 快照导出慢, 操作记录文件又太大, 恢复慢.\n\n2nn 则提供了一种机制,将 nn 里的 edits.log 做成 Fsimage.",
                    "title": "HDFS 安全策略"
                  },
                  {
                    "path": "Big Data/HDFS 读流程.md",
                    "content": "#HDFS  #docs/whatis-why-explanation  #bigdata \n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005175653-uu58lf4.png)​\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005175720-u4l3t5q.png)​\n",
                    "title": "HDFS 读流程"
                  },
                  {
                    "path": "Big Data/HDFS.md",
                    "content": "#bigdata #HDFS  #docs/whatis-why-explanation \n \n工程   /Users/zk/git/javaPrj/hadoop/hdfsDemo\n\nHDFS, 使用场景,一次写入,多次读取,且不支持随机修改,但支持追加. 不适合作网盘.非常适合做数据分析.\n\n**优点**\n- 高容错,默认有 3 个副本.丢一个副本,会自动恢复.\n- 适合大数据.\n- 可以在廉价机器上部署.\n\n**缺点**\n- 不适合低延迟数据访问\n- 无法高效存储大量小文件,费 [[NameNode]] 内存,小文件寻址时间甚至超过读取时间\n- 仅支持追加数据.要不就删了文件重建.\n\nHDFS 存储文件以 [[HDFS Block]] 为最小单元,不是以**文件**\n\n[[DataNode]](dn)  存数据\n[[NameNode]](nn)  存索引,元数据,文件名,文件结构,文件属性,每个文件在哪...\nSecondary NameNode(2nn): 用来监控 HDFS 状态的辅助程序,每隔一段时间获取 HDFS 的元数据的快照.\n\n## 配置 HDFS\n\n修改 /etc/hadoop/core-site.xml\n\n```xml\n<configuration>\n  <property>\n    <!--将默认的文件系统改为 hdfs -->\n    <name>fs.defaultFS</name>\n    <value>hdfs://192.168.1.22:9000</value>\n  </property>\n  <property>\n        <!--产生的临时文件存放的fbyy -->\n    <name>hadoop.tmp.dir</name>\n    <value>/opt/module/hadoop-2.7.2/data/tmp</value>\n  </property>\n</configuration>\n```\n\n\n\nhdfs-site.xml\n\n```xml\n<configuration>\n  <property>\n    <!--hdfs 副本的数量 -->\n    <name>dfs.replication</name>\n    <value>1</value>\n  </property>\n</configuration>\n```\n\n因为我们是起的伪分布式, 只有一个节点,所以为 1,默认为 3,但没意义...\n\n\n\n**格式化 hdfs**\n\n```bash\nbin/hdfs namenode -format \n```\n\n看到这样的输出\n20/01/03 02:19:47 INFO common.Storage: Storage directory /opt/module/hadoop-2.7.2/data/tmp/dfs/name has been successfully formatted.\n\n\n\n## 启动 HDFS\n\n```bash\nhadoop-daemon.sh start namenode\nhadoop-daemon.sh start datanode\n```\n\n可以通过 jps 查看是否启动.\n\nhadoop-2.7.2]# jps\n20391 NameNode\n20540 DataNode\n20620 Jps\n\n\n\n**测试页面：**\n\nhttp://192.168.1.22:50070/\n\n\n\n> 注意:\n>\n> 不要多次格式化 hdfs , 想像你的硬盘总格式化,你的数据咋整...\n>\n> namenode 在格式化时,会创建一个 clusterID 在/tmp/dfs/name/current 里\n>\n> datanode 会去认领这个 cluterID, 这样 namenode 跟 datanode 就关联上了.\n>\n> 如果格式化,会导致集群 id 不一致, \n>\n> 所以, 一定要格式化时:\n>\n> 先删除 data/tmp/dfs/data (和 log 日志,可选),然后再格式 namenode.\n\n\n\n\n\n## refs \n [[../Resources/BigData Resources#HDFS概述]]\n \n[[HDFS 命令]]\n[[HDFS 写流程]]\n[[HDFS 读流程]]\n[[HDFS 安全策略]]\n\n\n",
                    "title": "HDFS"
                  },
                  {
                    "path": "Big Data/NameNode.md",
                    "content": "#bigdata  #docs/whatis-why-explanation \n\n![image-20200104001424636](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20200104001424636.png)\n\n1. nn 启动时会加载 fsimage.\n2. 然后加载 edits\n3. 然后立刻会要求 2nn 执行一次 fsimage 和 edist 的合并\n4. 当client 有请求来时, 先写 [[DataNode]],再写 namenode 元数据到内存,将日志放入 edits_ingprogress_001 \n5. 2nn 每隔一段时间会请问 nn 要不要合并做成 checkpoint, checkpoint 的触发条件有 3 个\n   1. 一个是上面说的 nn 启动时\n   2. 再有就是`固定间隔时间`到了\n   3. 再有就是 edits `超出client动作次数范围`了\n6. 当可以合并时,nn 会将 edits_inprogress_001 改名为 edits_001 将 fsimage 交给 2nn 合并,同时生成新的 edits_002 供接下来的请求.\n7. 2nn 合并完后,将 fsimage 发送给 nn,nn 会留两个版本,一个是最新版 fsimage,一个是上一个 fsimage\n\n\n\n**固定间隔时间**设置\n\nhdfs-default.xml\n\n```xml\n<property>\n  <!-- 默认1 小时 -->\n  <name>dfs.namenode.checkpoint.period</name>\n  <value>3600</value>\n</property>\n```\n\n\n\n**超出client动作次数范围** 设置\n\nhdfs-default.xml\n\n```xml\n<property>\n  <!-- 最长动作次数 -->\n  <name>dfs.namenode.checkpoint.txns</name>\n  <value>100000</value>\n</property>\n\n<property>\n  <!-- 设定 2nn 向 nn 一分钟 请求一次 checkpoint  -->\n  <name>dfs.namenode.checkpoint.check.period</name>\n  <value>60</value>\n</property>\n\n\n```\n\n\n## Secondary NameNode 职责 \n\n>  注意:Secondary NameNode  并不是 NameNode 的备份,当 NameNode 挂掉时,它并不能马上替换 NameNode 提供服务\n\n- 辅助 NameNode, 分担其工作量,比如定期合并 Fsimage 和 Edits,并推给 NameNode\n-  在紧急情况下,可辅助恢复 NameNode\n\n![image-20200103202816720](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20200103202816720.png)\n",
                    "title": "NameNode"
                  },
                  {
                    "path": "Big Data/大数据架构选型.md",
                    "content": "#bigdata  #arch #docs/how-to-guides  \n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005024746-xur8jyx.png)​\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221005024814-95s0e65.png)​\n\n‍",
                    "title": "大数据架构选型"
                  },
                  {
                    "path": "Big Data/数据压缩.md",
                    "content": "#bigdata #docs/whatis-why-explanation \n压缩减少了磁盘 IO，增加了 cpu\n运算多的数据，少用压缩， 运算也费 cpu\nIO 密集的， 多用压缩，分散 IO 压力\n\n![image-20200108000051712](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20200108000051712.png)\n\n\n\n![image-20200108000258951](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20200108000258951.png)\n\n\n\n用的最多的是 snappy 和 LZO ，因为快。 其他的基本不用，\n开启 map 端输出压缩：\n```java\n   Configuration conf = new Configuration();\n        conf.set(\"mapreduce.map.output.compress\",\"true\");\n        conf.setClass(\"mapreduce.map.out.compress.codec\", BZip2Codec.class, CompressionCodec.class);\n        Job job = Job.getInstance(conf);\n```\n\n\nreduce 输出压缩，\n```java\n        FileOutputFormat.setCompressOutput(job,true);\n        FileOutputFormat.setOutputCompressorClass(job, BZip2Codec.class);\n```",
                    "title": "数据压缩"
                  },
                  {
                    "path": "Big Data/部署选型.md",
                    "content": "#bigdata #docs/how-to-guides \n# 部署选型\n\n![image](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20221006191631-0c4lwtz.png)​\n\n‍\n",
                    "title": "部署选型"
                  },
                  {
                    "path": "CSS/Place background image relative to border.md",
                    "content": "#css  #docs/how-to-guides \n\n``` css \ndiv {\n  background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat blue;\n  background-position: right 0px bottom 0px;\n  /* background-origin: border-box; */\n  border: 10px solid greenyellow;\n  box-sizing: border-box;\n  width: 100vw;\n  height: 100vh;\n}\n```\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221221175129904.CXfFR.jpg)\n\nIf I toggle [background-origin](https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin) back. The image would locate relative to the border instead of content-box;\n``` css \ndiv {\n  ...\n  background-origin: border-box;\n  ...\n}\n```\n\n ![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221221175344277.yIyZd.jpg)\n",
                    "title": "Place background image relative to border"
                  },
                  {
                    "path": "CSS/SASS 里 @mixin 与 @import 的区别.md",
                    "content": "#css #docs/whatis-why-explanation \n@mixin 必须要被选择器包含, 且与  @include  命令配合使用 \n\n``` scss\n@mixin button {  \n    font-size: 1em;  \n    padding: 0.5em 1.0em;  \n    text-decoration: none;  \n    color: #fff;  \n    @content;  \n}\n\n.button-green {  \n    @include button {  \n        background: green  \n    }\n}\n\n```\n\n\n\n❌ 下面的例子就是一个反面教材，它是不会工作的。\n``` scss \n@mixin button {  \n    font-size: 1em;  \n    padding: 0.5em 1.0em;  \n    text-decoration: none;  \n    color: #fff;  \n    @content;  \n}\n\n@include button {  \n    background: green;  \n};```\n@import 是文件之间的包含。\n\n\n## reference \n[Sass：@mixin和@extend该如何选择 | Sass中文网](https://www.sass.hk/skill/sass141.html)",
                    "title": "SASS 里 @mixin 与 @import 的区别"
                  },
                  {
                    "path": "Definitions/风险 Vs. 问题.md",
                    "content": "#docs/whatis-why-explanation \n\n[[风险]]是未发生的 [[问题]]是已存在的，\n\n风险和问题是可以互相转化的。就向上面所说的，风险是会对项目产生影响的不确定事件，所以要识别风险，是要在项目前期做出大量的假设的，当假设不成立时，假设就会转化为风险，那么当一个确定的风险已经发生，那么就会成为问题。这就是风险和问题之间的关系。",
                    "title": "风险 Vs. 问题"
                  },
                  {
                    "path": "Devleop obsidian plugin Tutorial.md",
                    "content": "#obsidian  #dev  #docs/tutorials \n\n主要开发步骤根据官方文档来即可。主要说一下官方文档没说的。\n\n\n## 怎么调试\n1 下载完 demo 仓库后。 yarn dev 运行之\n2 用 ln 命令行将 dist 目录 link 到 vault 的 .obsidian/plugins 文件夹下\n\n```\nln -fs /Users/zk/git/obsidian_plugin/obsidian-evergreen/dist '/Users/zk/Library/Mobile Documents/iCloud~md~obsidian/Documents/note/.obsidian/plugins'\n```\n \n\n\n## 参考文档\n[Obsidian 中文开发文档 | Obsidian 插件开发文档](https://luhaifeng666.github.io/obsidian-plugin-docs-zh/)\napi 文档 [Workspace | Obsidian Plugin Developer Docs](https://marcus.se.net/obsidian-plugin-docs/reference/typescript/classes/Workspace)\n",
                    "title": "Devleop obsidian plugin Tutorial"
                  },
                  {
                    "path": "EverGreen Note/EverGreen Note Methodology.md",
                    "content": "#evernote #docs/tutorials \n\n![400](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221125025530049.kO2lQ.jpg)\n\n提出这个方法的作者是 [Andy Matuschak](https://notes.andymatuschak.org/z4SDCZQeRo4xFEQ8H4qrSqd68ucpgE6LU155C)， 常青笔记的提出目的主要是渴望积累个人知识，而不是简单地获取信息。\n \n1. [[Evergreen notes should be atomic]]\n2. [[Evergreen notes should be concept-oriented]]\n3. [[Evergreen notes should be densely linked]]\n4. [[Prefer associative ontologies to hierarchical taxonomies]]\n5. [[Write notes for yourself by default, disregarding audience]]\n \n\n## reference \n[让笔记流动起来：从常青笔记到渐进式归纳 - Effie Blog](https://blog.effie.co/%E8%AE%A9%E7%AC%94%E8%AE%B0%E6%B5%81%E5%8A%A8%E8%B5%B7%E6%9D%A5%EF%BC%9A%E4%BB%8E%E5%B8%B8%E9%9D%92%E7%AC%94%E8%AE%B0%E5%88%B0%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%BD%92%E7%BA%B3/)\n[2020-05-04 Note-writing livestream - YouTube](https://www.youtube.com/watch?v=DGcs4tyey18&ab_channel=AndyMatuschak)\n\n\n ",
                    "title": "EverGreen Note Methodology"
                  },
                  {
                    "path": "Future 与 Promise 区别.md",
                    "content": "#docs/whatis-why-explanation  #basic \n \n\n(I'm not completely happy with the answers so far, so here is my attempt...)\n\nI think that [Kevin Wright's comment](https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise#comment32511183_14541975)\n\n> You can make a Promise and it's up to you to keep it. When someone else makes you a promise you must wait to see if they honour it in the Future\n\nsummarizes it pretty well, but some explanation can be useful.\n\n[Futures and promises](http://en.wikipedia.org/wiki/Futures_and_promises) are pretty similar concepts, the difference is that a future is a read-only container for a result that does not yet exist, while a promise can be written (normally only once). The Java 8 [CompletableFuture ](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)and the Guava [SettableFuture](http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/SettableFuture.html) can be thought of as promises, because their value can be set (\"completed\"), but they also implement the Future interface, therefore there is no difference for the client.\n\nThe result of the future will be set by \"someone else\" - by the result of an asynchronous computation. Note how [FutureTask](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html) - a classic future - *must* be initialized with a Callable or Runnable, there is no no-argument constructor, and both Future and FutureTask are read-only from the outside (the set methods of FutureTask are protected). The value will be set to the result of the computation from the inside.\n\nOn the other hand, the result of a promise can be set by \"you\" (or in fact by anybody) anytime because it has a public setter method. Both CompletableFuture and SettableFuture can be created without any task, and their value can be set at any time. You send a promise to the client code, and fulfill it later as you wish.\n\nNote that CompletableFuture is not a \"pure\" promise, it can be initialized with a task just like FutureTask, and its most useful feature is the unrelated chaining of processing steps.\n\nAlso note that a promise does not have to be a subtype of future and it does not have to be the same object. In Scala a Future object is created by an asynchronous computation or by a *different* Promise object. In C++ the situation is similar: the promise object is used by the producer and the future object by the consumer. The advantage of this separation is that the client cannot set the value of the future.\n\nBoth [Spring](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/AsyncResult.html) and [EJB 3.1](http://docs.oracle.com/javaee/7/api/javax/ejb/AsyncResult.html?is-external=true) have an AsyncResult class, which is similar to the Scala/C++ promises. AsyncResult does implement Future but this is not the real future: asynchronous methods in Spring/EJB return a different, read-only Future object through some background magic, and this second \"real\" future can be used by the client to access the result.\n\n‍\n\n[https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise](https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise)\n\n‍\n\n‍\n\n‍\n",
                    "title": "Future 与 Promise 区别"
                  },
                  {
                    "path": "Github release.md",
                    "content": "  #docs/how-to-guides \nOnly triggered when tag being pushed\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221231181135145.vPHTf.jpg)\n",
                    "title": "Github release"
                  },
                  {
                    "path": "K8s CPU limit 会降低服务性能.md",
                    "content": "#k8s #docs/how-to-guides \n \n添加K8S CPU limit会降低服务性能？\n \n[云计算](https://www.51cto.com/cloud.html)[云原生](https://www.51cto.com/cloudnative.html)\n\n谷歌的最佳实践告诉你，重要服务一定要配置 Guaranteed 的，这样在资源不足的时候可以保证你的重要服务不被驱逐。\n\n众所周知,Kubernetes QOS 分为三个级别：\n\n- Guaranteed：Pod 里的每个容器都必须有内存/CPU 限制和请求，而且值必须相等。如果一个容器只指明limit而未设定request，则request的值等于limit值。\n- Burstable：Pod 里至少有一个容器有内存或者 CPU 请求且不满足 Guarantee 等级的要求，即内存/CPU 的值设置的不同。\n- BestEffort：容器必须没有任何内存或者 CPU 的限制或请求。\n\n谷歌的最佳实践告诉你，重要服务一定要配置 Guaranteed 的，这样在资源不足的时候可以保证你的重要服务不被驱逐。\n\n最佳实践要求你这样配置是从运维和后期运营的角度来说的，团队刚起步，不设置资源请求和限制的情况下基本可以正常工作，但随着团队和项目的增长，您将开始遇到稳定性问题。服务之间相互影响，这时候可能需要为服务添加限制，并且可以让您免于遇到许多令人头疼的问题。\n\n这里我们应该已经清楚，通过遵循最佳实践，使整个集群具有更大的灵活性和可靠性。\n\n但是当涉及到 CPU 限制时，事情就变得有趣了。CPU 是可压缩资源。如果您的应用开始达到 CPU 限制，Kubernetes 就会开始限制您的容器。这意味着 CPU 将受到人为限制，使您的应用程序性能可能更差！\n\n### 1. 为什么会这样呢？\n\n因为当你在容器编排器中设置硬 CPU 限制时，内核使用完全公平调度程序 (CFS) Cgroup来强制执行这些限制。CFS Cgroup 机制使用两个设置来管理 CPU 分配：配额和周期。当应用程序在给定时间段内使用超过其分配的 CPU 配额时，它会受到限制，直到下一个时间段。\n\ncgroup 的所有 CPU 指标都位于`/sys/fs/cgroup/cpu,cpuacct/<container>`. 配额和期间设置位于`cpu.cfs_quota_us`和中`cpu.cfs_period_us`。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/13ea12e320585a81321654b4f55e575e5a8eea.png)\n\n您还可以查看限制指标 cpu.stat。在里面 cpu.stat 你会发现：\n\n- nr_periods– cgroup 任何线程可运行的周期数\n- nr_throttled– 应用程序使用其全部配额并受到限制的可运行周期数\n- throttled_time– 控制 cgroup 中各个线程的总时间\n\n### 2. 举个简单的例子\n\n单线程应用程序在具有 cgroup 约束的 CPU 上运行。此应用程序需要 200 毫秒的处理时间来完成一个请求。不受约束，它的响应看起来如下图。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/e5866643415e6c9c9b8276ac757242f0a9baac.png)没有配置限制的请求\n\n现在，假设我们为应用程序分配了 0.4 CPU 的 CPU 限制。这意味着应用程序每 100 毫秒周期获得 40 毫秒的运行时间——即使这些时间 CPU 没有其他工作要做。200 毫秒的请求现在需要 440 毫秒才能完成。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/014b32507cc01fd60fa210f190a4cbb62ce7b7.png)配置限制的请求\n\n这个时候你查看下所在容器路径下的 cpu.stat throttled_time 你会发现被限制了 240ms（对于每 100 毫秒的周期，应用程序只能运行 40 毫秒，并被限制 60 毫秒。它已被限制了 4 个周期，因此 4 * 60 = 240 毫秒。）\n\n换一个通俗点的说法，当您要求 1 个 CPU 时，这意味着您的应用程序每秒可以使用 1 个 CPU 内核。如果它是一个单线程，它将能够一直使用一个内核。但是，如果它有 2 个线程，则每秒可以无限制地使用 2 个核心秒。因此，有了这个限制，它可以在 1/2 秒内完全使用 2 个核心，然后会受到限制。（虽然这并不是真正以秒为单位来衡量的，实际是us，但我发现这样更容易理解）。\n\n看到这里，你可能会说，这只是一种约束，超出范围的资源，就是不能使用，否则将被限制。\n\n### 3. 是否存在不必要的限制\n\n并没有这么简单，很多人反馈遭到了不必要的 cgroup 限制，甚至还没有 CPU 上限，这里有激烈的讨论：\n\n1. `https://github.com/kubernetes/kubernetes/issues/67577`\n2. `https://github.com/kubernetes/kubernetes/issues/51135`\n3. `https://github.com/kubernetes/kubernetes/issues/70585`\n4. `https://github.com/kubernetes/kubernetes/pull/75682`\n\n运行容器时要检查的关键指标是throttling. 这表明您的容器被限制的次数。我们发现很多容器无论 CPU 使用率是否接近极限都会受到限制。如下一个热心网友反馈的案例：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/d783d7385a2499a0b6c85853a7b44017955d80.png)\n\n在动画中可以看到 CPU 限制设置为800m（0.8 个核心，80% 的核心），峰值使用率最高为200m（20% 的核心）。看到之后，我们可能会认为我们有足够的 CPU 让服务在它节流之前运行，对吧？. 现在看看这个：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/02d55bc63299329d839421113347e41cfb0adf.gif)\n\n即使 CPU 使用率低于 CPU 限制，您也会注意到发生了 CPU 限制。最大 CPU 使用率甚至没有接近 CPU 限制。\n\n限制就意味着服务性能下降和延迟增高。\n\n### 4. 什么原因导致的呢？\n\n本质上来说，这个问题是 linux 内核导致，具体可以看下这个视频：`https://www.youtube.com/watch?v=UE7QX98-kO0`\n\n这个视频大概意思是这样的。\n\n这里有一个多线程守护进程的例子，它有两个工作线程，每个工作线程都固定在自己的核心上。如下图，第一个图显示了 cgroup 在一段时间内的全局配额。这从 20ms 的配额开始，这与 0.2 CPU 相关。中间的图表显示分配给每个 CPU 队列的配额，底部的图表显示实际工作线程在其 CPU 上运行的时间。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/033ac991878d1b5d7e9206ad7072f5059d0708.png)\n\n#### 在 10 毫秒：\n\n- Worker 1 收到了一个请求。\n- 一部分配额从全局配额转移到 CPU 1 的每个 CPU 队列。\n- Worker 1 需要 5ms 来处理和响应请求。\n\n#### 在 17 毫秒：\n\n- Worker 2 收到了一个请求。\n- 一部分配额从全局配额转移到 CPU 2 的每个 CPU 队列。\n\nWorker 1 需要精确 5 毫秒来响应请求的机会是非常不现实的。如果请求需要其他一些处理时间会发生什么？\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/d7da668562dfe63d79615383ddedbdf51e5e29.png)\n\n#### 在 30 毫秒：\n\n- Worker 1 收到了一个请求。\n- Worker 1 只需要 1 毫秒来处理请求，而 CPU 1 的每个 CPU 存储桶上还剩下 4 毫秒。\n- 由于每个 CPU 运行队列上还有剩余时间，但 CPU 1 上没有更多可运行线程，因此设置了一个计时器以将 slack 配额返回给全局存储桶。这个定时器在worker 1停止运行后设置为7ms。\n\n#### 在 38 毫秒：\n\n- CPU 1 上设置的 slack 计时器触发并将除 1 ms 之外的所有配额返回到全局配额池。\n- 这会在 CPU 1 上留下 1 毫秒的配额。\n\n#### 在 41 毫秒：\n\n- Worker 2 收到一个长请求。\n- 所有剩余时间都从全局存储桶转移到 CPU 2 的 per-CPU 存储桶，Worker 2 使用所有时间。\n\n#### 在 49 毫秒：\n\n- CPU 2 上的 Worker 2 现在在未完成请求的情况下受到限制。\n- 尽管 CPU 1 仍有 1ms 的配额，但仍会发生这种情况。\n\n虽然 1 毫秒可能对双核机器没有太大影响，但这些毫秒在高核数机器上加起来。如果我们在 88 核 (n) 机器上遇到此行为，我们可能会在每个周期内耗费 87 (n-1) 毫秒。那可能无法使用的 87 毫秒或 0.87 CPU（每个Container）。这就是我们通过过度节流来达到低配额使用的方式。在最好的情况下，如果修复，使受影响的应用程序的每个实例的可用 CPU 增加 0.87，或者所需的 CPU 配额相应减少。这些优势将在我们的集群中提高应用程序密度并缩短应用程序响应时间。\n\n当 8 核和 10 核机器这个问题基本上没有引起注意。现在核心数量风靡一时，这个问题变得更加明显。这就是为什么我们注意到在更高核心数的机器上运行同一应用程序时会增加限制。\n\n总结来说，时钟偏差限制问题，这导致每个时期的配额都受到严格限制。这个问题一直是存在的，至少自提交 512ac999 和内核 v4.18 以来，它就是这样工作的。\n\n### 5. linux 内核是如何解决这个问题\n\n当且仅当每个 CPU 的过期时间与全局过期时间匹配时，预补丁代码才会在运行时过期`cfs_rq->runtime_expires != cfs_b->runtime_expires`。通过检测内核，我证明了这种情况在我的节点上几乎从未出现过。因此，那 1 毫秒永不过期。该补丁将此逻辑从基于时钟时间更改为周期序列计数，解决了内核中长期存在的错误。代码如下：\n\n复制\n\n```\n- if (cfs_rq->runtime_expires != cfs_b->runtime_expires) { \n+ if (cfs_rq->expires_seq == cfs_b->expires_seq) { \n               /* 延长本地期限，漂移以 2 个滴答为界 */ \n                cfs_rq->runtime_expires + = TICK_NSEC; \n       } else { \n                /* 全局截止日期提前，过期已过 */ \n                cfs_rq->runtime_remaining = 0; \n        }1.2.3.4.5.6.7.8.\n```\n\n修改问题 5.4+ 主线内核的一部分。它们已被反向移植到许多可用的内核中：\n\n1. RHEL 7: 3.10.0–1062.8.1.el7+\n2. RHEL 8: 4.18.0–147.2.1.el8_1+\n\n- Linux-stable: 4.14.154+, 4.19.84+, 5.3.9+\n- Ubuntu: 4.15.0–67+, 5.3.0–24+\n- Redhat Enterprise Linux:\n- CoreOS: v4.19.84+\n\n该错误`https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=763a9ec06c4`已被修复并合并到运行 4.19 或更高版本的 Linux 发行版的内核中。\n\n但是，在阅读kubernetes issue时`https://github.com/kubernetes/kubernetes/issues/67577`，我们可以看到各种 Linux 项目一直在引用这个 issue，所以我猜一些 Linux 发行版仍然存在这个 bug，并且正在努力整合修复。\n\n如果你的 Linux 发行版的内核版本低于 4.19，我建议你为你的节点升级到最新的 Linux 发行版，但无论如何，你应该尝试移除 CPU 限制并查看是否有任何限制.\n\n### 6. 总结\n\n监控你的容器，是否因为 throttle 而导致的性能不佳，如果确实发生了，最好通过分批升级内核版本解决，如果无法升级，可以通过方式解决：\n\n#### 解除限制（个人觉得这个并不是一个好主意）\n\n- 有性能要求的 Pod 调度到带特定污点的节点；\n- 对这些 Pod 删除 CPU 限制，可以考虑在 namespace 级别添加限制。\n\n#### 增加资源\n\n另外 CPU throttle 节流主要是因为 CPU 限制较低。它的限制影响 Cgroup 的行为。因此，一个快速解决该问题的方法是根据监控将限值提高 10-25%，以确保降低峰值或完全避免峰值。\n\n#### 自动扩容\n\n因为将 CPU 请求和限制设置为相同的值通常会给人们他们所期望的行为，解决此问题的简单方法是将 CPU 请求和限制设置为相同的值并添加 HPA。让 Pod 根据负载进行自动扩缩容。",
                    "title": "K8s CPU limit 会降低服务性能"
                  },
                  {
                    "path": "Make Money/Make a markdown editor with OC.md",
                    "content": "#docs/how-to-guides  #makemoney  \n\nhttps://github.com/abentele/Erbele 这是一个不错的基础模板,基于 oc.能直接跑起来.\n\n\n[make a evergreen note app](../../make%20a%20evergreen%20note%20app.md)\n",
                    "title": "Make a markdown editor with OC"
                  },
                  {
                    "path": "Make Money/在 medium 上写作赚美金.md",
                    "content": "#makemoney  #docs/how-to-guides  #website/medium \n\n\n  ## 最适合程序员的副业。\n\n  ![img](https://miro.medium.com/max/1400/0*m3wv99_Ct2HMnG5Z)\n\n  Photo by [Tezos](https://unsplash.com/@tezos?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)\n\n  欢迎从《科技爱好者周刊》来的朋友。\n\n  文章被阮一峰老师的周刊推荐后，一上午的阅读量顶的上过去一年的阅读量。。。\n\n  相信经常上国外技术论坛的朋友，应该都熟悉Medium。即使你不上国外论坛，在国内的技术网站上应该也看过很多从Medium翻译过来的文章。\n\n  简单来说就是一个比较流行的博客网站。Medium用户来源多样，世界各地的都有。但是这个平台语言比较单一，英语内容占据主流。这个平台有各种话题的内容，而编程话题也占据的重要的地位。\n\n  # 如何在Medium上写作赚钱？\n\n  在传统的内容平台中,创作者主要通过两种方式赚钱\n\n  - 在文章周围插入广告，通过点击量赚取一些广告费\n  - 直接发布付费内容，用户需要按照一定的价格购买\n\n  但是Medium却选择了一个非常独特的商业模式。具体来说是这样的：\n\n  创作者在发布文章的时候，可以选择是否要将自己的文章加入付费墙(Paywall)。\n\n  如果一篇文章没有被加入付费墙，那么这篇文章和普通的博客文章一样，任何人都有权限阅读，而创作者也无法获得任何经济利益。\n\n  而如果创作者将在自己的文章加入了付费墙，那么这篇文章只有Medium的会员用户有权限阅读，创作者也有机会获得收益。\n\n  Medium的会员费固定为5美金每个月，加入Medium会员（Medium Membership）之后，就可以无限制的阅读Medium上的所有文章了。\n\n  然后Medium会按照会员读者的阅读时长这个参数来分配读者的会员费，具体操作大概是这样的。\n\n  假设我这个月在Medium上阅读了20篇文章，其中10篇是免费文章，10篇是加入付费墙后的文章。我之前说了，免费文章是不会给作者带来获得收益的，所以前面10个文章的作者还是拿不到任何收益。\n\n  而另外10篇是会员可见的文章的作者可以拿到收益，他们会按照一定的比例分享我的5美金。在2019年11月份之后，Medium的分配算法是这样的：按照读者的阅读时间比例来分配这笔钱，比如：\n\n  - 在这10篇文章中，假设我每篇文章都花了10分钟阅读，那么我这个月累积阅读时间为100分钟。那么每个文章的作者都可以从我这里获得10%的会员费，也就是每个人从我这里拿到0.5美元的收入\n  - 在这10篇文章中，假设我在第一篇文章中花了50分钟阅读，在另外9篇文章中累积花了50分钟阅读。那么第一篇文章的作者可以从我这里获得50%的会员费，也就是2.5美元的收入。\n\n  然后Medium会按照上述方式分配每位会员的会员费，分给他们阅读的文章的作者。\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*LDjzIVByaYLnL-Xa2GJlvw.png)\n\n  反正就是一个读者每个月为了会员服务需要向Medium固定支付5美金。这笔钱不是被Medium收取了，而是会被分配给那些作者。Meidum根据读者的阅读时间这个参数，按照计算后的比例将读者的钱按照比例分配给哪些作者。\n\n  同理，Medium会按照上面的方式分配它收取到的所有的会员费用，用来支持内容创作者。如果你是一个创作者，你也可以在Medium上发布文章，如果你的文章被会员用户阅读了，那么恭喜你，你赚到了美金了。创作者的收益每个自然月结算一次，收益大概会在次月的4号到10号之间汇入你的银行账户。\n\n  可以看到，Medium的付费模式非常有创意性。它要求用户，如果你想阅读高质量的会员文章，那么你必须付费。但是你又不必为每一篇文章付费，你只需要缴纳5美元，折合人民币才35元，可以说非常良心了。成为会员后，你可以无限制的阅读Medium上所有的文章。\n\n  同时，你这5美金又不是直接给特定的作者，而是通过阅读时间这个参数。好的文章会被读者反复阅读，它的作者也会获得更多的收入。\n\n  # 为什么Medium适合中国的开发者？\n\n  Medium作为一个以英语为主要语言的外网平台，我为什么还要推荐给大家呢？\n\n  我这个人比较庸俗，理由很简单：在Medium上写作可以赚钱，而且赚的是美金。\n\n  同时对于中国的程序员来说，在Medium上写作是可行的。\n\n  首先就是编程技术类话题没有文化背景的差异。无论是中国的开发者，还是美国的开发者，用的都是同一个版本的React、Vue，所面对的技术问题都是相同的。所以你在中国社区写技术文章的经验，完全可以复制到Medium。\n\n  然后就是现在机器翻译比较发达，即使你的英语不好，也可以通过Google翻译，将自己的中文文章翻译成英文。我自己在Medium上写了几百篇文章，所有的文章都是采取了中文底稿 + 机器翻译 + 后期调整 的写作模式。\n\n  最重要的一点，就是我发现中文技术社区的内容质量其实不必外网差。很多中国人写的技术分享的含金量都高于Medium上的文章不少。我认为中文内容反向输出到英文互联网是未来的一个趋势。\n\n  比如我之前曾经在掘金上写过一篇文章：\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*PJ66o5r0zUftZuxUh1GNdA.png)\n\n  *（备注：上面的文章就是我写的，不过这个账号的账号密码被我忘了，我现在已经不使用这个号了）*\n\n  这篇文章阅读量还行，不过没有给我带来任何经济收益，但是我把这个文章翻译到Medium之后，给我赚了几百美金：\n\n  [5 JavaScript Tips I Learned From Vue Source CodeLearn JavaScript from the source code of the popular JS frameworks.levelup.gitconnected.com](https://levelup.gitconnected.com/5-javascript-tips-i-learned-from-vue-source-code-6095df4e9bc1)\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*sbwLXNx1m25ra15cSX659Q.png)\n\n  # 在Medium上写作需要注意什么？\n\n  如果你也想在Medium上写作，我可以分析几个经验给你。\n\n  ## 1# 向知名Publication投稿\n\n  我们说一篇文章主要有三个流量来源\n\n  - Medium平台的推荐流量\n  - 创作者自身的粉丝流量\n  - 搜索引擎的流量\n\n  新创作者没有任何粉丝，不会有粉丝流量。而搜索引擎的流量来的很慢。所以上面三种流量来源中，最重要的就是平台的推荐流量了。\n\n  而Medium的推荐系统是算法自动判断的，对于新账号来说，隐藏信誉分会很低，所以新账号直接发布的文章必然不会被推荐。\n\n  但是如果你将文章投稿到一些知名的Publication，比如Better Programming，那么当你的文章被发布的时候，由于这些Publication的隐藏信誉分足够高，所以你的文章就有很大的概率被推荐。\n\n  适合程序员投稿的Publication有：\n\n  - [Better Programming](https://medium.com/better-programming)\n  - [Level Up Coding](https://levelup.gitconnected.com/)\n  - [JavaScript in Plain English](https://medium.com/javascript-in-plain-english)\n\n  其中Better Programming这个Publication，接受所有编程话题的文章投稿，但是这个Publication的门槛比较高，你在投稿后可能被拒稿。\n\n  JavaScript in Plain English专注于前端开发的文章，现在门槛比较低，基本上投稿都可以成功。\n\n  如果你的文章被推荐，那你在文章status页面可以看到这样的一句话：Chose for further distribution。这意味着推荐系统会推荐你的文章。\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*w4tWEh_fMpgOxa3iVALbvA.png)\n\n  如果没有这句话，就意味着Medium的推荐系统不会推荐你的文章：\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*5vnngBe5dq-Sf0rHVQkxfA.png)\n\n  没有被推荐，就意味着你的文章只会曝光在你已有粉丝的信息流中，无法获得更多的流量了。\n\n  让自己的文章被推荐很重要。被推荐的文章未必能够火（Going Viral），但是没有被推荐的文章一定无法火。\n\n  ## 2# 文章选材\n\n  如果你在Medium上赚取收益的话，那么阅读量是一个非常重要的指标。这时候如果你写的是一个非常细分领域的话题，比如WebPack XX插件解析，那么由于这种话题属于一个细分领域了，所以文章的潜在受众会比较少，那你的文章也就很难获得阅读量了。\n\n  所以大家尽量选择一些比较宽泛的话题。比如JavaScript技巧、React用法等。\n\n  ## 3# 注意文章格式\n\n  由于Medium的UI设计的特点，一篇文章最好遵守下面的格式：\n\n  - 标题\n  - 副标题\n  - 背景图\n  - 正文\n  - 标签\n\n  这样你的文章在别人的信息流中才会看起来比较舒服。\n\n  ## 4# 插入代码\n\n  Medium没有内置的代码高亮功能，但是有非常强大的Embed功能。\n\n  如果你想在Medium文章中插入代码，可以使用GitHub Gist生成一个代码片段，再把链接复制到Medium的文章编辑器中，再按下回车，这时候Medium会自动的将这个链接内嵌到文章中。\n\n  <iframe src=\"https://medium.com/media/ade47066f869d9deb6a80c64c9c0a913\" allowfullscreen=\"\" frameborder=\"0\" height=\"65\" width=\"692\" title=\"a.js\" class=\"eg aq as ag dq\" scrolling=\"auto\" style=\"box-sizing: inherit; height: 65px; top: 0px; left: 0px; width: 692px; position: absolute;\"></iframe>\n\n  甚至你可以直接把CodePen、CodeSandbox内嵌到Medium中。\n\n  - [如何在Medium的文章编辑器中插入代码以及内嵌其他网页](https://medium.com/写作之路/如何在medium的文章编辑器中插入代码以及内嵌其他网页-139a688e9e5e)\n\n  # 翻译合作\n\n  如果你对Medium写作感兴趣，但是出于一些原因不想花时间在Medium上，那你可以考虑和我合作。\n\n  合作方式：\n\n  - 你用中文写好一篇文章。\n  - 你授权我翻译你的这篇文章。\n  - 我将你的文章翻译成英文，并发布到Medium上。我仅仅是翻译一下，文章的版权保留在你自己手里。\n  - 文章赚取的收益（税后），我们五五分成。\n\n  考虑到文化背景的差异以及个人的写作习惯，目前我只翻译【前端开发】相关的文章。\n\n  我的微信：LiShuai2048\n\n  期待和您的合作。\n\n  # 部分翻译合作案例\n\n  原文：\n\n  [就因为JSON.stringify，我的年终奖差点打水漂了 - 掘金JSON.stringify，一个看似无比熟悉但却十分陌生的方法，足以把你的年终奖干泡汤。来一起重新审视它，了解它的9大特性并手写一个。juejin.cn](https://juejin.cn/post/7017588385615200270)\n\n  经原作者授权，我翻译后：\n\n  [My Friend Almost Lost His Year-end Bonus Because of JSON.stringifyA truly sad story.medium.com](https://medium.com/frontend-canteen/my-friend-almost-lost-his-year-end-bonus-because-of-json-stringify-9da86961eb9e)\n\n  文章当前数据：\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*xpiNmQMGBhEzLYShpk45qg.png)\n\n  原文：\n\n  [2022，前端的天🌦️要怎么变？ - 掘金2022的前端风向是怎样的？🌦️ 什么技术会流行？什么方向值得学习？R家还是V家？该学第二语言吗？快来看看！juejin.cn](https://juejin.cn/post/7056431876688314399)\n\n  经原作者授权，我翻译后：\n\n  [My 5 Predictions for Frontend Trends in 20221/12 of the year 2022 has passed. The frontend community still hasn’t stopped its constant pace of innovation. Below I…medium.com](https://medium.com/frontend-canteen/my-5-predictions-for-frontend-trends-in-2022-4cabd3cc66e4)\n\n  文章当前数据：\n\n  ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1*HhgGSia7pNComvzuUkFPsg.png)\n\n  # 我在Medium上的写作经历\n\n  我是在2018年，通过Google搜索问题的时候，偶然间发现Medium这个平台的。不过开始的时候，我英文不好，就没有仔细探索这个平台。\n\n  后来我发现Google经常把我导向这个网站。次数多了，我也就逐渐的熟悉了这个平台。然后我就发现了原来在Medium上写作也可以赚钱，具体方式参考上面的文章。\n\n  然后从2019年开始，我就开始在Medium上写作。当时在2019年的时候，由于我没有搞懂这个平台的玩法，加上英语也不是很好，导致在平台上写了几十篇文章后，依然没有阅读量，更是没有收益。\n\n  后来在不断的摸爬滚打中，也逐渐摸清了平台的玩法，写出了一些热门文章。\n\n  部分热门文章：\n\n  [Clean Up Your Code by Removing ‘if-else’ StatementsA step-by-step guide to making your JavaScript code more elegant.bytefish.medium.com](https://bytefish.medium.com/clean-up-your-code-by-removing-if-else-statements-31102fe3b083)\n\n  [Use Chrome DevTools Like a Senior Frontend Developer6 tips you must know if you choose Chrome as your development environment.javascript.plainenglish.io](https://javascript.plainenglish.io/use-chrome-devtools-like-a-senior-frontend-developer-99a4740674)\n\n  不知不觉已经过去了三年了。\n\n  # 我的感悟\n\n  这段写作经历，让我有两个感触比较深的东西。\n\n  一个是技术写作是最适合程序员的副业。作为一个程序员，我们总是需要通过写笔记或者文章来沉淀自己的技术。如果自己的经验总结还能顺便赚一点小钱那就更好了。\n\n  第二个感悟就是中文技术社区的知识水平不比英文社区差。我在Medium上看到很多比较水的文章上了热门；而很多我在中文社区看到的很多技术文章，写的比外网好多了。\n",
                    "title": "如何在Medium上写作赚钱？"
                  },
                  {
                    "path": "Make Money/基金筛选.md",
                    "content": "#funds  #docs/how-to-guides  #makemoney \n\n[https://www.morningstar.cn/fundselect/default.aspx](https://www.morningstar.cn/fundselect/default.aspx)![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654020100021-58a2ba74-c73f-4f6d-9f25-4ab81981ee8b.png)",
                    "title": "基金筛选"
                  },
                  {
                    "path": "Make Money/怎么赚钱.md",
                    "content": "#makemoney   #docs/how-to-guides \n一个普通人想挣钱，首先得明白挣钱的[[道法术器]]\n赚钱在高手眼里就一场游戏，有它自己的游戏规则\n\n## 赚钱之道\n1.  人性逻辑, 如 [[影响力]]\n2.  利益逻辑\n\n何为人性逻辑？\n你问男生喜欢什么样的女生，他说喜欢善良的，优雅的。可最终他选择跟大胸的结婚。\n人性有两条线，一条明线，明线写满了仁义道德。一条暗线，暗线写满了黑暗法则，不可言说\n所以不要看一个说了什么，看一个做了什么\n不要只看见他身上的明线， 要看他他身上的暗线，这就是最基本的人性逻辑\n\n何为利益逻辑？\n一个问题：是不是只要一款产品质量足够好就可以卖爆？\n未必。\n那什么样的产品可以卖爆？\n可以让其他人更容易赚到钱的产品更容易卖爆，这里的其他人包括供应商，经销商，合作方，与消费者。\n因为它让利益链条上的所有参与方都赚到了钱，相对于仅仅是质量好的产品，后者更符合利益逻辑。利益逻辑决定了整个游戏规则的根基。\n\n  \n\n## 赚钱之法\n你有什么？你要什么，你放弃什么？\n你有什么，就是搞清自己的核心能力和手头资源，这决定了你的起手式\n你要什么，就是搞清息怕[[价值观|三观]]和目标，因为它会影响你的心力，以及你的终局。\n你放弃什么？ 就是建立清晰的财务逻辑和止损边界，知道什么时候该孤注一掷，什么时候该壮士断腕。\n\n## 赚钱之术\n为什么文艺女青年开花店，咖啡店，奶茶店，书店总是失败？\n原因就是空有情怀，却无心力，更无手法\n\n何为手法？\n怎么让店员听话？怎么找到便宜的原料且能保证品质？ 怎么设计招牌，怎么设计套餐让顾客多买东西?\n你能够不厌其烦地解决几十个甚至上百个类似这样的琐碎小问题，从而让一家店健康地运营下去。你就掌握了生意手法。\n\n生意手法往往琐碎，微妙，不可说，它们需要你在生意中一点一点磨出来，却决定着你是否真的可以赚钱。\n\n## 赚钱之器\n简单来说，你要打造属于自己的赚钱[[系统]]。\n一个好的赚钱系统往往符合以下标准：\n1. 不靠出卖个人时间和体力赚钱，而是借助别人，资源，和平台放大自己的能力与时间。\n2. 比个人有更强的稳定性和搞风险能力。\n3. 源源不断的被动收益。\n4. 有护城河\n\n道决定了根基\n法决定了方向\n术决定了效率\n器决定了周期",
                    "title": "怎么赚钱"
                  },
                  {
                    "path": "Make Money/收益率算法.md",
                    "content": "#docs/how-to-guides  #funds  #makemoney \n\n![](https://cdn.nlark.com/yuque/0/2022/png/2570362/1654009662268-e72b5a59-488b-455b-8dce-1043cf871c85.png)\n\n比如年化收益率10%， 投4年， 那就是 46.41% 的收益\n\n(1+10%)p +(1+10%)(1+10%)p\n\n十年期国债与纯债是反比关系",
                    "title": "收益率算法"
                  },
                  {
                    "path": "Make Money/混合止盈.md",
                    "content": "\n#funds  #docs/how-to-guides  #makemoney \n\n混合止盈\n\n1.  设置心里止盈区间， 如 9%~ 12% ， 达到 12% 则全部止盈。 这里设置上下限就是不宜过高与过低。\n2.  若触发 9%， 如果宽基指数都是高估状态，则做第一次分批止盈\n3.  根据随后行情， 持续分批止盈， 稳健可以设为 5%， 激进的可以设 10%。 分批止盈要比前次多。因为风险更大。\n4.  出现大幅回撤或触发止盈上线， 全部卖出，止盈离场。别贪。",
                    "title": "混合止盈"
                  },
                  {
                    "path": "Managment/WBS.md",
                    "content": "---\naliases: [工作分解]\n---\n#managment  #methodolgy #docs/how-to-guides \n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229161113197.m5Pii.jpg)\n\n- WBS 应用用图表形象地表示项目范围。以利于解释为什么项目花了这么多钱。\n- WBS 提供了分配资源的基础。  \n- WBS 帮助你估计每项工作持续的时间。",
                    "title": "WBS"
                  },
                  {
                    "path": "Managment/刘易斯管理方法.md",
                    "content": "---\naliases: [刘易斯方法,刘易斯]\n---\n#managment  #docs/whatis-why-explanation \n\n \n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229143902764.JgSSq.jpg)\n\n 第 6 步比较复杂， 单独一张图\n \n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229143909658.9Qwg8.jpg)\n",
                    "title": "刘易斯管理方法"
                  },
                  {
                    "path": "Managment/加班的后果.md",
                    "content": "---\naliases: [为什么不要加班]\n---\n#managment  #docs/whatis-why-explanation \n\n![500](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229132359685.v23Vf.jpg)\n\n ",
                    "title": "加班的后果"
                  },
                  {
                    "path": "Managment/复盘.md",
                    "content": "#methodolgy  #managment  #docs/how-to-guides \n \n是 [[PDCA|PDCA]]  里的 Check 与  Act 环节。\n \n简单可执行的技术复盘方法分为四个部分，目标回顾、结果陈述、过程分析和归类总结。\n\n1. 目标回顾，当初的技术目标是什么，包括定性和定量的目标；如果有余力可以分析下这个目标制定的是否合理。\n2. 结果陈述，现在的客观结果是什么，与目标比哪些好哪些差。\n3. 过程分析，好的点和差的点原因分别是什么，包括主观和客观原因；有过有余力可以分析下为什么好的点没能够更好，而差的点没能够及时止损。\n4. 归类总结，对于好的点要找到其中的规律，最好达到可复制，沉淀下来作为武器库中的一员；对于差的点要分析原因并找到对应的解决方案，沉淀下来作为知识库中的一员；如果有余力可以把总结下来的东东，再重新带入或重新演练一遍，看看正确性几何。\n\n ",
                    "title": "复盘"
                  },
                  {
                    "path": "Managment/如何落地 Scrum.md",
                    "content": "\n#methodolgy  #managment  #docs/how-to-guides \n\n[[Scrum|Scrum]] 的本质，是把一次漫长的长跑，分割成一段段全力以赴的冲刺，通过[[流程|流程]]提高效率。完成预期[[目标|目标]]。\n\n敏捷强调个体之间的互动，要求能够发布可以工作的成果，提倡跟客户建立合作共赢，也推崇拥抱变化的思维。\n\n在十多年前来看，敏捷确实是一套先进的方法论，虽然在传统软件开发领域，其实大家更在意的是流程、工具、文档、合同、[[计划|计划]]这类不变的东西，但是人们所处的外界环境在不断变化，面对的业务也在不断变化，人们常说“唯一不变的就是变化”。逐渐地，人们开始接受敏捷，并认同它所主导的核心价值。\n\n另外，在敏捷宣言提出后，业界也出现了一些偏实践的敏捷方法，例如：XP 极限编程、Scrum 敏捷方法、看板等。而这些敏捷方法中包括了很多有价值的工具，比如，每日站会、结对编程、代码评审、持续集成、测试驱动、计划扑克等。\n\n由 Product Owner（产品负责人）负责维护 Product Backlog（需求池），由 Scurm Master（项目负责人）召开 Sprint Plan Meeting（计划会议）和 Daily Scrum Meeting（站立会议），最后全员一起参与 Sprint Retrospective Meeting（回顾会议）。 \n\n![p-23.png](https://blog.michealwayne.cn/images/okr/p-23.png)\n\n实质上，Scrum 敏捷方法的核心思想，就是将不断变化的业务需求放入 Product Backlog， Product Owner 从 Product Backlog 中取出优先级较高的需求并将其放入 Sprint 迭代中，随后定期发布一次迭代，每次发布都需向客户交付可以工作的软件。\n\n此外，Scrum 的会议也在此过程中扮演了重要的角色，不仅跟踪了进度，也能起到[[计划|计划]]和复盘的作用。\n\n可见，每次 Sprint 的迭代都是一个固定的阶段，该阶段包括了一些具体的任务，我们通过完成这些任务去实现阶段性的目标。这样一来，基于“任务驱动”的方式看似敏捷，而在实际应用过程中，往往又会遇到一些现实问题。\n",
                    "title": "如何落地 Scrum"
                  },
                  {
                    "path": "Managment/怎么制定计划.md",
                    "content": "#managment  #docs/how-to-guides \n \n如果你想做一个好的、而且被你的团队所接受的计划，就让他们参与到计划制订中来。\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229151440779.UKiBD.jpg)\n",
                    "title": "怎么制定计划"
                  },
                  {
                    "path": "Managment/怎么定义项目是成功的.md",
                    "content": "#managment  #docs/how-to-guides \n\n并不是一个简单的是非选择。因为有人的参与。 通常结果如下图所示。\n \n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221229141915797.u5KYT.jpg)\n",
                    "title": "怎么定义项目是成功的"
                  },
                  {
                    "path": "Managment/怎么应对风险.md",
                    "content": "---\naliases: [应对风险]\n---\n#managment #docs/how-to-guides \n\n减轻——努力做某些事情来减少事件造成的危害。\n避免——努力防止这样的事件发生。\n转移——把[[风险]]转移给他人。保险就是个风险转移的例子。把工作转包给其他人做也可以是一种风险转移。\n接受——接受风险并且不采取任何特殊的行动去处理它，我们开车的时候就是采取这种策略（系安全带是一种试图减少车祸伤害的办法）。 ",
                    "title": "怎么应对风险"
                  },
                  {
                    "path": "Managment/技术岗位能力模型.md",
                    "content": "#docs/whatis-why-explanation  #managment \n\n>岗位是否能够区分，主要在于各岗的工作内容之间是否有明确的接口。 如果并没有，那其实应该调整此岗工作内容，或减少与合并岗位\n\n\n[[CTO]]\n[[技术 VP]]\n[[技术总监]]\n[[研发经理]]\n[[首席架构师]]\n[[架构师]]\n[[技术专家]]\n[[技术组长]]\n[[工程师]] ",
                    "title": "技术岗位能力模型"
                  },
                  {
                    "path": "Managment/敏捷研发管理体系.md",
                    "content": "---\naliases: [Agile]\n---\n#managment  #docs/reference\n\n\n纵观各类科技企业，由于自身所处环境不同，因此其软件研发管理模式也不尽相同，这其中有基于CMMI能力成熟度模型指导下构建的研发管理体系，也有基于IPD集成产品研发框架指导下构建的研发管理体系，当然也有一些目前不少小企业、互联网企业推崇的敏捷研发管理体系。\n\n[[CMMI]] \n[[IPD]]\n[[Scrum]]\n\n这三种开发模式中，IPD的层级最高，既包括了“做正确的事”，又包括了“把事情做正确”，是公司级的运营级流程，CMMI和敏捷是同一个层级流程，是工程方面的实践级流程。CMMI和敏捷不具备高层决策能力，而一种“把事情做正确”的开发模式。\n\n华为公司早在2009年正式发文在全公司现在流程IPD、CMMI的基础上，所有产品线的软件开发团队全面推行敏捷开发，可见这三个体系并不是孤立存在的，而是可以相融互补的。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/5ydkcFjmuZpWvvChBUFR.jpeg)\n\n由上图所示IPD关注整个产品的开发管理，包括市场、开发（软件、硬件）、结构、生产、采购、财务等各个方面，CMMI/Agile流程关注其中的软件研发过程的管理，CMMI是在研发过程中走瀑布模型，而敏捷是走版本迭代的模式。\n\n所以如何建设自己的研发体系，并没有标准的答案，而要关注自己团队的发展阶段、规模大小、业务形态，根据上面三个体系的指导，建立一个适合自己发展研发体系。而且研发体系也不是一成不变的，也要根据业务的变化不断的迭代调整，以符合业务发展的需要。\n\n",
                    "title": "敏捷研发管理体系"
                  },
                  {
                    "path": "Managment/项目开发流程.md",
                    "content": "#docs/how-to-guides  #managment \n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223130342729.OeCxU.jpg)\n\n \n‍\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221223130353458.aFrHm.jpg)\n\n",
                    "title": "项目开发流程"
                  },
                  {
                    "path": "Math/Obsidian scheme tweak.md",
                    "content": "#obsidian  #docs/how-to-guides \n\n\n``` css \n.theme-light,\nbody.theme-light.is-mobile {\n--file-line-width: 1000px;\n}\n```\n\n\n\n``` css \n  \n\ntable {\n\twidth: 100%;\n}\n\nthead {\n\tbackground-color: rgb(101, 101, 101);\n}\n\nth {\n\tcolor: white !important;\n}\n\ntr:nth-child(even) {\n\tbackground-color: #f2f2f2 !important;\n}\n\n  \n  \n/* center image*/\n.markdown-source-view.mod-cm6 .cm-content > img {\n\t/* margin: 0 auto !important; */\n\tdisplay: block;\n\tmargin: 0px auto !important;\n}\n```\n\n ",
                    "title": "Obsidian scheme tweak"
                  },
                  {
                    "path": "My Canada migration Plan/枫叶卡与加拿大入籍怎么选？.md",
                    "content": "#canada  #docs/how-to-guides \n## 申请入籍优先\n**喜欢涉足政治**\n社会福利、医疗保障，在你有PR卡时已经基本能享受完全。但是，PR卡的拥有者是没有选举权和被选举权的。\n如果你热衷于参与加拿大政治，想投票参选自己信赖的政党，甚至想自己尝试投身政坛，那么申请入籍是必须要做的。\n\n**喜欢说走就走的旅行**\n这一点，是很多申请入籍者的最大原因——加拿大护照。众所周知，加拿大护照在西方国家都是免签的，比如旅行圣地欧洲。\n拥有加拿大护照，确实可以“说走就走”，而不是先想方设法办签证。这一点原因，让很多旅游爱好者心动，从而选择了入籍。\n\n## 保留 [[Permanent Resident|PR]] 卡优先\n**频繁回国**\n当你入籍加拿大，你就和中国公民彻底无关了。无论回国出差还是探亲，都要去大使馆办理中国签证，每次还需缴纳费用。\n\n不要以为你说中文就一定可以拿到中国签证——你是有被各种理由拒签的风险的。所以，如果你有家人或事业在国内，且要频繁回国，最好还是先把入籍事情放一放。虽然申请中国旅游签证不算复杂，但条条框框的限制还是会让你觉得：我明明是中国人，为何回次国都那么憋屈？\n\n## 入籍和 PR 区别不大\n**爱去美国**\n加拿大的核心城市都在美加边境，所以自然有一批人会频繁前往美国。从这一点考虑的话，区别并不大。如果你入籍加拿大，自然可以免签;但即便你拿的是PR卡，也可以办理一个10年的旅游签证。\n\n办理流程非常简单，一般在几天内就能搞定。所以，从去美国角度考虑，PR和入籍并无太大差别。\n\n总结一下，从提升幅度来看，从临时签证到PR卡是一次大幅提升，而PR卡到国籍对大多数人而言则只是一个小幅提升。毕竟并不是所有人都热衷环球旅行，也不是所有人都喜欢参与政治。\n\n所以，在入籍和拿PR之间选择时，要想好自己的需求是什么，自己的未来打算是什么，以及考虑到自己家人的状况，听取他们的意见，那么你的决定会是理性的。\n\n ",
                    "title": "枫叶卡与加拿大入籍怎么选？"
                  },
                  {
                    "path": "OAtuth 2.0.md",
                    "content": "#auth #docs/whatis-why-explanation \n\n/Users/zk/git/javaPrj/sso\n\nOAuth 2.0 算是个一比较古老复杂的协议，看似流程没几步。 要深刻明白这个东西最好的办法就是按照[规范](https://tools.ietf.org/html/rfc6749#section-4.2d)手撸一套。\n\n它主要规范的地方是授权. 但有一个尴尬的地方. 授权前你就先得鉴权. \n\n比如你要给某个用户分配角色. 你先得确认这是你的用户吧. 比如通过账号密码确认. \n\n但 oauth 并没有规范这一块的东西. 那 OpenID 就完善了这一块. \n\n## OAuth2\n\nOAuth 2.0 它有 4 种授权方式。主要针对不同的用户场景。我们看一个各场景的适合的授权图。图中 Client 是个相对概念。比如用微信账号登陆小红书。 那小红书就是微信的 client。 \n\n![image-20190813203306900](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813203306900.png)\n\n需要前端：\n\n\n\n我们用最重要也是最复杂的 Authorized code 方式来说明一下 OAuth 2.0 的安全问题。\n\n### OAtuth 2.0  - Authorized code\n看一下场景，我要用 qq 网站账号登陆百度。 \n我就不写各角色的术语了，因为官方就定义比较混乱，比如上面场景按官方定义，那百度属于 Client，**因为它是 qq 授权服务的客户**。 我是 Resource Owner， 因为我在 qq 那存着各种资源。\n\n>  按正常人理解的话，我针对百度不也是 Client 么，qq 针对我不也是  Reosurce Owner 么。\n\n\n代码见 github，实现了上面场景的基本功能。启动服务后。\n\n默认百度在 qq 那注册了，qq 大哥，我要用你的权限服务器。好的，百度小弟。\n\nclient_id=2\n\nclient_secrect=IamSerect\n\n>  AUTHORIZATION_CODE 我写死了，code123。\n\n\n\n百度在 localhost:8081 \n\nqq在   localhost:8080\n\n![image-20190813211209531](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813211209531.png)\n\n1. 打开百度 localhost:8081，点 \"login with qq\"，跳到如下 url\n\n   ```javascript\n   http://http://localhost:8080/authorize?\n   response_type=code\n   &client_id=2\n   &redirect_uri=http://localhost:8081/callback\n   &scope=read\n   &state=fKdWioZCkGgftETZTNxaSTNWnDRnis \n   \n   ```\n\n   ![image-20190813211300269](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813211300269.png)\n\n2. 输入 qq 账号密码(admin, admin)，点提交，post 到 qq 的  /login ，qq 给我的浏览器发了个重定向到 redirect_uri 的链接，这链接后面还跟了个 code 参数，和上一步的 state\n\n   ```javascript\n   http://localhost:8081.com/callback?code=code123&state=fKdWioZCkGgftETZTNxaSTNWnDRnis\n   ```\n\n3. 百度服务端收到上面请求，检测 state 参数(可以确保上一个 authorize 请求是由百度自己发出)。 拿到 code 参数，百度服务端去跟 qq 服务端拿 token 跟 refresh token。带上CLIENT_ID 与CLIENT_SECRET 表明自己就是百度官方。（这里要注意，拿 token 已经跟浏览无关了，不一定要用http 协议）\n\n   ```javascript\n   http://localhost:8080.com/oauth/token?\n   client_id=2\n   &client_secret=IamSerect\n   &grant_type=authorization_code\n   &code=code123\n   &redirect_uri=http://localhost:8081/callback\n   ```\n\n4. 有了token 百度服务器就可以拿我的 qq 头像了，拿到后，上面那个 callback 还没返回呢！ 返回页面\n\n   ![image-20190813211445993](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813211445993.png)\n\n   \n\n   流程图如下：\n\n   ![image-20190814003051539](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190814003051539.png)\n\n    \n\n    \n\n   \n\n   直接给 browser 肯定不安全.\n\n   **那为什么不直接给百度 code  呢，还要通过 browser 中转呢？**\n\n   ![image-20190813155544468](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813155544468.png)\n\n   原因是这样.\n\n   \n\n   \n\n   **为什么要带上 redirect_url 呢？**\n\n   官方定义的原因是这样 [3.1.2.3.  Dynamic Configuration](https://tools.ietf.org/html/rfc6749#section-4.1.1)：\n\n   1. 注册了多个 redirect_url。\n   1. 只注册了 redirect_url 的一部分。\n   \n   3. 没有注册 redirect_url。\n   \n   \n   \n   但你会发现，现在很多厂商其实就强制你注册一个 redirect_url！ 也就排除了官方定义的需要带上 redirect_url的原因。\n   \n   \n   \n   那我们来分析一下官方要带上 redirect_url  的原因\n   \n   注册了多个 redirect_url：\n   \n   这个不言而预，你得告诉我回调哪个吧。\n   \n   \n   \n   只注册了 redirect_url 的一部分：\n   \n   部分 redirect_url 是指，比如你的回调地址是这样\n   \n   http://yourweb.com/callback\n   \n   回调地址写成这样  /callback ，想当然的认为 Authorization Server 会帮你根据你的域名拼成\n   \n   http://yourweb.com/callback。\n   \n   但如果不安好心的人改了回调地址变成，\n   \n    \n   \n   \n   \n   \n   \n   **为什么需要检测 state**？\n   \n   ![image-20190813172152677](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190813172152677.png)\n   \n    \n\n\n\n## Open ID\n\n1. 在返回 access_token 时, 同时返回 id_token.也就是通过 jwt 编码的用户信息\n2. 统一用户信息接口, /userinfo\n\n没啦!!\n\n\n\n   ## 参考\n\n   http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html\n\n   https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type\n\n[playground](https://www.oauth.com/playground/authorization-code.html)\n\n\n\nhttps://tools.ietf.org/html/rfc6749#section-1.3.1\n\nhttps://backstage.forgerock.com/docs/am/5/oauth2-guide/\n\nhttps://www.youtube.com/watch?v=996OiexHze0",
                    "title": "OAtuth 2.0"
                  },
                  {
                    "path": "React State/react 16 原理.md",
                    "content": "\n#react  #docs/whatis-why-explanation \n\n## 大纲 \n1. 简版 react 手写思路\n2. 对比真实源码细节\n3. 完善简版\n\n\n## 引\nreact 16 有 利用浏览器的 requestIdleCallback  来实现 fiber \n有 hook\n\n## requestIdleCallback 原理\nrequestIdleCallback 从本质上是模拟了空间时间分片. \n但不是所有浏览器都支持, 有一个 polyfill https://github.com/aFarkas/requestIdleCallback\n\n根据 3c 规范: https://w3c.github.io/requestidlecallback/\n\n触发时机\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221122134526473.q6BkU.jpg)\n\n最多 50ms\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221122134532810.sGMkE.jpg)\n\n\n在注册一次回调后, 就自动取消了. 所以得每次注册\n``` js\n    function workloop(deadline){\n      console.log(deadline.timeRemaining())  \n      requestIdleCallback(workloop);\n    }\n    requestIdleCallback(workloop);\n\n```\n\n## fiber\n\nhttps://github.com/acdlite/react-fiber-architecture\nWe've established that a primary goal of Fiber is to enable React to take advantage of scheduling. Specifically, we need to be able to\n\n-   pause work and come back to it later.\n-   assign priority to different types of work.\n-   reuse previously completed work.\n-   abort work if it's no longer needed.\n\nIn order to do any of this, we first need a way to break work down into units. In one sense, that's what a fiber is. A fiber represents a **unit of work**.\n\n就是一个数据结构, 与 dom 对应.  \n\n假设 dom 如下\n``` html\n<div id=\"root\">    \n\t<div>          \n\t   <h1> Hello </h1>\n\t</div>\n\t<div>\n\t</div>\n</div>\n```\n子: child\n父: return\n兄: sibling\n\nfiber 要保障快速的访问,\n1. 有子就访问子.\n2. 无子访问兄弟,\n3. 各节点知父.\n\n所以, 这里为什么不直接用树不就完了么? 树有个问题. 要维护状态. 而 fiber 不需要. 它将状态已经维护在了树里.\n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221122134950836.c0W3L.jpg)\n\n\n## Reconciliation \nreact 的 diffing 算法\n\n\n\n\n## 源码\n\n远程仓库: git@github.com:dennis-jiang/Front-End-Knowledges.git\n本地位置: /Users/zk/git/jsPrj/react/Front-End-Knowledges/Examples/React/fiber-and-hooks\n\n\n\n\n\n[手写 Hooks](5.轮子索引/3.前端库/react/手写%20Hooks.md)\nhttps://juejin.cn/post/6844903700717109261\n",
                    "title": "react 16 原理"
                  },
                  {
                    "path": "React State/useMemo Vs  React.memo.md",
                    "content": "#react #docs/whatis-why-explanation \n这两者是完全不一样的东西，只是名字上有点像。\nReact.memo()是通过校验props中的数据是否改变的来决定组件是否需要重新渲染的一种缓存技术。\n**具体点说React.memo()其实是通过校验Props中的数据的内存地址是否改变来决定组件是否重新渲染组件的一种技术。**\n\n而 useMemo 是类似 vue 的 watch。",
                    "title": "useMemo Vs  React.memo"
                  },
                  {
                    "path": "Resources/VPS resources.md",
                    "content": "#resources  #markdown  #docs/how-to-guides \n\n [Home | Read the Docs](https://readthedocs.org/)\n Using the rst ?\n\n\n\n\n",
                    "title": "VPS resources"
                  },
                  {
                    "path": "SASS 样式库使用.md",
                    "content": "\n#docs/tutorials \n\n## 安装 \n在工程里使用\nyarn install sass\n\n在全局使用\nyarn global add sass \n\n## 快速教程\n\n## 快速使用\n\n\n### 变量 \nSass 变量使用 $ 符号\n\n``` scss\n$myFont: Helvetica, sans-serif;  \n$myColor: red;  \n$myFontSize: 18px;  \n$myWidth: 680px;  \n  \nbody {  \n  font-family: $myFont;  \n  font-size: $myFontSize;  \n  color: $myColor;  \n}  \n  \n#container {  \n  width: $myWidth;  \n}\n```\n\n\n### 变量作用域\n局部作用域\n``` scss\n$myColor: red;  \n  \nh1 {  \n  $myColor: green;   // 只在 h1 里头有用，局部作用域  \n  color: $myColor;  \n}  \n  \np {  \n  color: $myColor;  \n}\n```\n\n=> 以上代码将转换为  \n``` css\nh1 {  \n  color: green;  \n}  \n  \np {  \n  color: red;  \n}\n```\n\n\n全局作用域\n``` scss\n$myColor: red;  \n  \nh1 {  \n  $myColor: green !global;  // 全局作用域  \n  color: $myColor;  \n}  \n  \np {  \n  color: $myColor;  \n}\n```\n\n=> 将转换为 \n``` css\n$myColor: red;  \n  \nh1 {  \n  $myColor: green !global;  // 全局作用域  \n  color: $myColor;  \n}  \n  \np {  \n  color: $myColor;  \n}\n```\n\n\n### 嵌套规则\n\n``` scss \nnav {  \n  ul {  \n    margin: 0;  \n    padding: 0;  \n    list-style: none;  \n  }  \n  li {  \n    display: inline-block;  \n  }  \n  a {  \n    display: block;  \n    padding: 6px 12px;  \n    text-decoration: none;  \n  }  \n}\n```\n\n=> 转换为\n``` css\nnav ul {  \n  margin: 0;  \n  padding: 0;  \n  list-style: none;  \n}  \nnav li {  \n  display: inline-block;  \n}  \nnav a {  \n  display: block;  \n  padding: 6px 12px;  \n  text-decoration: none;  \n}\n```\n\n\n\n### 嵌套属性\n``` scss\nfont: {  \n  family: Helvetica, sans-serif;  \n  size: 18px;  \n  weight: bold;  \n}  \n  \ntext: {  \n  align: center;  \n  transform: lowercase;  \n  overflow: hidden;  \n}\n```\n\n=> \n``` css\nfont-family: Helvetica, sans-serif;  \nfont-size: 18px;  \nfont-weight: bold;  \n  \ntext-align: center;  \ntext-transform: lowercase;  \ntext-overflow: hidden;\n```\n\n\n### 引入文件  @import\n\n1. 包含文件时不需要指定文件后缀，Sass 会自动添加后缀 .scss。\n2. 静态导入。不会产生像请求。\n\nrest.scss\n``` scss\nhtml,  \nbody,  \nul,  \nol {  \n  margin: 0;  \n  padding: 0;  \n}\n```\n\nstandard.scss\n``` scss \n@import \"reset\";  \n  \nbody {  \n  font-family: Helvetica, sans-serif;  \n  font-size: 18px;  \n  color: red;  \n}\n```\n\n\n=> \n``` css\nhtml, body, ul, ol {  \n  margin: 0;  \n  padding: 0;  \n}  \n  \nbody {  \n  font-family: Helvetica, sans-serif;  \n  font-size: 18px;  \n  color: red;  \n}\n```\n\n\n### Partials\n1. 不希望将一个 Sass 的代码文件编译到一个 CSS 文件。\n2. 在导入语句中我们不需要添加下划线。\n\n\\_color.css\n``` scss \n$myPink: #EE82EE;  \n$myBlue: #4169E1;  \n$myGreen: #8FBC8F;\n```\n\n引用\n``` scss\n@import \"colors\";  \n  \nbody {  \n  font-family: Helvetica, sans-serif;  \n  font-size: 18px;  \n  color: $myBlue;  \n}\n```\n\n**注意：请不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略。\n\n### 混入 @mixin \n讲白， 就是复制代码。\n[[CSS/SASS 里 @mixin 与 @import 的区别]]\n[[SASS 里 @mixin 与 @extend 怎么选择]]\n\n\n### 继承 @extend\n\n``` scss\n.button-basic  {  \n  border: none;  \n  padding: 15px 30px;  \n  text-align: center;  \n  font-size: 16px;  \n  cursor: pointer;  \n}  \n  \n.button-report  {  \n  @extend .button-basic;  \n  background-color: red;  \n}  \n  \n.button-submit  {  \n  @extend .button-basic;  \n  background-color: green;  \n  color: white;  \n}\n```\n\n=>\n``` css\n.button-basic, .button-report, .button-submit {  \n  border: none;  \n  padding: 15px 30px;  \n  text-align: center;  \n  font-size: 16px;  \n  cursor: pointer;  \n}  \n  \n.button-report  {  \n  background-color: red;  \n}  \n  \n.button-submit  {  \n  background-color: green;  \n  color: white;  \n}\n```\n\n\n\n### & 符号\n就是一个占位的作用， 常用在快速实现 [[BEM]] 。\n\n``` css\n.MyComponent {\n    line-height:2.2;\n    &-title{\n        font-size:16px;\n    }\n    &-content{\n        color:#f00;\n    }\n\n}\n\n \n```\n\n=>\n``` css\n//编译为\n.MyComponent {line-height:2.2;}\n.MyComponent-title {font-size:16px;}\n.MyComponent-content {color:#f00;}\n```\n\n### 函数\n用的不多，给个链接用时再查\n[Sass 字符串相关函数](https://www.runoob.com/sass/sass-string-func.html)\n[Sass 数字相关函数](https://www.runoob.com/sass/sass-numeric-func.html)\n[Sass 列表(List)相关函数](https://www.runoob.com/sass/sass-list-func.html)\n[Sass 映射(Map)相关函数](https://www.runoob.com/sass/sass-map-func.html)\n[Sass 选择器相关函数](https://www.runoob.com/sass/sass-selector-func.html)\n[Sass Introspection 相关函数](https://www.runoob.com/sass/sass-introspection-func.html)\n[Sass 颜色相关函数](https://www.runoob.com/sass/sass-color-func.html)\n\n\n## reference\n[Sass 函数 | 菜鸟教程](https://www.runoob.com/sass/sass-functions.html)",
                    "title": "SASS 样式库使用"
                  },
                  {
                    "path": "Social/怎么让人愿意做事.md",
                    "content": "#social  #docs/how-to-guides ",
                    "title": "怎么让人愿意做事"
                  },
                  {
                    "path": "Social/怎么说服别人.md",
                    "content": "#docs/how-to-guides  #social \n\n本质上这种 how 形式，都是 [[../../1.方法论/怎么解决问题 | 怎么解决问题]] 的变体。\n\n在说服人这种事上，通过挖掘本质问题，站在对方的观点里帮他找证据，用他自己的观点说服他。\n\n比如买相机，2000块， 客户说觉得贵， 那再询问客户的要的功能是什么？ 基本功能， 那基本功能是什么呢？ 像素高，续航久。 \n\n为了保证你的基本使用。 建议你买这个2000块的。",
                    "title": "怎么说服别人"
                  },
                  {
                    "path": "Social/怎么说话.md",
                    "content": "#social    #docs/how-to-guides \n\n万稳万当，不如一默。任何一句话，你不说出来便是那句话的主人，你说了出来，便是那句话的奴隶。   ---大明王朝",
                    "title": "怎么说话"
                  },
                  {
                    "path": "VS code guide.md",
                    "content": "#docs/how-to-guides  #vscode \n\n## 打开 method outline \ncmd+shift+o,  再输入 :\n ",
                    "title": "VS code guide"
                  },
                  {
                    "path": "async 在 foreach 不生效.md",
                    "content": "#js  #docs/how-to-guides \n \n## 结论\n\n不要在 forEach　里使用　async, 使用普通的 for 循环\n\n## 问题\n\n``` js\n// 大致是需要请求一个接口获取数据然后在把结果发送给另外一个接口\nlet count = 0;\nconst result = await fetchDataFromDataBase();\nresult.forEach(async (item) => {\n  await request(item);\n  count++;\n});\nconsole.log('发送次数', count);  // 输出　0\n```\n\n\n\n## 原因\n\nforEach 大致[源码](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#polyfill)\n\n```js\nArray.prototype.forEach = function (callback) {\n  for (let index = 0; index < this.length; index++) {\n    callback(this[index], index, this);\n  }\n};\n```\n\n可以看到 callback 前面并没有使用`await`, \n\n\n\n## 解决方案\n\n### 1. 使用原始的　for ...of\n\n略\n\n### 2. for await ... of \n\n```js\nconst LIMIT = 3;\n\nconst asyncIterable = {\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      next() {\n        const done = i === LIMIT;\n        const value = done ? undefined : i++;\n        return Promise.resolve({ value, done });\n      },\n      return() {\n        // This will be reached if the consumer called 'break' or 'return' early in the loop.\n        return { done: true };\n      }\n    };\n  }\n};\n\n(async () => {\n  for await (const num of asyncIterable) {\n    console.log(num);\n  }\n})();\n// 0\n// 1\n// 2\n```\n\n\n\n",
                    "title": "async 在 foreach 不生效"
                  },
                  {
                    "path": "financial/公司现金流入减少.md",
                    "content": "#docs/whatis-why-explanation   #financial \n\n[[资产负债表]] 里应收账款,货物大量增加, 将导致公司[[现金流量表]] 里现金流入减少\n预示着无法追加的债务风险或客户增加了付款期限\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221228084547180.iEcsE.jpg)\n",
                    "title": "公司现金流入减少"
                  },
                  {
                    "path": "financial/增加公司现金流.md",
                    "content": "#financial #docs/how-to-guides \n\n增加[[资产负债表]]应付账款, 即可改善[[现金流量表]] 现金流状况\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221228085101364.P7aqB.jpg)\n",
                    "title": "增加公司现金流"
                  },
                  {
                    "path": "financial/短期流动性问题.md",
                    "content": "#financial   #docs/reference \n\nProfit/(Loss) before tax 远大于  Net Cash Used In Operating Activities , 通常可以从[[现金流量表]] 里看出.\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221228084232062.av0Ci.jpg)\n(上图中,数字不太对,利润应该大于经营活动的现金流)",
                    "title": "短期流动性问题"
                  },
                  {
                    "path": "how to get a k8s certificate.md",
                    "content": "#k8s  #docs/how-to-guides \n \n官方考证入口: https://www.cncf.io/certification/cka\n\n  ",
                    "title": "how to get a k8s certificate"
                  },
                  {
                    "path": "how to take Notes.md",
                    "content": "---\naliases: [how to make notes,how to write notes, 怎么记笔记]\n---\n#notes #docs/how-to-guides \n\n \nBased on the idea of [[EverGreen Note Methodology]], and with the help of The Note Taking App Obsidian.\nI came up with some principles to keep the notes vital and clean.\n\n- We are lazy, make everything simple and intuitive.\n- [[Note roaming should be easy and predictable]].\n- [[Note finds me instead of me finding the notes, keep Every Note Element Counting]]. \n\t- Tags should distill note title\n\t- [[Less Media attachment as possible as you can]].\n- Keep your Note linking proactively.\n- Note should be purely hand-written. Othere resources like [[citation]], [[reference]], [[Bibliography]] should be linked.\n- [[Concept should build on concreate facts]]. \n- [[Write in your own words in any type of Notes]]\n- [[如何建立自己的知识体系]]\n- 技术 note 与其他笔记非常不一样，技术 note 非常容易过期\n- Use Ctrl-o to create file instead of Ctrl-n in obsidian \n\n\n\nWhat is the [[Difference between  Excerpt, Quotation, Reference, Citation and Bibliography]]?\n\n\n## When I say note should be atomic, what do I mean?\nEvergreen Note author also suggests that [[EverGreen Note/Evergreen notes should be concept-oriented]] . But How should I know if my note is ?\nThe definition of atomic is a vague. \n\n## When should I create a new note?\nI do not have to think about it. I will create one whenever I need one .\n1. When one piece of text is possibly linked by multiple notes. \n",
                    "title": "how to take Notes"
                  },
                  {
                    "path": "how to take notes/Concept should build on concreate facts.md",
                    "content": "#docs/how-to-guides  #note \n![[assets/Notes should build on concreate facts 2022-12-12 03.10.19.excalidraw]]\n\nJust like Paper-written process. Note title / concept  is important, Meanwhile, reliability  plays the key role in  making note linking valuable. \n\nWhen we build Note title / concept on top of reliable facts. Time cost  of validating and testing would been saved.\n\nOnce we find some souce is not trustworthy. We can easily trace back all the references and  reevaluate.\n\n[[如何建立自己的知识体系]]",
                    "title": "Concept should build on concreate facts"
                  },
                  {
                    "path": "how to take notes/Note roaming should be easy and predictable.md",
                    "content": "#docs/how-to-guides  #note \nYou do not want  losing track when roaming between notes. Especially when you are only roaming by hirarchy. When you opened A , B, C.  closing C should go back to B with no effect . That's intuitive.  Make that happen with your note keeping software .\n",
                    "title": "Note roaming should be easy and predictable"
                  },
                  {
                    "path": "how to take notes/如何建立自己的知识体系.md",
                    "content": "#docs/how-to-guides  \n\n对于一个概念\n1. 找到支撑这个概念的多个加以**案例**\n2. 概念还能**应用**到哪些方面\n3. 对这个概念的正确性做论文级别的**解释**\n\n\n[知乎：李叫兽是如何搜集和整理信息的？如何建立的知识体系？ - 数英](https://www.digitaling.com/articles/17364.html)",
                    "title": "如何建立自己的知识体系"
                  },
                  {
                    "path": "js/Bubbling and capturing.md",
                    "content": "#HTML #docs/whatis-why-explanation \n\n \n# 前言\n\n2021-05-25 補充：文中所提到的在 target phase 會依照加上 event listener 的順序觸發，在新版的 Chrome 似乎更改了這個行為，請參考：[Chrome 89 更新事件触发顺序，导致99%的文章都错了（包括MDN）](https://juejin.cn/post/6965682915141386254)\n\n（補充：感謝 othree 前輩的指點，指出這其實是在講 DOM 裡面事件傳遞的順序，因此把標題以及內文修正，原標題為：JavaScript 的事件傳遞機制：捕獲與冒泡）\n\n今天為大家帶來的內容是 DOM 裡面的事件傳遞機制，而與這些事件相關的程式碼，相信大家應該不太陌生，就是`addEventListener`, `preventDefault`跟`stopPropagation`。\n\n簡單來說，就是事件在 DOM 裡面傳遞的順序，以及你可以對這些事件做什麼。\n\n為什麼會有「傳遞順序」這一詞呢？假設你有一個`ul`元素，底下有很多`li`，代表不同的 item。當你點擊任何一個`li`的時候，其實你也點擊了`ul`，因為`ul`把所有的`li`都包住了。\n\n假如我在兩個元素上面都加了`eventListener`，哪一個會先執行？這時候呢，知道事件的執行順序就很重要。\n\n另外，由於某些瀏覽器（沒錯，我就是在說 IE）的機制比較不太一樣，因此那些東西我完全不會提到，有興趣的可以研究文末附的參考資料。\n\n# 簡單範例\n\n為了之後方便說明，我們先寫一個非常簡單的範例出來：\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <ul id=\"list\">\n    <li id=\"list_item\">\n      <a id=\"list_item_link\" target=\"_blank\" href=\"http://google.com\">\n        google.com\n      </a>\n    </li>\n  </ul>\n</body>\n</html>\n```\n\n在這個範例裡面，就是最外層一個`ul`，再來`li`，最後則是一個超連結。為了方便辨識，id 的取名也跟階層架構有關係。\n\nDOM 畫成圖大概是長這樣：\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/event_p1.png)\n\n有了這一個簡單的 HTML 結構之後，就可以很清楚的說明 DOM 的事件傳遞機制了。\n\n# 事件的三個 Phase\n\n要幫一個 DOM 加上 click 的事件，你會這樣寫：\n\n```js\nconst $list = document.getElementById('list');\n$list.addEventListener('click', (e) => {\n  console.log('click!');\n})\n```\n\n而這邊的`e`裡面就蘊含了許多這次事件的相關參數，其中有一個叫做`eventPhase`，是一個數字，表示這個事件在哪一個 Phase 觸發。\n\n```js\nconst $list = document.getElementById('list');\n$list.addEventListener('click', (e) => {\n  console.log(e.eventPhase);\n})\n```\n\n`eventPhase`的定義可以在[ DOM specification ](https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface)裡面找到：\n\n```C\n// PhaseType\nconst unsigned short      CAPTURING_PHASE                = 1;\nconst unsigned short      AT_TARGET                      = 2;\nconst unsigned short      BUBBLING_PHASE                 = 3;\n```\n\n這三個階段，就是我們今天的重點。\n\nDOM 的事件在傳播時，會先從根節點開始往下傳遞到`target`，這邊你如果加上事件的話，就會處於`CAPTURING_PHASE`，捕獲階段。\n\n`target`就是你所點擊的那個目標，這時候在`target`身上所加的`eventListenr`會是`AT_TARGET`這一個 Phase。\n\n最後，事件再往上從子節點一路逆向傳回去根節點，這時候就叫做`BUBBLING_PHASE`，也是大家比較熟知的冒泡階段。\n\n這邊用文字你可能會覺得霧煞煞，我直接引用一張[ w3c 講 event flow 的圖](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)，相信大家就清楚了。\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/eventflow.png)\n\n你在點擊那一個`td`的時候，這一個點擊的事件會先從`window`開始往下傳，一直傳到`td`為止，到這邊就叫做`CAPTURING_PHASE`，捕獲階段。\n\n接著事件傳遞到`td`本身，這時候叫做`AT_TARGET`。\n\n最後事件會從`td`一路傳回去`window`，這時候叫做`BUBBLING_PHASE`，冒泡階段。\n\n所以，在看一些講事件機制的文章的時候，都會看到一個口訣：\n\n> 先捕獲，再冒泡\n\n就是這樣來的。\n\n可是，我要怎麼決定我要在捕獲階段還是冒泡階段去監聽這個事件呢？\n\n其實，一樣是用大家所熟悉的`addEventListener`，只是這函數其實有第三個參數，`true`代表把這個 listener 添加到捕獲階段，`false`或是沒有傳就代表把這個 listener 添加到冒泡階段。\n\n# 實際演練\n\n大概知道事件的傳遞機制之後，我們拿上面寫好的那一個簡單範例來示範一下，一樣先附上事件傳遞的流程圖（假設我們點擊的對象是`#list_item_link`）\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/event_p2.png)\n\n接著，來試試看幫每一個元素的每一個階段都添加事件，看一看結果跟想像中的是否一樣：\n\n```js\nconst get = (id) => document.getElementById(id);\nconst $list = get('list');\nconst $list_item = get('list_item');\nconst $list_item_link = get('list_item_link');\n\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing', e.eventPhase);\n}, true)\n\n// list 的冒泡\n$list.addEventListener('click', (e) => {\n  console.log('list bubbling', e.eventPhase);\n}, false)\n\n// list_item 的捕獲\n$list_item.addEventListener('click', (e) => {\n  console.log('list_item capturing', e.eventPhase);\n}, true)\n\n// list_item 的冒泡\n$list_item.addEventListener('click', (e) => {\n  console.log('list_item bubbling', e.eventPhase);\n}, false)\n\n// list_item_link 的捕獲\n$list_item_link.addEventListener('click', (e) => {\n  console.log('list_item_link capturing', e.eventPhase);\n}, true)\n\n// list_item_link 的冒泡\n$list_item_link.addEventListener('click', (e) => {\n  console.log('list_item_link bubbling', e.eventPhase);\n}, false)\n```\n\n點一下超連結，console 輸出以下結果：\n\n```\nlist capturing\n1\nlist_item capturing\n1\nlist_item_link capturing\n2\nlist_item_link bubbling\n2\nlist_item bubbling\n3\nlist bubbling\n3\n```\n\n1 是`CAPTURING_PHASE`，2 是`AT_TARGET`，3 是`BUBBLING_PHASE`。\n\n從這邊就可以很明顯看出，事件的確是從最上層一直傳遞到 target，而在這傳遞的過程裡，我們用`addEventListenr`的第三個參數把 listener 添加在`CAPTURING_PHASE`。\n\n然後事件傳遞到我們點擊的超連結（`a#list_item_link`）本身，在這邊無論你使用`addEventListener`的第三個參數是`true`還是`false`，這邊的`e.eventPhase`都會變成`AT_TARGET`。\n\n最後，再從 target 不斷冒泡傳回去，先傳到上一層的`#list_item`，再傳到上上層的`#list`。\n\n# 先捕獲，再冒泡的小陷阱\n\n既然是先捕獲，再冒泡，意思就是無論那些`addEventListener`的順序怎麼變，輸出的東西應該還是會一樣才對。我們把捕獲跟冒泡的順序對調，看一下輸出結果是否一樣。\n\n```js\nconst get = (id) => document.getElementById(id);\nconst $list = get('list');\nconst $list_item = get('list_item');\nconst $list_item_link = get('list_item_link');\n\n// list 的冒泡\n$list.addEventListener('click', (e) => {\n  console.log('list bubbling', e.eventPhase);\n}, false)\n\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing', e.eventPhase);\n}, true)\n\n// list_item 的冒泡\n$list_item.addEventListener('click', (e) => {\n  console.log('list_item bubbling', e.eventPhase);\n}, false)\n\n// list_item 的捕獲\n$list_item.addEventListener('click', (e) => {\n  console.log('list_item capturing', e.eventPhase);\n}, true)\n\n// list_item_link 的冒泡\n$list_item_link.addEventListener('click', (e) => {\n  console.log('list_item_link bubbling', e.eventPhase);\n}, false)\n\n// list_item_link 的捕獲\n$list_item_link.addEventListener('click', (e) => {\n  console.log('list_item_link capturing', e.eventPhase);\n}, true)\n```\n\n一樣點擊超連結，輸出的結果是：\n\n```\nlist capturing\n1\nlist_item capturing\n1\nlist_item_link bubbling\n2\nlist_item_link capturing\n2\nlist_item bubbling\n3\nlist bubbling\n3\n```\n\n可以發現一件神奇的事，那就是`list_item_link`居然是先執行了添加在冒泡階段的 listener，才執行捕獲階段的 listener。\n\n這是為什麼呢？\n\n其實剛剛上面有提到，當事件傳遞到點擊的真正對象，也就是 e.target 的時候，無論你使用`addEventListener`的第三個參數是`true`還是`false`，這邊的`e.eventPhase`都會變成`AT_TARGET`。\n\n既然這邊已經變成`AT_TARGET`，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據你`addEventListener`的順序而定，先添加的先執行，後添加的後執行。\n\n所以，這就是為什麼我們上面把捕獲跟冒泡的順序換了以後，會先出現`list_item_link bubbling`的原因。\n\n關於這些事件的傳遞順序，只要記住兩個原則就好：\n\n1. 先捕獲，再冒泡\n2. 當事件傳到 target 本身，沒有分捕獲跟冒泡\n\n[jsbin 範例程式碼](https://jsbin.com/mogujivera/edit?html,js,console,output)\n\n# 取消事件傳遞\n\n接著要講的是，這一串事件鏈這麼長，一定有方法可以中斷這一條鏈，讓事件的傳遞不再繼續。而這個方法相信大家應該都不陌生，就是：`e.stopPropagation`。\n\n你加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞。\n\n例如說以上面那個例子來講，假如我加在`#list`的捕獲階段：\n\n```js\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing', e.eventPhase);\n  e.stopPropagation();\n}, true)\n```\n\n這樣子，console 就只會輸出：\n\n```\nlist capturing\n1\n```\n\n因為事件的傳遞被停止，所以剩下的 listener 都不會再收到任何事件。\n\n不過，在這邊依然有一個地方要特別注意。\n\n這邊指的「事件傳遞被停止」，意思是說不會再把事件傳遞給「下一個節點」，但若是你在同一個節點上有不只一個 listener，還是會被執行到。\n\n例如說：\n\n```js\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing');\n  e.stopPropagation();\n}, true)\n\n// list 的捕獲 2\n$list.addEventListener('click', (e) => {\n  console.log('list capturing2');\n}, true)\n```\n\n輸出結果是：\n\n```\nlist capturing\nlist capturing2\n```\n\n儘管已經用`e.stopPropagation`，但對於同一個層級，剩下的 listener 還是會被執行到。\n\n若是你想要讓其他同一層級的 listener 也不要被執行，可以改用`e.stopImmediatePropagation();`\n\n例如說：\n\n```js\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing');\n  e.stopImmediatePropagation();\n}, true)\n\n// list 的捕獲 2\n$list.addEventListener('click', (e) => {\n  console.log('list capturing2');\n}, true)\n```\n\n輸出結果是：\n\n```\nlist capturing\n```\n\n## 取消預設行為\n\n常常有人搞不清楚`e.stopPropagation`跟`e.preventDefault`的差別，前者我們剛剛已經說明了，就是取消事件繼續往下傳遞，而後者則是取消瀏覽器的預設行為。\n\n最常見的做法就是阻止超連結，例如說：\n\n```js\n// list_item_link 的冒泡\n$list_item_link.addEventListener('click', (e) => {\n  e.preventDefault();\n}, false)\n```\n\n這樣子，當點擊超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生，這就是`preventDefault`的作用。\n\n所以呢，`preventDefault`跟 JavaScript 的事件傳遞「一點關係都沒有」，你加上這一行之後，事件還是會繼續往下傳遞。\n\n有一個特別值得注意的地方是 W3C 的文件裡面有寫到：\n\n> Once preventDefault has been called it will remain in effect throughout the remainder of the event's propagation.\n\n意思就是說一旦 call 了`preventDefault`，在之後傳遞下去的事件裡面也會有效果。\n\n我們來看一個範例：\n\n```js\n// list 的捕獲\n$list.addEventListener('click', (e) => {\n  console.log('list capturing', e.eventPhase);\n  e.preventDefault();\n}, true)\n```\n\n我們在`#list`的捕獲事件裡面就先寫了`e.preventDefault()`，而根據文件上面所說的，這個效果會在之後傳遞的事件裡面一直延續。\n\n因此，等之後事件傳遞到`#list_item_link`的時候，你會發現點超連結一樣沒反應。\n\n# 實際應用\n\n知道了事件的傳遞機制、取消傳遞事件跟取消預設行為之後，在實際開發上有什麼用處呢？\n\n最常見的用法其實就是事件代理（Delegation），例如說你今天有一個 ul，底下 1000 個 li，如果你幫每一個 li 都加上一個 eventListener，你就新建了 1000 個 function。\n\n但我們剛剛已經知道，任何點擊 li 的事件其實都會傳到 ul 身上，因此我們可以在 ul 身上掛一個 listener 就好。\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <ul id=\"list\">\n    <li data-index=\"1\">1</li>\n    <li data-index=\"2\">2</li>\n    <li data-index=\"3\">3</li>\n  </ul>\n</body>\n</html>\ndocument.getElementById('list').addEventListener('click', (e) => {\n  console.log(e.target.getAttribute('data-index'));\n})\n```\n\n而這樣的好處是當你新增或是刪除一個 li 的時候，不用去處理跟那個元素相關的 listener，因為你的 listener 是放在 ul 身上。這樣透過父節點來處理子節點的事件，就叫做事件代理。\n\n除此之外，我有想到幾個滿有趣的應用，大家可以參考看看。\n\n例如說剛剛提到的`e.preventDefault()`，既然我們知道原理跟使用技巧，就可以這樣用：\n\n```js\nwindow.addEventListener('click', (e) => {\n  e.preventDefault();\n  e.stopPropagation();\n}, true);\n```\n\n只要這樣一段程式碼，就可以把頁面上所有的元素停用，點了都沒有反應，像是`<a>`點了不會跳出超連結，`<form>`按了`submit`也沒用，而且因為阻止事件冒泡，所以其他的`onClick`事件也都不會執行。\n\n或是，也可以這樣用：\n\n```js\nwindow.addEventListener('click', (e) => {\n  console.log(e.target);\n}, true)\n```\n\n利用事件傳遞機制的特性，在`window`上面使用捕獲，就能保證一定是第一個被執行的事件，你就可以在這個 function 裡面偵測頁面中每一個元素的點擊，可以傳回去做數據統計及分析。\n\n# 結論\n\nDOM 的事件傳遞機制算是 JavaScript 眾多經典面試題裡面相對簡單很多的，只要能掌握事件傳遞的原則跟順序，其實就差不多了。\n\n而`e.preventDefault`與`e.stopPropagation`的差別在知道事件傳遞順序之後也大概能理解，前者就只是取消預設行為，跟事件傳遞沒有任何關係，後者則是讓事件不再往下傳遞。\n\n希望這篇能讓大家理解 DOM 的事件傳遞機制，如果有哪邊有講錯，也麻煩大家不吝指證，感謝。\n\n\n[Bubbling and capturing](https://javascript.info/bubbling-and-capturing)",
                    "title": "前言"
                  },
                  {
                    "path": "js/Prototype In JS.md",
                    "content": "#js #basic  #docs/reference \n\n要理解 Prototype， 最好是对脚本语言有所了解。 [Interperator](../../../Interperator.md)   \n\n我们先准备一段代码。\n\n````js\n// a constructor function\nfunction Foo(y) {\n  // which may create objects\n  // by specified pattern: they have after\n  // creation own \"y\" property\n  this.y = y;\n}\n \n// also \"Foo.prototype\" stores reference\n// to the prototype of newly created objects,\n// so we may use it to define shared/inherited\n// properties or methods, so the same as in\n// previous example we have:\n \n// inherited property \"x\"\nFoo.prototype.x = 10;\n \n// and inherited method \"calculate\"\nFoo.prototype.calculate = function (z) {\n  return this.x + this.y + z;\n};\n \n// now create our \"b\" and \"c\"\n// objects using \"pattern\" Foo\nvar b = new Foo(20);\nvar c = new Foo(30);\n \n// call the inherited method\nb.calculate(30); // 60\nc.calculate(40); // 80\n \n// let's show that we reference\n// properties we expect\n \nconsole.log(\n \n  b.__proto__ === Foo.prototype, // true\n  c.__proto__ === Foo.prototype, // true\n \n  // also \"Foo.prototype\" automatically creates\n  // a special property \"constructor\", which is a\n  // reference to the constructor function itself;\n  // instances \"b\" and \"c\" may found it via\n  // delegation and use to check their constructor\n \n  b.constructor === Foo, // true\n  c.constructor === Foo, // true\n  Foo.prototype.constructor === Foo, // true\n \n  b.calculate === b.__proto__.calculate, // true\n  b.__proto__.calculate === Foo.prototype.calculate // true\n \n);\n````\n\n\n\n\n\n\n![Figure 3. A constructor and objects relationship.](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/constructor-proto-chain.png)\n\n\n\nhttp://dmitrysoshnikov.com/ecmascript/javascript-the-core/\n\n\n\n这个图非常有意思.\n\n1. Object 是最终的东西。  `__proto__` 指向 null\n2. Foo 是一个函数，所以它的`__proto__` 指向 Function.prototype，而且，**仅仅** function 拥有  prototype 属性 \n3. Foo 里的 prototype属性和 Foo.prototype里的 constructor 互相指着对方。  \n\n```js\nabc: Function {\n\t__proto__:Function.prototype*;\n}\n\nFunction(){\n   prototype:{}\n}\n\nPrototype 相当于类\n__proto__ 相当于指针\n```\n\n\n类只是 ES 6 里的语法糖。  [Class in ES 6](Class%20in%20ES%206.md)",
                    "title": "Prototype In JS"
                  },
                  {
                    "path": "js/history in HTML.md",
                    "content": "#docs/whatis-why-explanation  #HTML\n\n\npopState 在被回调时，已经完成导航了。\n\n而 pushState 和replaceState 则还没有。\n\n![image-20220530225310479](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220530225310479.png)\n\n\n\napply 最好的解释。\n\nrawPushState 原始的函数  window.history.pushState\n\n当客户调用window.history.pushState 时， 你希望再去调一下旧的。 就需要使用  \n\nrawPushState.apply(window.history,args)\n\n你不能这样：\n\nwindow.history.pushState ， 死循环了\n\n也不能这样， window.history.rawPushState， 没这个函数\n\nCONST RAWPUSHSTATE - WINDOW.HISTORY.PUSHSTATE\n\nWINDOW.HISTORY.PUSHSTATE (..........\n\nRAWPUSHSTATE.APPLY(WINDOW.HISTORY, ARGS)\n\nCONSOLE.LOG('监视到PUSHSTATE 变化了')\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1653919489020-67d52d95-9947-407c-b852-cdeb92ab7dbd.png)\n\n\n\n \n\n",
                    "title": "history in HTML"
                  },
                  {
                    "path": "publish obsidian with mkdocs in github pages.md",
                    "content": "#obsidian  #docs/how-to-guides \n\nput the below file to github repo.\n\n.github/workflows/buildGithubPages.yml\n``` yaml \nname: publish to github pages\non:\n  push:\n    branches:\n      - master\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n            fetch-depth: 0 # fetch everything so that mkdocs doesn't run into the missing refs problem\n      - uses: actions/setup-python@v2\n        with:\n          python-version: 3.x\n      - run: python .publish/prepareGithubPages.py\n      - run: pip install mkdocs-material==\"8.*\"\n      - run: pip install mkdocs-roamlinks-plugin\n      - run: |\n         cd .publish\n         mkdocs gh-deploy \n```\n\n\nrefs: \n[GitHub - zk4/obsidian_dataview_example_vault](https://github.com/zk4/obsidian_dataview_example_vault)   this is also the repo that show how to use Dataview plugins\nI alread fork this repo  [GitHub - zk4/obsidian_dataview_example_vault](https://github.com/zk4/obsidian_dataview_example_vault)\n ",
                    "title": "publish obsidian with mkdocs in github pages"
                  },
                  {
                    "path": "start up a day.md",
                    "content": "#life #docs/how-to-guides \n\n1. Clean up myself with some routine to start a day\n\t1. brush and clean the beard \n2. Set small goals to match the [[Big Life Goals]] and Make Plans to achieve those\n3. execute plans with focus method, like tomato clock",
                    "title": "start up a day"
                  },
                  {
                    "path": "templates/t-Explanation.md",
                    "content": "#template  #docs/whatis-why-explanation \n\n\t解释文档特点：\n\t目标受众： 我对某种概念不明白，你能解释清楚。\t\n\t-   以理解作为基本的导向\n\t-   说明问题、解释问题\n\t-   描述问题的背景和关联内容  \n\t\t解释可以类比成：一篇讲述烹饪社会历史的文章。\n\n \n_The reason for x is because historically, y…_\n\nExplain.\n\n_W is better than z, because…_\n\nOffer judgements and even opinions where appropriate..\n\n_An x in system y is analogous to a w in system z. However…_\n\nProvide context that helps the reader.\n\n_Some users prefer w (because z). This can be a good approach, but…_\n\nWeigh up alternatives.\n\n_An x interacts with a y as follows:…_\n\nUnfold the machinery’s internal secrets, to help understand why something does what it does.",
                    "title": "t-Explanation"
                  },
                  {
                    "path": "templates/t-Ho-to Guides.md",
                    "content": "---\naliases: [指南模板]\n---\n\n#template #docs/how-to-guides \n\n_This guide shows you how to…_\n\nDescribe clearly the problem or task that the guide shows the user how to solve.\n\n_If you want x, do y. To achieve w, do z._\n\nUse conditional imperatives.\n\n_Refer to the x reference guide for a full list of options._\n\nDon’t pollute your practical how-to guide with every possible thing the user might do related to x.\n\n# Goal \n## mehtod 1\n## method 2\n",
                    "title": "Goal"
                  },
                  {
                    "path": "templates/t-Tutorials.md",
                    "content": "---\naliases: [教程模板]\n---\n#docs/tutorials  #template \n\n\t目标受众：为达到某种目标，我需要系统的学习。\n\t特点如下：\n\t-   以学习为目的\n\t-   适合新手入门\n\t-   是一个课程  \n\t-   效果先行，引出读者兴趣\n\n## Before We Start\n### What Are We Building?\n### Prerequisites\n\n## Steps\n### 1. Setup the Environment\n### 2. ...\n### 3. Result \n\n## Overview \nwhat is your product's key feature, and catchy for users to grab.\n\n## What's Next \n\n",
                    "title": "t-Tutorials"
                  },
                  {
                    "path": "templates/文档区别.md",
                    "content": "#docs  \n\n|              |   Tutorial                           |   Guide            |   Explanation   |   Reference   |\n|:-------------|:-------------------------------------|:-------------------|:----------------|:--------------|\n|   目标         | 引起用户兴趣                               |   解决用户问题           | 帮助用户搞懂          |   用户可查        |\n|   方向         |   You Can                            |   How              |   Why           |   What        |  \n\n\n\n ![[../../Excalidraw/文档区别 2022-10-16 20.25.34.excalidraw]]\n\n[怎么写模板文档](../../1.方法论/怎么写技术文档？/怎么写模板文档.md)\n ",
                    "title": "文档区别"
                  },
                  {
                    "path": "templates/项目文档/7.项目验收总结报告.md",
                    "content": "#docs \n \n",
                    "title": "7.项目验收总结报告"
                  },
                  {
                    "path": "templates/项目文档/项目文档模板.md",
                    "content": "#docs \n \n时间线上所需文档\n- [[1.可行性研究报告]]\n- [[2.项目建议书]]\n- [[3.招投标文件]]\n- [[4.需求分析书]]\n- [[5.概要设计书]]\n- [[6.详细设计书]]\n- [[7.项目验收总结报告]]\n\n",
                    "title": "项目文档模板"
                  },
                  {
                    "path": "write appealing articles.md",
                    "content": "#writingSkills  #docs/how-to-guides \n\n\n[[怎样写标题|how to write attractive title in 3 steps]]\n[[李叫兽 所有文章索引]]\n[[SQA]]\n[Ahrefs SEO博客 - 链接建设策略&SEO小技巧](https://ahrefs.com/blog/zh/)\n",
                    "title": "write appealing articles"
                  },
                  {
                    "path": "中国为什么留不住人才？.md",
                    "content": "#docs/whatis-why-explanation \n\n![[社会人]]",
                    "title": "中国为什么留不住人才？"
                  },
                  {
                    "path": "为什么要生孩子.md",
                    "content": "#docs/whatis-why-explanation   #life  #parenting \n在三四十岁的某一天，你会突然发现，生命中最好的事，都已经发生过了，剩下的只是重复和老去，一年年，一天天。\n\n而孩子会冲走重复，让生活重新变得未知。他/她让你烦恼，让你牵挂，让你欢喜，让你惊讶，让你再经历一次童年，让你明白当年父母的心境，让你有理由买曾经求而不得的玩具，让你在痛苦时坚强，在危机中冷静，让你看到童年时的自己，看到他的勇敢，他的好奇，他的局促，他的不安，从而更好的理解自己，接受自己。\n\n父母养育了孩子，孩子也陪伴了父母，父母和孩子滋养了彼此，也成就了彼此。\n\n在飞逝的时光中，他让未来有所期待。",
                    "title": "为什么要生孩子"
                  },
                  {
                    "path": "写 wysiwyg 编辑器.md",
                    "content": "#docs/how-to-guides \n \n  \n[https://codeburst.io/how-to-build-your-own-wysiwyg-editor-6002fa3f5ea8](https://codeburst.io/how-to-build-your-own-wysiwyg-editor-6002fa3f5ea8)\n\n大量基于 document.execCommand (vditor 一样) ，但是这个 api 已经废弃了。\n\n可能接替的是 [link](https://stackoverflow.com/questions/60581285/execcommand-is-now-obsolete-whats-the-alternative)\n\n有人重写了 execCommand Re-implementing document.execCommand()[^1]\n\n基于上面的重写做了个做 slide 的网站，https://app.deckdeckgo.com/\n\n基于这个 https://github.com/deckgo/deckdeckgo\n\n<iframe src=\"file:///Users/zk/git/jsPrj/wysiwyg-editor-demo/index.html\" data-src=\"\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 833px; height: 526px;\"></iframe>\n\n‍\n\n",
                    "title": "写 wysiwyg 编辑器"
                  },
                  {
                    "path": "十亿级数据ES搜索怎么优化.md",
                    "content": "\n#ES #docs/how-to-guides \n\n### 面试题\n\nes 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？\n\n### 面试官心理分析\n\n这个问题是肯定要问的，说白了，就是看你有没有实际干过 es，因为啥？其实 es 性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下 5~10s，坑爹了。第一次搜索的时候，是5~10s，后面反而就快了，可能就几百毫秒。\n[]()\n你就很懵，每个用户第一次访问都会比较慢，比较卡么？所以你要是没玩儿过 es，或者就是自己玩玩儿 demo，被问到这个问题容易懵逼，显示出你对 es 确实玩儿的不怎么样？\n\n### 面试题剖析\n\n说实话，es 性能优化是没有什么银弹的，啥意思呢？就是不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。\n\n### 性能优化的杀手锏——filesystem cache\n\n你往 es 里写的数据，实际上都写到磁盘文件里去了，查询的时候，操作系统会将磁盘文件里的数据自动缓存到 filesystem cache 里面去。\n\n![](https://juejin.cn/post/6844904202494279694)\n\nes 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 idx segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。\n\n性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 filesystem cache，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。\n\n这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 64 * 3 = 192G。每台机器给 es jvm heap 是 32G，那么剩下来留给 filesystem cache的就是每台机器才 32G，总共集群里给 filesystem cache 的就是 32 * 3 = 96G 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 1T 的磁盘容量，es 数据量是 1T，那么每台机器的数据量是 300G。这样性能好吗？filesystem cache 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。\n\n归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。\n\n根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要用来搜索的那些索引，如果内存留给 filesystem cache 的是 100G，那么你就将索引数据控制在 100G 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。\n\n比如说你现在有一行数据。id,name,age .... 30 个字段。但是你现在搜索，只需要根据 id,name,age 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 90% 的数据是不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，单条数据的数据量越大，就会导致 filesystem cahce 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的少数几个字段就可以了，比如说就写入 es id,name,age 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 es + hbase 这么一个架构。\n\nhbase 的特点是适用于海量数据的在线存储，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整的数据，给查出来，再返回给前端。\n\n写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。\n\n### 数据预热\n\n假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 filesystem cache 一倍，比如说你写入一台机器 60G 数据，结果 filesystem cache 就 30G，还是有 30G 数据留在了磁盘上。\n\n其实可以做数据预热。\n\n举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。\n\n或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 filesystem cache 里去。\n\n对于那些你觉得比较热的、经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据每隔一段时间，就提前访问一下，让数据进入 filesystem cache 里面去。这样下次别人访问的时候，性能一定会好很多。\n\n### 冷热分离\n\nes 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在 filesystem os cache 里，别让冷数据给冲刷掉。\n\n你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 filesystem cache 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。\n\n### document 模型设计\n\n对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。\n\n最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。\n\ndocument 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。\n\n### 分页性能优化\n\nes 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。\n\n分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。\n\n我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。\n\n有什么解决方案吗？\n\n不允许深度分页（默认深度分页性能很差）\n\n跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。\n\n类似于 app 里的推荐商品不断下拉出来一页一页的\n\n类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 scroll api，关于如何使用，自行上网搜索。\n\nscroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。\n\n初始化时必须指定 scroll 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。\n\n除了用 scroll api，你也可以用 search_after 来做，search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。",
                    "title": "十亿级数据ES搜索怎么优化"
                  },
                  {
                    "path": "如何写广告语.md",
                    "content": "---\naliases: [广告,广告语]\n---\n#advertising #docs/how-to-guides #marketing \n\n以下来自吴晓波对谈江南春 \n\n## 从经验维度\n1. **消费者只会记住一句话**. 一句活要说服消费者选择你而不是别人\nOppo 手机是拍照最好的手机\n小米手机是性价比最高的手机\n时尚人士手机用苹果\n商务人士用华为\n\n2. 如果是卖的是商品, 则**找 Top 10 销冠采用的话术**\n3. **朋友推荐你时,用的第一句话**\n\n## 从市场排名维度\n**老大** 广告语走**封杀品类**路线\n烤鸭就是去全聚德\n租车找神州\n装修就找土巴兔\n\n**老二**, 挑战老大,**挑战品类特性**,更专注更专业\n换轮胎找天猫\n\n**老三, 垂直聚焦**\n特卖网,唯品会\n\n**老四,开创新品类**\n\n拼多多, 玩社区团购\n\n> 那从广告里反推就知道行业的 1,2,3,4 名是谁了.\n\n以上本质上就是[[借势]].\n",
                    "title": "如何写广告语"
                  },
                  {
                    "path": "如何成为行业顶尖.md",
                    "content": "#docs/how-to-guides  \n\n\n1.  熟悉一百个行业关键词\n2.  找3 5专家聊，他们的共同点是这个行业最重要的东西\n3.  找3 5专著看\n4.  价值最大化，构建影响力",
                    "title": "如何成为行业顶尖"
                  },
                  {
                    "path": "如何表达？.md",
                    "content": "#docs/how-to-guides  #social \n\n你必须先搞定语法。通过学习语法，才能了解语言的结构规律。若不懂这规律，碰到再好的语言素材，也设计不出好的表达。\n  \n## 语法速成 \n\n大多数人提到学语法就头大，这得益于国内教育对语文的轻视，导致我们的语言基础很低。\n但请各位放心，今天我不是来抖书袋的。各位在日常用到的语法知识，都被我浓缩到了接下来的区区数百字里。\n首先你要了解，组成语句的基本构成是什么？\n简单的说来，就是“主谓宾”与“定状补”。\n\n![](https://pic1.zhimg.com/80/v2-58142dcd501a7b896ef9cd74c218164c_720w.webp)\n\n一个简单明了的句子，要么就是主谓结构：**他是什么，他处于什么状态**\n要么就是主谓宾结构：**他做了什么**。\n而剩下的定状补，是当基本句式需要补充更多信息来加强真实性时，才会登场。\n\n![](https://pic2.zhimg.com/80/v2-18dd3d81183ddc0732e892ac63ac7321_720w.webp)\n\n  \n\n举个例子\n\n主谓宾句式：“张媛媛长得好看。”\n光听这句话，别人显然没有概念，不知道她到底好不好看，有多好看？\n这时，我们为了达到理想的传达效果，就必须得里面添加更多的信息。\n来看把定状补分别添加进去后，各自的效果：\n\n-   加定语：“三年二班的张媛媛长得好看。”\n-   加状语：“张媛媛长得非常好看。”\n-   加补语：“张媛媛长得好看，校花也不及她。”\n \n我们假设，现在让鲜肉老师王大锤听这三句话，你们觉得哪句能直接激发他对该女学生的兴趣呢？\n\n![](https://pic4.zhimg.com/80/v2-c1f7e78e8a3f29ab50135ee1e8a0baff_720w.webp)\n\n**很明显，补语是最有效的。**  \n有了**补语**，我们就能对他人信息产生直观的认识。发现原来张媛媛有这么漂亮！不但确立了好看这个事实，更让人对此充满好奇。  \n除此之外，**定语**表明了主语所属，也给大锤老师提供了重要信息：三年二班。  \n一切仿佛触手可及~\n\n![](https://pic3.zhimg.com/80/v2-453835c514d69707965f958ea21707fe_720w.webp)\n\n最无用的信息反倒是**状语**，它只加强了描述者的主观看法。即便他自己很兴奋，但传达出的信息无效，就失去了想象的来源。听众的印象只会是模糊的，自然也不会有多少兴趣。  \n\n**你发现没有，原来大多数人表达上的问题，就是因为状语过多。**  \n\n我们给朋友推荐某个东西好，通常就是强化情绪：很好、非常好、超级好。甚至很多商家都只会说，我们手机性价比超高，我们手机叼爆了。  \n\n而这些信息对接收方而言，没有任何价值。  \n\n现在，整理下语法思路：\n-   在一句话里，主谓宾确立了核心信息：他（它）是什么？他（它）做了什么？主谓宾也是人们最容易理解的的信息结构，因为越清晰的信息，形成的认知就越集中。\n-   有了主谓宾的核心信息，再去为它添加补语和定语，核心信息就会更具说服力。这样信息不但清晰，而且深刻。\n\n## 语法思维搞定所有表达 \n\n当你知道一句话如何组织，等于也懂了如何大段表达和写作的思路。因为相比于单个句子，后者只不过是数量的延伸，本质是不变的。\n\n那么语法思维具体要如何延伸呢？\n\n每次在表达和动笔之前，**你想要表达的中心思想，必须能精简成一个主谓宾式的信息**。这才能保证传达的信息足够清晰，否则别人不知道你在讲什么。\n\n有了清晰的中心思想，下一步就是让它足够可信。用补语和定语思维为其添加有效信息：**一个让结果合理**，**一个让事件跟主角有紧密的联系**。\n\n下面以实例来为大家讲解\n### 面试中的自我介绍\n\n![](https://pic2.zhimg.com/80/v2-f3057cdb9c1339e4c4e18a1901b1e8f5_720w.webp)\n\n### 向领导汇报计划\n\n![](https://pic2.zhimg.com/80/v2-94c5a72e5cbfa4a7bef3a90e3c8503c9_720w.webp)\n\n### 与爸妈交流\n\n![](https://pic2.zhimg.com/80/v2-b204684baed60f3166dfe73a7def8181_720w.webp)\n\n\n### 向朋友安利\n\n![](https://pic2.zhimg.com/80/v2-a9baba1d80a6e2dcc3464ad26ee389d9_720w.webp)\n\n如此一来，你既能做到言之有物，也能避免听众觉得“你这个观点不可信”以及“事实虽如此，但这和你有什么关系”这样的尴尬局面。\n\n道理我已经讲清楚了，还看各位能否尽快熟练并且运用到日常表达中。或许新思维的引入，一定程度上削弱了你快人快语的直率性格。但你之后的每一次发言，都会是你彰显形象的闪亮时刻！\n\n\nrefs:\n[那些表达力超强的人，是如何把事情说清楚的 - 知乎](https://zhuanlan.zhihu.com/p/26756438)\n   ",
                    "title": "如何表达？"
                  },
                  {
                    "path": "怎样写标题.md",
                    "content": "---\naliases: [how to write title]\n---\n #writingSkills  #docs/how-to-guides \n\n\n## 什么是标题？\n标题是一个题目，一个名称。\n一个好的标题有三个作用：\n-   吸引读者的注意力\n-   引发读者好奇去点击\n-   准确描述内容\n \n## 如何三步写出标题？\n\n写一个标题并不难。你可以通过一个简单的三步系统来掌握基本知识。在你解决这个问题的时候，请记住以下几点:\n\n-   你应该为谷歌搜索者写你的标题，因为，很可能，如前所述，你的大部分流量来自于搜索。\n-   通常最好是在写博客之前先写标题，所以这个系统就采用了这个方法。也就是说，你仍然可以使用每个步骤来精炼一个特别的标题。\n-   在执行这些步骤时，应该考虑到文章的真实内容，从而避免成为“标题党”。通常在你写完文章后再写标题，会导致你过多地承诺读者会从文章中得到什么。如果这篇文章没有提供，那这就是标题党。\n\n\n现在让我们来写这个标题吧！\n\n### 1. 选择一种格式\n\n假设你正在写一篇关于最好的蛋白质粉的文章，任何一种标题形式都可以:\n\n-   清单:2021年锻炼肌肉的10种最佳蛋白粉\n-   如何: 如何选择最适合你的蛋白粉\n-   教程:最佳蛋白粉:6步选择最佳蛋白粉\n-   评论文章:真的有最好的蛋白粉吗? 科学说没有\n-   测评: Optimum Nutrition金段测评:最佳蛋白粉\n-   比较: Optimum Nutrition 对比 MyProtein: 哪种是最好的蛋白质粉？\n\n但是请记住，对于大多数网站来说，流量最重要的来源是谷歌。所以，你不应该只选择听起来最好的标题格式。你应该选择搜索者实际上正在寻找的，这样你就有最好的机会排名。\n\n你怎样能做到呢?\n\n在谷歌中查看你的目标关键词的当前排名靠前的页面，并检查主导\n\n角度。你可以看到前三名“最好的蛋白粉都是清单。\n\n![](https://ahrefs.com/blog/zh/wp-content/uploads/2021/08/Untitled-2.jpg)\n\n不过要注意，谷歌的搜索结果是根据你的位置和搜索历史等因素个性化的。为了解决这个问题，在隐身标签中使用[Ahrefs SEO 工具栏](https://ahrefs.com/zh/seo-toolbar) ，可以模拟你的目标国家和语言的搜索。![](https://ahrefs.com/blog/zh/wp-content/uploads/2021/08/Untitled-4.png)\n\n记住，最有效的标题类型取决于你的主题。虽然关于最佳蛋白粉的文章最适合用清单式的标题，但“如何使用”的标题更适合你正在阅读的文章。你的主题可能需要一篇评论。这完全取决于搜索数据。\n\n专业提示\n如果你写的标题与搜索结果中的内容角度不匹配，考虑一下你是否可以通过细小的编辑来改变角度。例如，你可以通过改变几个单词来快速地将一个教程变成一个清单:\n\n> 写出你最好的标题: 六个步骤 → 写好标题的6种方法\n\n### 2. 增加一个吸引人的角度\n现在你已经有了格式，你需要找到排名靠前的角度。\n使用与上一步相同的文章，寻找有区别的单词。例如，当看清单时，大多数文章都以#最佳蛋白粉开头，然后是角度。\n在最佳蛋白粉的情况下，性别是主导的角度。即，对男性或女性。\n但是在SERP中也有其他的选择，比如:\n\n-   ”为了更好的营养”\n-   “每种饮食”\n-   ”给你的”\n\n在选择你的角度时，你需要平衡搜索者想要什么和你能写什么。如果你是个专家，知道某个角度比另一个角度更有意义，你应该从这个角度出发。\n\n如果没有明显的主导角度，就要关注一个明显的好处，一个产品/服务的差异化因素，或者仅仅是一些还没有被关注的东西，只要它是你的读者想要知道的。\n\n比如:\n\n-   “减肥”\n-   “锻炼肌肉”\n-   “增肥”\n\n一旦你掌握了标题的基本部分，比如格式和角度，你只需要再做一件事…\n\n### 3. 使之人性化\n\n为了真正打动读者，你需要让你的标题人性化。\n如果你是人类，这应该很容易。用形容词或修辞格向你最好的朋友随意描述这篇文章。\n因此，与“10种最佳减肥蛋白粉”不同，你可能需要：\n\n-   “10种最好的蛋白粉，轻松减肥”\n-   “10种最好的减肥蛋白粉”\n-   ”十大最佳蛋白粉减肥”\n\n为了让这个过程更简单，请使用读者的语言。在每个行业，都有行话，有俚语，有熟悉行业的人谈论他们最喜欢的东西的私人方式。如果你有时间，尽可能多地阅读与你的主题相关的文章。\n\n你也可以在社交媒体上浏览你的话题。Reddit、Twitter和LinkedIn是寻找小众短语和特定社区语言的好地方。一些reddit甚至带有Wiki和Glossary来定义关键词。\n\n![](https://ahrefs.com/blog/zh/wp-content/uploads/2021/08/Untitled-6.jpg)\n\nWiki 关于健身\n\n利用这些信息，你可以选择一个标题，如“17蛋白粉，帮助你实现你的宏量营养目标”或“14蛋白粉，快速，便携，准备和食用。\n\n## 标题写作的4个技巧\n选择一个正确的格式，角度，并使它人性化，对于如何写一个成功的标题的基本步骤是足够的。\n也就是说，在写了这么多年的标题之后，我们有四个技巧给你。\n\n### 1. 增加具体性\n标题越具体，越容易阅读。它越容易阅读，人们就会越喜欢它。人们越喜欢它，就越有可能点击它。\n就这么简单，而具体性来自于有形的、真实的东西。\n例如，不要用“蛋白粉增重”来代替“15种美味的蛋白粉可以帮助你每周增加1磅的肌肉”。\n\n### 2. 惊喜和快乐\n如果你的目标是从其他地方获得流量，而不是有机搜索，比如社交媒体，匹配搜索意图可能就不那么重要了。你可以通过说一些有趣的和不寻常的东西来让人们停下来点击，从而产生更大的影响。\n几年前我们就这样做了，我们发布了“[我邀请了235个人来推特我的文章…](https://ahrefs.com/blog/asking-for-tweets/) ”的帖子。\n这个问题没有一个真正的公式; 它依赖于了解你的听众，他们使用的语言，以及什么可能与他们产生共鸣。\n\n### 3. 制造好奇心差距\n把你的信息告诉每个人，除了你想让他们好奇的那个人，例如: “除了你，每个人都在做 x!”只要确保你在你的文章中支持这个主张，这样它就不只是又一个标题党文章了。\n\n### 4. 测试标题的变体\n当你在社交媒体平台上发表文章时，你可以选择不同的标题。测试主主题的变体，看看一个标题是否获得更多的点击、喜欢、评论和分享。然后把它作为你的主要文章标题。\n\n## 最后的想法\n制作一个成功的标题不是火箭科学。这是营销科学。这显然更容易。事实上，如果你使用上面详述的三步系统，你将能够跟上你所在行业中最好的作家。\n一旦你准备好成为最好的标题作者，可以看看经典文案。他们都有自己的基于证据的标题公式和理论来支持他们。\n以下是我最受益的五本书：\n1.  [Claude Hopkins的《科学广告》](https://www.amazon.com/Scientific-Advertising-Claude-Hopkins/dp/1614279233/)。 通过详细了解1923年直接响应营销中使用的最有效的头条新闻来介绍“[复制测试](https://en.wikipedia.org/wiki/Copy_testing#:~:text=Copy%20testing%20is%20a%20specialized,%2C%20internet%2C%20and%20social%20media.)”的概念。\n2.  [John Caples的《测试广告法》](https://www.amazon.com/Advertising-Methods-Prentice-Business-Classics/dp/0130957011/)。克劳德 · 霍普金斯的方法又经过了十年的改进。包括最成功的标题公式仍然在近一个世纪后仍然有点击。\n3.  [Eugene Schwartz的《突破广告》。](https://www.amazon.com/Breakthrough-Advertising-Eugene-M-Schwartz/dp/0887232981/)尤金·施瓦茨介绍了[品牌意识](https://en.wikipedia.org/wiki/Brand_awareness)的概念以及如何向各个层次的消费者进行营销。\n4.  [Roy Williams的《广告奇才》](https://www.amazon.com/Wizard-Ads-Turning-Dreamers-Millionaires/dp/1885167296/)。这是一本更现代、个人最喜欢的书，采用了一种最独特的文案方法。\n5.  Michael Masterson的《伟大的领导》。只关注如何写文案的第一行，以最大程度地影响你的读者。 \n\n一旦你成为了一个真正的标题写作专家，就可以用Si Quan的[SEO 文案指南](https://ahrefs.com/blog/zh/seo-copywriting/)来优化你文章的其余部分。\n\n",
                    "title": "怎样写标题"
                  },
                  {
                    "path": "成为一个算法高手.md",
                    "content": "#algorithm  #docs/how-to-guides \n\n刷 leetcode 前，可先把[[booknote/跟左程云学算法笔记]] 搞定。\n\n``` dataview \nTABLE filename FROM #algorithm\nSORT rating DESC \n```",
                    "title": "成为一个算法高手"
                  },
                  {
                    "path": "技术知识库.语雀导出/Flyway Guide.md",
                    "content": "#flyway #db #docs/tutorials  #spring \n\n在向前发布时, 让数据库脚本跟着当前运行的代码版本走.\n \n## Spring Boot  快速集成\n### 引入依赖\n``` xml\n      <!-- 无需版本号 -->\n <dependency>\n      <groupId>org.flywaydb</groupId>\n      <artifactId>flyway-core</artifactId>\n </dependency>\n```\n\n\n### 创建 sql 存放位置\n\n新建文件夹,用于存放sql文件,官方推荐是放在classpath下的db.migration目录下.\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220519160114795.png#crop=0&crop=0&crop=1&crop=1&id=EkEdP&originHeight=40&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\napplication 增加配置为：  复制粘贴即可. 不需要做任何修改\n\n```yaml\n# flyway 配置\nspring:\n  flyway:\n    # 启用或禁用 flyway\n    enabled: true\n    # flyway 的 clean 命令会删除指定 schema 下的所有 table, 生产务必禁掉。这个默认值是 false 理论上作为默认配置是不科学的。\n    clean-disabled: true\n    # SQL 脚本的目录,多个路径使用逗号分隔 默认值 classpath:db/migration\n    locations: classpath:db/migration\n    #  metadata 版本控制信息表 默认 flyway_schema_history\n    # table: flyway_schema_history\n    # 如果没有 flyway_schema_history 这个 metadata 表， 在执行 flyway migrate 命令之前, 必须先执行 flyway baseline 命令\n    # 设置为 true 后 flyway 将在需要 baseline 的时候, 自动执行一次 baseline。\n    baseline-on-migrate: true\n    # 指定 baseline 的版本号,默认值为 1, 低于该版本号的 SQL 文件, migrate 时会被忽略\n    baseline-version: 1\n    # 字符编码 默认 UTF-8\n    encoding: UTF-8\n    # 是否允许不按顺序迁移 开发建议 true, 因为可能有多人在创建 sql  uat 与 prod 建议 false, 因为已经 sql 脚本合并了.\n    out-of-order: false\n    \n    # 需要 flyway 管控的 schema list,这里假设我们配置为  flyway  缺省的话, 使用spring.datasource.url 配置的那个 schema,\n    # 可以指定多个schema, 但仅会在第一个schema下建立 metadata 表, 也仅在第一个schema应用migration sql 脚本.\n    # 但flyway Clean 命令会依次在这些schema下都执行一遍. 所以 确保生产 spring.flyway.clean-disabled 为 true\n    # schemas: mall_member\n    \n    # 执行迁移时是否自动调用验证   当你的 版本不符合逻辑 比如 你先执行了 DML 而没有 对应的DDL 会抛出异常\n    validate-on-migrate: true\n```\n\n\n### 编写 sql 脚本\n```\n{prefix}{version}__{desc}.sql   为 flyweay 官方规范\n```\n我们自己做一些额外约定\n```\nprefix: 只允许 V 或 R\nversion: yyyyMMddhhmmss 时间格式\ndesc: {author}_{schemeOperation}_{doWhat}\nschemeOperation: DDL 或  DML\n```\n\n**示例**:\nsql 脚本在 resources/db/migration 下:\nV20220519052021__zk_DDL_createUserTable.sql\n\n```sql\nuse `mall_member`;\n-- 创建商城用户表\nCREATE TABLE `mall_user`(\n    `user_id`         int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `username`        varchar(125)    NOT NULL unique ,\n    `encode_password` varchar(125)       NOT NULL,\n    `age`             int(3)           NOT NULL,\n    PRIMARY KEY (`user_id`)\n) ENGINE = InnoDB\n  DEFAULT CHARSET = utf8mb4;\n```\n\nV20220519052121__zk_DML_insertUser.sql\n\n```sql\nuse `mall_member`;\n-- 插入管理员\ninsert into  mall_user values (1,'Felordcn','{noop}12345',18);\n```\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220519162150186.png#crop=0&crop=0&crop=1&crop=1&id=HMPnd&originHeight=80&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n启动项目即可, 成功启动项目, 则可见数据多了一张表 flyway_schema_history , 有如下数据\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220519162512813.png#crop=0&crop=0&crop=1&crop=1&id=JMWXE&originHeight=130&originWidth=1706&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n**注意事项**\n\n1.  sql 脚本一旦执行. 不允许再做修改,删除! 有需要请新建另一个 sql 脚本. \n2.  禁止使用 Undo 模式。 \n3.  **DDL 语句与 DML 语句一定要分开书写.** 不然, 在出错时,你不仅要清理flyway_schema_history 里出错的行. 还需要手动回滚脚本中所有 DDL 的操作. \n\n\n## QA\n\n### SQL 脚本执行报错及回滚\n\n当执行的 SQL 脚本在生产环境发生错误时,运维同学如何快速定位是 Flyway 执行的 SQL 脚本问题导致部署失败?以及如何回滚?\n\n下面这张截图是我在本地跑时报错的截图,项目未成功启动:\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ICB5rGJ5YGl6Lqr,size_20,color_FFFFFF,t_70,g_se,x_16-20220519111433334.png#crop=0&crop=0&crop=1&crop=1&id=JeFEE&originHeight=235&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n在接入 Flyway 部署后,运维同学虽然不需要手动执行 SQL 脚本,但需要确认本迭代的 SQL 脚本是否执行失败:\n\n```sql\nSELECT version,\n       installed_on,\n       CASE success\n           WHEN 1 THEN '成功'\n           WHEN 0 THEN '失败'\n           END\n           AS '执行状态'\nFROM flyway_schema_history\nORDER BY installed_on DESC\nLIMIT 50;\n```\n\n查看是否有执行失败的 SQL 脚本.\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220519160434607.png#crop=0&crop=0&crop=1&crop=1&id=Qkkhr&originHeight=71&originWidth=523&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n如果有失败情况, 则需要根据提交 sql 脚本. 做手动修补\n\n### Flyway 执行 version 顺序\n\n**Flyway** 是如何比较两个 **SQL** 文件的先后顺序呢？它采用 **采用左对齐原则, 缺位用 0 代替** 。举几个例子：\n\n> 1.0.1.1 比 1.0.1 版本高。\n\n\n> 1.0.10 比 1.0.9.4 版本高。\n\n\n> 1.0.10 和 1.0.010 版本号一样高, 每个版本号部分的前导 0 会被忽略。\n\n\n**Flyway** 将 **SQL** 文件分为 **Versioned** 、**Repeatable** 和 **Undo** 三种：\n\n- **Versioned** 用于版本升级, 每个版本有唯一的版本号并只能执行一次.\n- **Repeatable** 可重复执行, 当 **Flyway**检测到 **Repeatable** 类型的 **SQL** 脚本的 `checksum` 有变动, **Flyway** 就会重新应用该脚本. 它并不用于版本更新, 这类的 `migration` 总是在 **Versioned** 执行之后才被执行。\n- **Undo** 用于撤销具有相同版本的版本化迁移带来的影响。但是该回滚过于粗暴，过于机械化，一般不推荐使用。一般建议使用 **Versioned** 模式来解决。\n\n这三种的命名规则如下图：\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/1666778591497-082973e4-20c0-446c-bb71-c1bf811812cb.png)\n\n- **Prefix** 可配置，前缀标识，默认值 `V` 表示 **Versioned**, `R` 表示 **Repeatable**, `U` 表示 **Undo**\n- **Version** 标识版本号, 由一个或多个数字构成, 数字之间的分隔符可用点 `.` 或下划线 `_`\n- **Separator** 可配置, 用于分隔版本标识与描述信息, 默认为两个下划线 `__`\n- **Description** 描述信息, 文字之间可以用下划线 `_` 或空格 ``分隔\n- **Suffix** 可配置, 后续标识, 默认为 `.sql\n",
                    "title": "Flyway Guide"
                  },
                  {
                    "path": "搜索 mac 环境变量的值.md",
                    "content": "#mac   #docs/how-to-guides \n\n``` bash\nzsh -ixc : 2>&1 | grep  '要搜索的值'  \n```\n\n更多 [bash quickstart](5.轮子索引/4.系统.运维/bash/bash%20quickstart.md) 在这",
                    "title": "搜索 mac 环境变量的值"
                  },
                  {
                    "path": "效率工具/DataGrip virtual key.md",
                    "content": " #docs/how-to-guides    #datagrip\n\nIt could help build a connection between id even without actual foreign reference.\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221227130319275.aK7pN.jpg)\n\n\n![](https://md4zk.oss-cn-beijing.aliyuncs.com/img/20221227130327074.ESuqT.jpg)\n\n[Foreign keys | DataGrip Documentation](https://www.jetbrains.com/help/datagrip/foreign-keys.html#debug-rules-for-virtual-foreign-keys)",
                    "title": "DataGrip virtual key"
                  },
                  {
                    "path": "效率工具/Find Girls.md",
                    "content": " #docs/how-to-guides  #pua \n\n租房子，找转租的。微博有超话，比如“北京租房”。找个人发布房源，一般点微博进去就可以知道对方性别，甚至是长相。然后私信看房，加微信。去看房子的时候又能近距离聊天，又能看到对方打理房屋的样子，又有微信在手，以后就随你怎么聊了，可以多找几个。\n\n男女通用，约炮恋爱通用。\n\n‍\n",
                    "title": "Find Girls"
                  },
                  {
                    "path": "效率工具/chrome 浏览器看很多网站代码块背景是黑色的问题.md",
                    "content": "#tips #docs/how-to-guides  #chrome \n\n\n![image](https://tva3.sinaimg.cn/large/e729c8a3ly1ghq5pcrprmj21cw0wm0wm.jpg) 开启无痕窗口也是一样，排除插件的问题，主题恢复成默认也没解决。\n\n安装这个字体\n\nhttps://fonts.google.com/specimen/Source+Code+Pro\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220227110558-lkz2wea.png)\n",
                    "title": "chrome 浏览器看很多网站代码块背景是黑色的问题"
                  },
                  {
                    "path": "效率工具/photoshop 脚本自动化.md",
                    "content": "#ps  #yoga #tenwan #docs/how-to-guides \n\n工程文件在： /Users/zk/bdcloud/公司/藤蔓瑜伽/设计/老师资质\n \n步骤：\n\n1. 制作模板\n2. 准备脚本\n3. 准备数据\n4. 生成\n\n\n\n## 制作模板\n\n新建一个普通的 psd 工程，保存为 template.psd，作为模板。\n\n模板里层的命名要简单易懂，在脚本中会引用到\n\n![image-20190823112526814](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823112526814.png)\n\n\n\n模板决定了除文字内容外，所有的设置，包括文字位置，字体，颜色等。\n\n我现在还不知道怎么通过脚本动态修改图片。所以，如果有动态修改图片的需求，则将所有可能的图片导入模板，通过关键字显示。其他的隐藏。\n\n![image-20190823112840717](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823112840717.png)\n\n\n\n最终做好可能是这样\n\n![image-20190823114106878](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823114106878.png)\n\n## 准备脚本\n\n\\#include 是 photoshop 里引用 js 的关键字。\n\njson2.js 可以用来解析 json。在 github 下就 ok 了。\n\n至于函数可以查阅 photoshop-cc-javascript-ref-2015.pdf, adobe 官方有。\n\nmakeTeacherCard.jsx\n\n``` js\n// reference \n// https://www.youtube.com/watch?v=LxxqxEVYfVc\n//\n//\n\n#include json2.js\n\n(function main(){\n  var teachers = loadJson('teachers.json');\n  for(var i = 0; i < teachers.length; i ++){\n    var teacher = teachers[i];\n    processTeacher(teacher);\n  }\n})()\n\nfunction changeEntryBuilder(group,teacher){\n  return function (key,isarray){\n      if (key in teacher){\n        group.layers.getByName(key).visible =true;\n        group.layers.getByName(key).textItem.contents = teacher[key];\n      }else {\n        group.layers.getByName(key).visible =false;\n      }\n  }\n}\n\nfunction processTeacher(teacher){\n  var doc = app.activeDocument;\n  var group = doc.layerSets.getByName('data');\n  var builder = changeEntryBuilder(group,teacher)\n\n  builder(\"name\");\n  builder(\"bgtext\");\n  builder(\"info\");\n  builder(\"info1\");\n\n  builder(\"exp\");\n  for(var i = 0; i < 12; i ++){\n    builder(\"time\"+i);\n  }\n\n  var imgs =doc.layerSets.getByName('imgs');\n  for(var q = 0; q < imgs.layers.length; q++){\n   \n    if(teacher[\"imgid\"] == imgs.layers[q].name)\n      imgs.layers[q].visible = true;\n    else{\n      imgs.layers[q].visible = false;\n    }\n  }\n  \n  saveGroup(group, teacher.name);\n}\nfunction saveGroup(group,name){\n//  group.visible = true;\n  saveJpeg(name);\n//  group.visible =false;\n}\nfunction loadJson(relPath){\n  var script = new File($.fileName);\n  var jsonFile = new File(script.path + '/' + relPath)\n\n  jsonFile.open('r');\n  var str = jsonFile.read();\n\n  jsonFile.close()\n\n  return JSON.parse(str);\n}\n\nfunction saveJpeg(name){\n  var doc = app.activeDocument;\n  var file = new File(doc.path + \"/gen/\" + name + '.jpg');\n\n  var opts = new JPEGSaveOptions();\n  opts.quality = 10;\n\n  doc.saveAs(file, opts, true);\n}\n```\n\n\n\n## 准备数据\n\n``` json\n[\n  {\n    \"imgid\":\"dkl\",\n    \"info\":\"连续两年获年度（最佳人气老师）称号\",\n    \"name\":\"狄凯丽老师\",\n    \"bgtext\":\"丽\",\n    \"exp\":\"5 年教学经验\",\n    \"time0\": \"2018年11月 艾扬格密集练习培训三\",\n    \"time1\": \"2018年04月 艾扬格女性—生理期调理培训\",\n    \"time2\": \"2017年11月 艾扬格肩颈理疗\",\n    \"time3\": \"2017年08月 艾扬格密集练习培训二\",\n    \"time4\": \"2017年03月 （薄伽梵歌原意）初阶课程\",\n    \"time5\": \"2017年02月 获年度最佳人气老师称号\",\n    \"time6\": \"2016年11月 减脂塑身课程\",\n    \"time7\": \"2016年05月 喜马拉雅生命科学学习\",\n    \"time8\": \"2016年02月 获年度最佳人气老师称号\",\n    \"time9\": \"2015年09月 艾扬格密集练习培训一\",\n    \"time10\":\"2015年03月 理疗工作坊\",\n    \"time11\":\"2014年05月 哈他初中高证书\"\n  }\n  ]\n```\n\n\n\n## 生成\n\n### 手动生成\n\n将 psd 模板处当前打开状态下。点击 File -> Scripts -> Browse.. ，找到「制作脚本」步骤的 makeTeacherCard.jsx。\n\n奇迹出现了。 图片会生成到 psd 模板文件的 gen 下。\n\n![image-20190823114139956](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823114139956.png)\n\n\n\n如果要增加快捷键 到 Edit -> KeyBoard Shortcut.. 里定义即可。\n\n### 自动生成\n\n如果你想只要在发动模板就自动调用脚本去生成，如下操作\n\n打开 File -> Scripts -> Script Events Manager... \n\n将红框里的值对应好，点击 add。\n\n这样就会当你保存 psd 时，就会自动触发脚本\n\n> 注意： 如果你的 psd 没有发生变化， Save Document 事件是不会触发的。\n\n\n\n![image-20190823113852010](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823113852010.png)\n\n",
                    "title": "photoshop 脚本自动化"
                  },
                  {
                    "path": "效率工具/vimscript.md",
                    "content": "#vim #docs/tutorials \n## Basics\n\nset arg?   显示变量的值\n\n:messages  查看消息日志\n\n注意以下带 `:`的命令是在 cmdline 下执行. 不是放在 .vimrc 里. 如果在脚本里, 要去掉 :\n\n## 常用变量\n\n### statusline \n\n设置状态条, 有点像 c 里的 printf, 这样用\n\n```\n:set statusline=%f\n:set statusline=%f\\ -\\ FileType:\\ %y\n```\n\n也可以连续设值, 看起来更清晰\n\n```vim\n:set statusline=%f         \" 文件的路径\n:set statusline+=\\ -\\      \" 分隔符\n:set statusline+=FileType: \" 标签\n:set statusline+=%y        \" 文件的类型\n:set statusline=[%4l]      \" 至少显示 4 个字符宽的行号 例如：[  12]\n:set statusline=[%04l]      \" 至少显示 4 个字符宽的行号 例如：[0012]\n:set statusline=%.20F       \" 最多显示 20 个字符的完整路径名,超出以 < 代替前的,如<hapters/17.md\n\n\n```\n\n\n\n常用点位符\n\n```vim\n%l  当前行号\n%L  叫行数\n%f  当前文件名\n%F  完整路径名\n%y  当前文件类型\n%=  右对齐\n```\n\n帮助看\n\n```\n:help statusline\n```\n\n\n\n## echo & echom\n\necho 非常奇怪\n\n```\nlet foo = \"bar\"\necho foo   \n\" 打印出 bar\n\nset textwidth=80\necho textwidth  \n\"将报错\n\necho &textwidth \n\" 打印出 80\n\necho &textwidth99\n\" 打印出 80 99\n\n```\n\n就像大多数编程语言，Vimscript允许你在字符串中使用转义字符串来表示\"打不了\"的字符。 执行下面命令：\n\n```vim\n:echom \"foo \\\"bar\\\"\"\n```\n\n字符串中的`\\\"`将如你所愿地被替换成双引号。转义字符串在大多数情况下都会如你所愿。 执行下面的命令：\n\n```vim\n:echom \"foo\\\\bar\"\n```\n\nVim显示`foo\\bar`，因为`\\\\`是表示'\\'的转义字符串，一如大多数编程语言。 现在执行下面的命令(注意那是`echo`而*不是*`echom`)：\n\n```vim\n:echo \"foo\\nbar\"\n```\n\n这次Vim将显示两行，`foo`和`bar`，因为`\\n`会被替换为换行。现在试试下面的命令：\n\n```vim\n:echom \"foo\\nbar\"\n```\n\nVim将显示类似`foo^@bar`的诡异信息。当你对字符串使用`echom`而不是`echo`时， Vim将输出字符串中*额外的*字符，这意味着有时`echom`的输出跟`echo`的会有所不同。 `^@`在Vim里表示\"换行符\"。\n\n\n\n## let 与 set\n\n我们先要区别两种变量. 一种是你自己创建的叫 variable .一种是 vim 内置的 叫option\n\nset 只能与 option 工作\n\n\n\n```\nset number 的意思就是\nset number =True\n\nset nonumber 的意思是\nset number = False\n\nset number! 的意思是\nset number =!number\n\nset number? 的意思是\necho number\n\nset number numberwidth=6 的意思是\nset number=6\nset numberwidth=6\n```\n\n而 let 可以做 set 做的事,还能做更多\n\n比如 \n\n```\nlet foo='bar'  \"设置 variable\nlet &textwidth=80  \"设置 option\nlet @a=$HOME . '/vimfiles' \"设置寄存器 ,执行 \"ap \nlet $NOTHING ='NONTHING' \"设置环境变量\nlet &l:number = 1 设置当前 local 行号打开\n```\n\nset 基本上只能设一个常量值,那要实现 option=option+1 的功能,就无能为力了,但 let 可以\n\n```\nlet &textwidth = &textwidth + 10\n```\n\n\n\n> 在 set 能搞定时, 不要用 let . let 难于阅读\n\n\n\n## 寄存器\n\ny命令会将内容放在未命名寄存器里,也就是 \" 里.\n\n/ 字段会将搜索内容放在 / 寄存器里\n\n也可以通过 let @a=xx  选择放什么到某寄存器\n\n打印寄存器里 yy 的内容, \" 代表未命名寄存器\n\n```\n:echo @\"  \n```\n\n打印上次搜索的值\n\n```\n:echo @/  \n```\n\n查看当前所有 register 的值\n\nregister ,  reg \n\n\n\n@@ 未命名寄存器\n\n帮助文档:\n\n:help registers\n\n## vim 通用语言\n\n### 变量作用域\n\n:help internal-variables\n\n```\n                (nothing) In a function: local to a function; otherwise: global \nbuffer-variable    b:     Local to the current buffer.                          \nwindow-variable    w:     Local to the current window.                          \ntabpage-variable   t:     Local to the current tab page.                        \nglobal-variable    g:     Global.                                               \nlocal-variable     l:     Local to a function.                                  \nscript-variable    s:     Local to a :source'ed Vim script.                     \nfunction-argument  a:     Function argument (only inside a function).           \nvim-variable       v:     Global, predefined by Vim.\n```\n\n### 条件分支\n\n```vim\n:if 0\n:    echom \"if\"\n:elseif \"nope!\"\n:    echom \"elseif\"\n:else\n:    echom \"finally!\"\n:endif\n```\n\n支持 if  elseif   else\n\n\n\n```\nif 1\n\techo \"one\"\nendif\n```\n\n\n\n#### 强制转换\n\n```vim\n:if \"9024\"\n:    echom \"WHAT?!\"\n:endif\n\n输出 WHAT?!\n```\n\n当需要做强制转换 到数字时, 逻辑是\n\n如果是数字,则转为数字\n\n如果开头是数字,则只转开头的数字\n\n如果不是数字,则变为 0\n\n```vim\n:if \"something\"\n:    echom \"INDEED\"\n:endif\n\n无输出\n```\n\n#### 大小写由用户决定敏不敏感的 ==\n\n```vim\n:set noignorecase\n:if \"foo\" == \"FOO\"\n:    echom \"vim is case insensitive\"\n:elseif \"foo\" == \"foo\"\n:    echom \"vim is case sensitive\"\n:endif\n```\n\n\n\n```vim\n:set ignorecase\n:if \"foo\" == \"FOO\"\n:    echom \"no, it couldn't be\"\n:elseif \"foo\" == \"foo\"\n:    echom \"this must be the one\"\n:endif\n```\n\n这意味着什么？意味着在为别人开发插件时，你*不能*信任`==`。 一个不加包装的`==`*不能*出现在你的插件代码里。\n\n所以,应该这样写\n\n`==?` 无论你怎么设都大小写*不敏感*\"比较操作符\n\n```vim\n:if \"foo\" ==? \"FOO\"\n:    echom \"first\"\n:elseif \"foo\" ==? \"foo\"\n:    echom \"second\"\n:endif\n```\n\n`==#`是\"无论你怎么设都大小写*敏感*\"比较操作符\n\n```vim\n:set ignorecase\n:if \"foo\" ==# \"FOO\"\n:    echom \"one\"\n:elseif \"foo\" ==# \"foo\"\n:    echom \"two\"\n:endif\n```\n\n\n\n比较符帮助文档\n\n:help expr4\n\n\n\n### 多行语句\n\n用 | 连接, 注意这不是管道!  它能够分隔两个单独的命令.\n\n```vim\n:echom \"foo\" | echom \"bar\"\n```\n\n比如,你在测试独立命令时, 如果一行行的输入太麻烦,可以用上面的 |.\n\n### 函数\n\n**没有作用域限制的Vimscript函数必须以一个大写字母开头！**\n\n即使你*真的*给函数限定了作用域(我们待会会谈到)，你最好也用一个大写字母开头。 大多数Vimscript程序猿都是这么做的，所以不要破例。\n\n定义函数\n\n```vim\n:function Meow()\n:  echom \"Meow!\"\n:endfunction\n\n:function GetMeow()\n:  return \"Meow String!\"\n:endfunction\n```\n\n调用一个函数\n\n```vim\n:call Meow()  \" 返回值会被丢弃\n\n:echom GetMeow() \"带返回值,如果函数没返回值,将返回 0\n\n```\n\n\n\n```vim\nfunction TextwidthIsTooWide()\n  if &l:textwidth ># 80 \" \n    return 1\n  endif\nendfunction\n\nset textwidth=180\nif TextwidthIsTooWide()\n  echom \"WARNING: Wide text!\"\nendif\n```\n\n<SID> 使 vim 能够找到这个函数, 不然 vim 会到全局空间去找, 而因为函数使用了 s: 只在脚本内可见, 是不可能找到的\n\n```vim\nnnoremap <leader>g :set operatorfunc=<SID>GrepOperator<cr>g@\nvnoremap <leader>g :<c-u>call <SID>GrepOperator(visualmode())<cr>\n\nfunction! s:GrepOperator(type)\n    let saved_unnamed_register = @@\n\n    if a:type ==# 'v'\n        normal! `<v`>y\n    elseif a:type ==# 'char'\n        normal! `[v`]y\n    else\n        return\n    endif\n\n    silent execute \"grep! -R \" . shellescape(@@) . \" .\"\n    copen\n\n    let @@ = saved_unnamed_register\nendfunction\n```\n\n\n\n**当看到 call filename#funcname()**　　\n\n一般是用在 autoload的时候。\n\nvim　会去runtimepath 里找　filename.vim。找filename#funcname()　函数。所以你在filename.vim 定义函数时。也得这样写\n\n```\nfunction filename#funcname()\n\t...\nendfunction\n```\n\n也可以在子文件里定义，比如　　call  foder1#folder2#functionname()，文件名同理也一样要改变\n\n\n\nfunction! 这个感叹号的意思是如果存在一样的名字,则覆盖\n\n\n\n **帮助文档**\n\n:help :call\n\n哪些可以用来做变量名\n\n:help E124 \n\n:help return\n\n\n\n### 带参\n\n```vim\n:function DisplayName(name)\n:  echom \"Hello!  My name is:\"\n:  echom a:name\n:endfunction\n```\n\n一定要使用a:name 不然会找不到变量\n\n### 可变长参\n\n```vim\n:function Varg(...)\n:  echom a:0\n:  echom a:1\n:  echo a:000\n:endfunction\n\n:call Varg(\"a\", \"b\",\"c\")\n```\n\na:0 为变参的长度\n\na:000 为变参\n\n变参不能用 echom ,  只能用echo打印\n\n不能对变参再赋值, 可以通过以下方式搞个复制.再赋值\n\n```vim\n:function AssignGood(foo)\n:  let foo_tmp = a:foo\n:  let foo_tmp = \"Yep\"\n:  echom foo_tmp\n:endfunction\n\n:call AssignGood(\"test\")\n```\n\n**帮助文档**\n\n:help function-argument\n\n:help local-variables\n\n### 数字\n\n0xee  16 进制\n\n09  (0 开头为 8 进制. 当心,就算写 9 也不会报错!)\n\n3/2 =1\n\n3+2 =5  注意+号只能用在数学运算, 不能用来连接字符串\n\n**帮助文档**\n\n:help Float\n\n:help floating-point-precision\n\n### 字符串\n\n用 . 来连接字符串\n\n```\n:echom \"abc\" . \"de\"  => abcde\n:echom 10 . \"foo\"    => 10foo\n:echom 10.1 . \"foo\"  => <error>\n```\n\n使用 ' 可以不用转义字符\n\n**帮助文档:**\n\n:help literal-string\n\n## iabbrev\n\n相当于简化版的 snippet, 与 coc 有点冲突。关闭 coc 后测试\n\n```vim\n:iabbrev adn and\n```\n\n结合 buffer ,创建简易版的 snippet ,augroup 作用是防止多次加载(组合原理)\n\n```vim\n:augroup zKsnippets\n:   autocmd!\n:   autocmd FileType python     :iabbrev <buffer> iff if:<left>\n:   autocmd FileType javascript :iabbrev <buffer> iff if ()<left>\n:augroup END\n```\n\n记住：最好的学习使用这些snippets的方法是*禁用*之前你做这些事情的方式。执行`:iabbrev <buffer> return NOPENOPENOPE`会*强迫*你使用缩写，这个命令在你输入return的时候不会输出任何东西。为了节省学习的时间，为你刚才创建的snippets都创建一个上面的缩写来*强迫*你使用你创建的snippets。\n\n## map\n\n unmap  某个 key   i 代表 insert \n\n```vim\n:iunmap ssig\n```\n\n在Vim中有很多默认的方式可以退出插入模式：\n\n- `<esc>`\n- `<c-c>`\n- `<c-[>`\n\n使用 jk 映射的优点\n\n如果你出于习惯在常用模式下按了`jk`，只会将光标向下移动一下，然后又向上移动一下，最终光标还是停留在原来的位置。\n\n```vim\n:inoremap jk <esc>\n```\n\n如果要适应 jk , 最好的方法是禁用原来的 esc\n\n```vim\n:inoremap <esc> <nop>\n```\n\n\n\n```\n     COMMANDS                    MODES                                                 \n:map   :noremap  :unmap     Normal, Visual, Select, Operator-pending                   \n:nmap  :nnoremap :nunmap    Normal                                                     \n:vmap  :vnoremap :vunmap    Visual and Select                                          \n:smap  :snoremap :sunmap    Select                                                     \n:xmap  :xnoremap :xunmap    Visual                                                     \n:omap  :onoremap :ounmap    Operator-pending                                           \n:map!  :noremap! :unmap!    Insert and Command-line                                    \n:imap  :inoremap :iunmap    Insert                                                     \n:lmap  :lnoremap :lunmap    Insert, Command-line, Lang-Arg                             \n:cmap  :cnoremap :cunmap    Command-line                                               \n:tmap  :tnoremap :tunmap    Terminal       \n```\n\n\n\n## buffer\n\n<buffer> 只在定义它的缓冲区有效,  最常见的定义方式,就是直接在 : 里直接输入k. \n\n这里就应该使用 <localleader> 更为合适,因为 local  只在当前 buffer 有效\n\n```vim\n\"  以下命令是 在 command mode 里执行\n:nnoremap <buffer> <leader>x dd\n\" 当你切换 buffer 时，则这个绑定就失效了\n```\n\n`<buffer >`的命令比全局的有更高的优先级.\n\n```vim\n:nnoremap <buffer> Q x    <--优先这个\n:nnoremap          Q dd\n```\n\n\n\nvim 下有多个 tab \n\n- :tabe 创建新 tab\n- :tabc  关闭 tab\n\ntab 下有多个 buffer.\n\n- :badd  创建 buffer\n\nbuffer 下有多个 window, window 是一个 buffer 的 viewport . 可以多个 window 对应同一个 buffer .\n\n![image-20190501232632011](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190501232632011.png)\n\n\n\n## autocmd自动命令\n\n可以缩写为 au ,这个命令执行的时机是在设定文件类型的时候.\n\n### 监听事件\n\n```text\n:autocmd BufNewFile * :write\n         ^          ^ ^\n         |          | |\n         |          | 要执行的命令,但不能是 <cr>\n         |          |\n         |          用于事件过滤的“模式（pattern）”\n         |\n         要监听的“事件”\n```\n\n**比如:**\n\n1. 在文件打开后,就写入文件到硬盘, 默认 vi a.txt ,如果 a.txt 不存在,是不会创建的(在 buffer 里),除非你 wirte 到硬盘\n\n```vim\n:autocmd BufNewFile * :write\n```\n\n2. 写入前格式化\n\n```vim\n:autocmd BufWritePre *.html :normal gg=G\n```\n\n3. 绑定多个事件, 不仅写入前, 在读的时候也格式化\n\n```vim\n:autocmd BufWritePre,BufRead *.html :normal gg=G\n```\n\n\n\n在Vim脚本编程中有一个不成文的规定，你应该同时使用`BufRead`和`BufNewFile`（译注：这里不是BufWritePre）这两个事件来运行命令，这样当你打开某个类型的文件，不论这个文件是否存在命令都会执行。执行下面的命令：\n\n```vim\n:autocmd BufNewFile,BufRead *.html setlocal nowrap\n```\n\n上面的命令会使得无论你在什么时候编辑HTML文件自动换行都会被关闭。\n\n### FileType事件\n\n最有用的事件是`FileType`事件。这个事件会在Vim设置一个缓冲区的`filetype`的时候触发。\n\n让我们针对不同文件类型设置一些有用的映射。运行命令：\n\n```vim\n:autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>\n:autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>\n```\n\n打开一个Javascript文件（后缀为`.js`的文件）,将光标移动到某一行，敲击`<localleader>c`，光标所在的那一行会被注释掉。\n\n现在打开一个Python文件（后缀为`.py`的文件）,将光标移动到某一行，敲击`<localleader>c`，同样的那一行会被注释掉，不同的是此时所用的是Python的注释字符！\n\n\n\n### 事件例表\n\n```\n:help autocmd-events\n```\n\n\n\n## normal\n\n在 command 里执行  normal的命令\n\n![image-20191023220149137](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20191023220149137.png)\n\nnormal! 将**忽略用户的映射**. 在写Vim脚本时，你应该*总是*使用`normal!`\n\n比如你映射了 nnoremap G dd\n\n```vim\n:normal! G \n```\n\n将还是跳到末行.\n\n\n\n但有个问题, 如下命令,会将`<cr>` 当一个一个的字符,而非回车\n\n```vim\n:normal! /foo<cr>\n```\n\n解决这个问题需要借助于 execute, 使用普通的转义字符串来生成你需要的\"打不出\"的字符。 \n\n```vim\n:execute \"normal! /foo<\\r\"\n```\n\n常用转换\n\n`<esc>`  ->  `\\<esc>`\n\n`<cr>`   ->  `\\r`\n\n\n\n## execute\n\nexecute 相对于 normal . 它运行的是字符串,比如函数名什么的.\n\n``` \n:execute \"write\"\n:execute \"normal! gg\"\n```\n\n\n\n```\n:execute \"rightbelow vsplit \" . bufname(\"#\")\n```\n\n:rightbelow     这个命令是指定分割时放在右边或者下面.  后面跟的命令是左右分割,所以是放在右边.\n\nbufname 在执行后的返回值 将做为 rightbelow vsplit  的参数\n\n不过 execute 一般会和 normal! 连用\n\n```vim\n:execute \"normal! gg/print\\<cr>\"\n```\n\n## \n\n## augroup\n\n这个功能是和 autocmd  一起用的. 如果一条 autocmd 命令被执行多次.那在触发时,就会触发多次. 为避免这种问题.加上一个augroup 作为关键字,比如\n\n我们首先定义以下组\n\n```vim\n:augroup testgroup\n:    autocmd BufWrite * :echom \"Foo\"\n:    autocmd BufWrite * :echom \"Bar\"\n:augroup END\n```\n\n要清除时,而不是只加载一次哦! 比如,我们又执行以下命令\n\n```vim\n:augroup testgroup\n:    autocmd!\n:    autocmd BufWrite * :echom \"Cats\"\n:augroup END\n```\n\n那在写入文件时, 只会打印出Cat 了\n\n:star2:所以在 vimrc 里应该都这样写 \n\n```\naugroup {key}\n    autocmd!\n    autocmd {cmd}\naugroup END\n```\n\n\n\n## Movement映射\n\n\n\no 代表 operator 操作映射\n\n```vim\n:onoremap p i(\n```\n\noperator 包括  d y  c 之类的\n\n比如 dp 就会删除括号里的东西\n\n\n\n```vim\n:onoremap in( :<c-u>normal! f(vi(<cr>\n```\n\n```python\n将光标放在 print 处, 按cin(\nprint foo(bar)\n```\n\n\n\n\n```\n:<c-u>normal!\n<c-u> 会清除选区，也就是类似下的东西不会生效\n:'<,'> \n这是vim 自动帮你加的 range,如果不需要这个 range,则按 :<c-u>,变成\n```\n\n\n```\n:nnoremap G dd\n:normal G   \"将执行 dd\n:normal! G  \"将还是 G 的功能,直接到文章尾\n```\n\n**一般规则**\n\n下面两条规则可以让你可以很直观的以多种方式创建operator-pending映射：\n\n- 如果你的operator-pending映射以在可视模式下选中文本结束，Vim会操作这些文本。\n- 否则，Vim会操作从光标的原始位置到一个新位置之间的文本。\n\n\n\n:help omap-info 帮助文档\n\n\n\n\n\n例子:\n\n```vim\n:onoremap ih :<c-u>execute \"normal! ?^==\\\\+$\\r:nohlsearch\\rkvg_\"<cr>\n:onoremap ah :<c-u>execute \"normal! ?^==\\\\+$\\r:nohlsearch\\rg_vk0\"<cr>\n```\n\n1.  将 md 里用 = 标识的标题做为 object\n2. 将 md 的用 = 标识的标题,以及 = 做为 object\n\n 当`execute`碰到任何你想让它执行的字符串的时候。它会先替换这个字符串中的所有特殊字符。在这个示例中，`\\r`是一个转义字符，它表示的是\"回车符（carriage return）\"。两个反斜线也是一个转义字符，它会将一个反斜线当作一般字符放到字符串中。\n\n我们来做个试验\n\n```\n:normal! gg/a<cr>\n```\n\n屏幕上出现了 bc<cr>,并没像我们预想一样到顶端后搜索 a,原因是<cr> normal命令不识别\n这时 execute 上场了\n\n```\n:execute \"normal! gg/a\\r\"\n:execute \"normal! gg/a\\<cr>\"\n```\n\n\\r  也是回车的意思, 第一条命令就会如期执行. 用\\r 代替了 <cr>.\n\n第二命令要多写几个字...\n\n变成\n\n```text\n:onoremap ih :<c-u>execute \"normal! ?^==\\+$<cr>:nohlsearch<cr>kvg_\"<cr>\n                \t\t\t\t\t\t\t\t\t\t\t\t\t\t^^^^           ^^^^\n                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t ||             ||\n这里的<cr>实际上是一个回车符，而不是由4个字符——“左尖括号”，“c“，”r“和“右尖括号”组成的字符串。\n```\n\n\n\n## textwidth\n\n```\nset tw =20 \n```\n\n要配合 *formatoptions* (简写 fo) 使用, t 代表开启.\n\n```\nset fo+=t\n```\n\n超 20 个字符时,自动换行.\n\n## 搜索!\n\n正则表达式\n\n使用 \\v ! \n\n```vim\n:execute \"normal! gg\" . '/\\vfor .+ in .+:' . \"\\<cr>\"\n```\n\n:help magic\n\n## 自定义 grep\n\n<cword>  delimeted by a lot of stuff. including space,'/', \\t\n\n<cWORD>  delimeted only by space\n\nex:\n``` txt\nrun viw/viW on layouts \napps/views/layouts/admin.blade.php\n\tabcde\n```\n\n\n\n\n\n\n\n## commands and functions\nhttps://vi.stackexchange.com/questions/19142/why-do-functions-in-vimscript-require-a-call-statement\ncommands is a old thing in Vi. functions introduced in VIM.\n\nto make a diffrence between them . \n\nfunction need to be called by `call`. and followed by  ()\n\ncommand don't have to . and command don't need ()\n\nso!\ncommand = call function(args)\n\n\nyou can check your command by :com\n\n```vim\n:function GetMeow()\n:  return \"Meow String!\"\n:endfunction\n:GetMeow()       \" ERROR!\n:call GetMeow()  \" no output\n:echom GetMeow() \" shows the string\n```\n\n\n##  example explains\nhttps://learnvimscriptthehardway.stevelosh.com/chapters/32.html\n``` vim\n:nnoremap <leader>g :silent exe \"grep! -R \" . shellescape(expand(\"<cWORD>\")) . \" .\"<cr>:copen<cr>\n\n <cWORD>:  get the WORD in command-line mod.  but when WORD is abc;ls it breaks.\nwe need to add  double quote around. but when WORD is that's, it breask.. \nwe need to escpae it . using shellescape(), but WORD becomes <cWORD> ,\n\ntry: \nechom shellescape(\"<cWORD>\")\n\nwe need to expand it before it get escpaed. \n\ntry: \nechom shellescape(expand(\"<cWORD>\"))\n\ngrep default jump the cursor to the first found WORD.\nwe could use grep! instread. it won`t move the cursor\n\n. concat the strings. and exe represents  execute.\n\n:copen open the result in quickfix\n\n:silent  will remove to search output.  if you don`t use silent. it will prompt two times. one is output. the other is quickfix.\n\n```\n\n\n# vim-vimscript-教程\n\nhttp://learnvimscriptthehardway.onefloweroneworld.com/\n\n中文版 hard way\n\nhttp://learnvimscriptthehardway.stevelosh.com/ 英文版 hard way\nabout fzf jump in lines\nhttps://medium.com/@_ahmed_ab/crazy-super-fast-fuzzy-search-9d44c29e14f\ncoc ,and a good web site for vim\nhttps://medium.com/@chemzqm/create-coc-nvim-extension-to-improve-vim-experience-4461df269173\nabout command! explaination\nhttps://vi.stackexchange.com/questions/13965/what-is-command-bang-nargs-in-a-vimrc-file/13967\n",
                    "title": "vim-vimscript-教程"
                  },
                  {
                    "path": "效率工具/内网穿透.md",
                    "content": "#docs/how-to-guides  #basic/network \n\n### ![image-20220315153250619](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20220315153250619.png)\n\n\n\nhttps://natapp.cn\n\n[www.zhexi.tech](https://www.zhexi.tech)\n上面这个公司被下面这个公司收\nhttps://www.oray.com",
                    "title": "内网穿透"
                  },
                  {
                    "path": "效率工具/如何快速摸清一个行业/短的时间里了解并分析一个行业.md",
                    "content": "#business/investigation  #docs/how-to-guides \n\n\n本科一毕业就在战略咨询搬砖，在非常短的时间里了解并分析一个行业可以说是基本功了\n\n**高赞回答基本上都是分析的思维导图，当然维度非常全，但并不是非常实用**\n\n对于一个新手来说照着思维导图上的内容按图索骥分析下来，还没分析完外部环境估计人已经晕了\n\n**对着密密麻麻的内容，按部就班地分析就和从a开始背单词背到abandon就结束了一样，有用但不实用**\n\n而真正实用的方法应该是可以让新人在一个极其简单的方法论的基础上最终能自发地建立出一整套完整的分析框架的\n\n**而这方法论非常的简单，就是思考及分析的时候要“由低维到高维，由小及大，由点及面”**\n\n这里引用黑衣人的结尾片段让大家有一个比较直观的认知\n\n![](https://pic1.zhimg.com/50/v2-77fbaaad53a30a15174274ba51652e08_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n而对于行业分析，其实就是这样的一个思考框架\n\n![](https://pic2.zhimg.com/50/v2-fb991335f9b61c0a45da3b1f1d3d5aaa_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n这个方法论一共有2个部分，4个环节，2个思考方式。\n\n**Part 1 由小及大（代入式思考：业内人士视角）**\n\n*环节1：分析行业内的一家头部公司（关键词：收入&amp;成本）*\n\n*环节2：分析整个行业（关键词：竞品对标）*\n\n**Part 2 由点及面（跳出式思考：外部人士视角）**\n\n*环节3：分析行业的目前的趋势（关键词：自我对标）*\n\n*环节4：分析整个行业的周期（关键词：发展&amp;波动）*\n\n任何一个人认识一个事物都是需要一个循序渐进的过程的，行业分析也不例外\n\n**上来连这个行业里的一家公司是怎么赚钱的都搞不明白，就直接分析趋势及周期基本就是在痴人说梦了**\n\n**当然，只分析和了解公司挣钱的逻辑，完全不考虑大方向即趋势和周期，这对于整个行业分析来说也是不完整且缺乏思考深度与高度的**\n\n接下来，我们来分别聊聊每个环节具体该怎么思考\n\n---\n\n## **Part 1 由小及大（代入式思考：业内人士视角）**\n\n这部分最关键的就是你需要学会代入式思考\n\n**很多人做不好公司及行业层面的分析，最关键的一点原因就是分析的时候永远都置身事外，从外部者的角度去分析**\n\n但事实上你不真正地把自己代入进去成为这一行业的一个玩家，你很难切身去体会这个行业关键点在哪里？\n\n**环节1：分析行业内的一家头部公司（关键词：收入&amp;成本）**\n\n为什么选一家头部公司呢，道理很简单，头部公司的信息最容易收集，方便自己做分析\n\n好了，现在把自己想象成为这一行业的一个头部玩家，你开这家公司的原因很简单，就是为了赚钱\n\n**而赚钱的核心是买卖，你需要把你生产的东西卖给需要它的人，当然你生产的东西是需要成本的，因此在这一环节，你只需要弄清楚4个问题**\n\n> *问题1：你的产品是什么？*  \n> *问题2：你卖给谁？*  \n> *问题3：每个产品的价格是多少？*  \n> *问题4：你的成本是什么？*\n\n其中123与收入有关，4则与成本有关\n\n举个例子，假设你是一家新式茶饮公司的老板，想一想你的产品是什么？Emmm，茶饮和面包\n\n那卖给谁呢？如果从销售渠道分的话那就是点外卖的人和路过店的人，如果按照年龄来分那又是巴拉巴拉，再按照性别来分那又是巴拉巴拉\n\n价格多少呢？一杯茶25-35元，一个面包大概15-30元\n\n那你的成本是什么呢？租金、员工费用、原材料成本等等\n\n**作为老板，你一定想赚更多的钱，想赚更多的钱，无非就是提高收入或减少成本，那针对之前的4个问题，又演变为以下4个问题。**\n\n> *问题1：我是否要新增产品或者减少产品？*  \n> *问题2：我如何扩展我的消费群体和对象 ？*  \n> *问题3：我是否要调整定价？*  \n> *问题4：我怎么节省我的成本？*\n\n**那在解决这4个问题之前一定需要知道我收入与成本的构成是什么，才能针对性地去提升，简单说就是搞细致，go to detail**\n\n因此关于收入你需要将你的产品拆分详细，拆得不能再拆了，然后再看每一个产品的运营效率究竟如何\n\n例如，茶饮分为奶茶、果茶、奶盖茶等等，面包又分为现制烘焙和预制烘焙，现制烘焙又分为A类面包、B类面包等等\n\n那它们又分别都是卖给谁的，定价分别又是多少？销量如何？客户满意度怎么样？\n\n而成本上最常见的拆分方法法就是固定成本与[可变成本](https://www.zhihu.com/search?q=%E5%8F%AF%E5%8F%98%E6%88%90%E6%9C%AC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)，固定成本包括租金，设备，员工等，可变成本则包括原材料成本，制造成本，物流成本等\n\n最后再两者结合起来看看自己每一类业务的利润情况，评估自己赚钱的情况，什么是容易赚的，什么又是辛苦钱\n\n等你把以上这些问题都了解清楚了即搞懂了我钱怎么来，我钱又花到哪里去，哪些钱容易挣，那基本上你算是对这个公司入门了\n\n**通常来说，分析这些可以从这家公司的三张表出发，对于业务层面的理解最高效的方式就是阅读**​[招股说明书](https://www.zhihu.com/search?q=%E6%8B%9B%E8%82%A1%E8%AF%B4%E6%98%8E%E4%B9%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)****\n\n如果这个行业没有一家公司上市，咨询公司通常的做法是进行专家访谈、Cold Call以及实地调研，来帮助自己了解以上的问题\n\n**环节2：分析整个行业（关键词：竞品对标）**\n\n搞清楚了前面的4个问题，你对自己有了一个比较基本的了解，但依旧很难解决之前的那个问题，我怎么去赚更多的钱？\n\n这是因为行业里并不只有你一个玩家，你需要对标才能帮助你去做决策。\n\n**那对标什么呢？依旧是前面分析的4个问题，只是对象变了，你需要弄清楚你的竞争对手是怎么做的，成功的地方“比学赶帮超”，失败的地方引以为鉴就对了**\n\n> *问题1：竞争对手的产品是什么？产品线是比我多，还是产品更精简？*  \n> *问题2：竞争对手的用户是谁？有没有挖掘出我之前没想到过的用户群体？*  \n> *问题3：竞争对手的定价策略是什么？是不是走高端线，或者都是低端线？*  \n> *问题4：竞争对手的成本是什么情况？成本多少，又是如何削减成本的？*\n\n在分析完以上这些问题，你对整个行业开始有了相对清楚的认知，你知道玩的最好的玩家好在哪里，你也知道玩的最差的玩家差在哪里\n\n**但此时的你还是站在公司的维度，而分析到这里你需要提升一个维度了，你需要把所有在这个行业的玩家捏合起来进行总结**\n\n把他们看成一个整体进行分析，这时候你最需要知道什么呢？\n\n你需要了解自己——弄清已知，了解外界——弄清未知\n\n**总结来看依旧是4个问题，2个内部问题，2个外部问题**\n\n> **内部问题：**  \n> *问题1：这行的关键成功因素是什么？*  \n> *问题2：这行自身最大的风险是什么？*  \n> **外部问题：**  \n> *问题3：这行的市场规模有多大？还能再大吗？这关系到增量*  \n> *问题4：这行的护城河是什么？新玩家进来会轻松分我的蛋糕吗？这关系到存量*\n\n关于这环节，建议从阅读媒体新闻开始入手，有了一个基础认识之后再去阅读专业机构的报告，例如咨询公司的报告以及券商的行业分析报告\n\n弄清楚以上这些，第二环节也算是入门了\n\n## **Part 2 由点及面（跳出式思考：外部人士视角）**\n\n到了这阶段的你，对自己的公司和行业已经有了一个基本的认识了，而这时候你需要切换自己的思考方式，从代入式思考转变为跳出式思考\n\n因为在接下去的两个环节，你将更多地关注大方向上的东西，如果依旧采用代入式思维，很容易陷在纯粹的买卖之中\n\n**环节3：分析行业目前的趋势（关键词：自我对标）**\n\n前面两个环节，都是专注于一个时间点由小及大地进行分析，接下去的两个环节，则需要加入时间维度，由点及面地进行分析\n\n第3环节其实非常简单，是一个启发环节，为第4环节做铺垫\n\n**这一环节主要做的就是自我对标，自己和自己比，总结来看是以下3个问题**\n\n> *问题1：这个行业目前和过去3-5年比，怎么样了？*  \n> *问题2：行业是增长了还是下滑了？*  \n> *问题3：导致这一现象的原因是什么？*\n\n举个例子，2009年钢铁价格史无前例的高，基本达到5000元/吨，而到了2015年，钢铁价格只有之前的三分之一都不到行业下滑了\n\n原因是2008年大搞基建，钢铁需求空前绝后的高，但之后由于“[凯恩斯主义](https://www.zhihu.com/search?q=%E5%87%AF%E6%81%A9%E6%96%AF%E4%B8%BB%E4%B9%89&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)”的后遗症，导致产能过剩严重，钢铁价格只能一降再降\n\n**自我短时间段的对标分析，会让你发现除去上一阶段最后提到的从自身角度去思考的内外部分析外，事实上还会有其他的因素来影响行业**\n\n这环节的分析则需要更多地参考专业机构的报告以及经济学家的观点了，收集数据并对数据做一些处理分析\n\n**环节4：分析整个行业的周期（关键词：发展&amp;波动）**\n\n为了弄明白第三环节的问题，我们需要再拉大维度来看这个问题，你需要弄清楚以下3个问题\n\n> *问题1：这个行业究竟是靠什么来驱动发展的？（这涉及到行业未来的发展趋势）*  \n> *问题2：是否会受到经济周期或政策的影响？（这涉及到发展时会被经济和政策影响的程度）*  \n> *问题3：目前处于生命周期的哪个阶段（了解目前所处的发展阶段）*\n\n**行业靠什么来驱动发展，可以分为两类，技术驱动与马斯洛需求驱动。**\n\n> *技术驱动：即核心竞争力是靠自己的技术，例如医药、高新科技、人工智能等*  \n> *马斯洛需求驱动：即核心竞争力是为了满足人们那5层需求的，例如现在大家更加追求精神层面的需求，因此很多满足人们精神世界满足的产品未来会发展的更快*\n\n而从经济周期的角度来看，行业可以分为经济周期性行业和非经济周期性行业。\n\n> *经济周期性行业：通常不是生活必须的，例如汽车、钢铁、旅游业等等*  \n> *非经济周期性行业：通常是必需品，例如水电煤等行业*\n\n除了会受经济周期的影响，还会受到政策的影响，例如近期的电子烟以及线上教育\n\n以上这些都是会打断趋势发展的因素\n\n当然，政策和经济周期是最为常见，也是通常必须考虑的发展波动因素，但依旧还有其他的因素，例如环境因素等等\n\n**但一事一议，你需要做的是根据你在前两个环节研究得到的关于行业的特点来进行针对性的思考，而非什么行业都来把所有的外部因素都研究一遍**\n\n好了，终于到最后一步，分析目前处于生命周期的什么阶段，即导入期、成长期、[成熟期](https://www.zhihu.com/search?q=%E6%88%90%E7%86%9F%E6%9C%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)、衰退期，这一步相对来说也是最简单的一步了\n\n这环节在分析时需要更多地参考创投行业的报告，还要对经济周期的波动历史有一定了解并在这一过程中补充自己欠缺的经济学知识\n\n通过以上4个环节的分析，对于一个行业的分析基本上来说是算入门了\n\n**当然以上每个环节所列举的问题仅仅是核心问题，以启发为主，更重要的是顺着这个思路分别站在业内人士和外部人士的角度去问自己更多的问题来帮助自己完善对于行业的理解**\n\n---\n\n那前面提到的这些信息我去哪里获取呢？\n\n**这里我和大家分享一下咨询公司一般获取数据和信息的途径，通常对于咨询公司来说，一般分为一手研究信息和二手研究信息**\n\n**一手研究通常会采用以下几种方式：**\n\n> *方式1：问卷*  \n> *方式2：专家访谈*  \n> *方式3：Cold Call*  \n> *方式4：Focus Group*  \n> *方式5：实地走访*  \n> *方式6：网站数据爬虫*\n\n二手研究通常就是在公开渠道的各种网站来获取信息了\n\n关于这一块，我为了方便以后自己在做案头研究的时候找资料，我花了一整天的时间梳理了自己常用的网站\n\n用Excel做了一个小工具，把所有靠谱的渠道搜集起来然后做一个dashboard方便使用，我根据自己的使用习惯，将自己要找的信息分为了三类，分别是找数据、找报告以及找资讯\n\n![]()\n\n例如在专业机构报告下，有查询投行/券商行研报告、咨询公司报告以及其他机构及文献的网站\n\n![](https://pic1.zhimg.com/50/v2-578786144898dd92ae76c14aebc12a1b_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n为了方便自己找各类细分行业的报告，我还设立了细分行业报告子类，方便自己查询各个细分行业的资料，**细分行业包括TMT、汽车与出行、零售及消费品、教育、工业等14大行业**\n\n![](https://pic3.zhimg.com/50/v2-8a96b781bce0c00b93aa51edff35e738_720w.jpg?source=1940ef5c)\n\nGIF_点击可查看大图\n\n**当然，这个工具肯定是在没法使用Bloomberg、Wind、Capital IQ等付费数据库或无法在这些数据库上找到自己想要的信息的时候使用的**\n\n如果你或你的公司有这些靠谱的付费数据库，那肯定还是优先使用数据库查询\n\n**但一般来说，二手研究的数据信息会被做一些处理和加工，一手数据的质量通常还是会比二手研究的高不少**\n\n尤其是专家访谈，当然前提是专家靠谱且愿意说\n\n商业的东西其实真的很简单，有时候告诉你，你就是知道，不告诉你你就是不知道\n\n**而这些信息就是高质量信息，懂得人几句话就给你讲透了，这样的信息通常只掌握在少数的大佬手里，而一旦有了这些信息，你对行业就会有更深刻的理解**\n\n**这也就是通常所说的混圈子，随着你的级别与能力越来越高，高质量的信息获取就会更简单**\n\n最后，说实话即便像[咨询公司](https://www.zhihu.com/search?q=%E5%92%A8%E8%AF%A2%E5%85%AC%E5%8F%B8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D)那样一整个团队做到了以上所有的这些，也不能说自己摸清了这个行业\n\n只能说帮助你尽可能地了解一个行业，毕竟这世上不可能存在任何人能100%摸清一个行业\n\n**作为一个非行业内人士，能做到以上这些已经尽全力了，接下去再提升对某个行业的认知只能靠时间积淀来提升自己了**\n\n注：关于如何查报告的内容引用自本人文章《[一个工具搞定行业研究](https://www.zhihu.com/search?q=%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E6%90%9E%E5%AE%9A%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1819818502%7D) | 实用工具.03》，欢迎移步搜索\n",
                    "title": "短的时间里了解并分析一个行业"
                  },
                  {
                    "path": "效率工具/怎么跳到 typescript 的源码.md",
                    "content": "#docs/how-to-guides #ts \n \n\n使用 ctag\n\nhttps://github.com/universal-ctags/ctags/blob/master/docs/osx.rst\n\n不是很好用。 与 vim 不搭\n\n‍\n",
                    "title": "怎么跳到 typescript 的源码"
                  },
                  {
                    "path": "效率工具/通过脚本控制 photoshop.md",
                    "content": "#ps  #docs/how-to-guides  \n\nphotoshop-generator 可以通过脚本控制 ps 。\n\n\n\n步骤：\n\n1. ps 开启与脚本的通信\n2. 准备脚本环境\n3. 运行\n4. 将脚本集成到 ps\n\n   \n\n\n\n## ps 开启与脚本的通信\n\n![image-20190823132618534](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/image-20190823132618534.png)\n\n\n\n## 准备脚本环境\n\ngit clone https://github.com/adobe-photoshop/generator-core.git\n\n``` bash\nyarn \n\n```\n\n\n",
                    "title": "通过脚本控制 photoshop"
                  },
                  {
                    "path": "架构图.md",
                    "content": "#docs/how-to-guides \n## 图 SED 标准\n\nSED\n\n-   谁负责来画\n    \n\n-   Source\n    \n\n-   组成元素\n    \n\n-   Element\n    \n\n-   给谁看，想达成什么目标，维度平面是什么\n    \n\n-   Dest\n    \n\n## 图类型\n\n-   **结构图**：\n    \n\n-   架构图： 强调结构与单层展现维度\n    \n\n-   **顺序图**：\n    \n\n-   流程图 强调业务 process 的连接\n    \n-   时序图 强调技术 process 的顺序\n    \n-   状态图 强调 process 的结果\n    \n\n## 架构图\n\n### 业务架构\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1663913776883-d468be94-755b-4466-bde6-9c657897fd7c.png)\n\n-   S：产品\n    \n\n-   E: 业务系统 > 业务组件 > 功能点\n    \n-   D:\n    \n\n-   架构师。 了解有哪些业务模块需要技术支撑\n    \n-   客户。 了解技术与业务的映射关系\n    \n-   开发。了解业务上技术层面如何衔接\n    \n\n### 服务架构 / 应用架构\n\n## ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1663913871222-b8fbaaa0-b4be-4174-a9df-a39ebee09137.png)\n\n-   S：架构师\n    \n\n-   E：层，库，接口\n    \n\n-   D: 开发人员。\n    \n\n-   指导单体项目的创建与开发。描述一个服务内基本组织结构。对接系统\n    \n\n### 系统架构\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1663914028267-f8a289f8-83e9-4c41-9d3b-19b059c97674.png)\n\n-   系统架构\n    \n\n-   S: 架构师\n    \n-   E: 端，服务，中间件，基础设施\n    \n-   D：\n    \n\n-   开发人员\n    \n\n-   了解各单体子系统点如何协作构成整体服务。\n    \n\n-   架构师\n    \n\n-   解决业务规模与系统匹配问题\n    \n\n-   负载\n    \n-   注册发现\n    \n-   消息路由\n    \n-   缓存\n    \n-   数据库\n    \n-   ...\n    \n\n### 运维架构\n\n#### 软件\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1663914166456-7b5895e1-f68c-4379-9b03-51d948bc9f07.png)\n\n-   S：架构师，运维\n    \n\n-   E: 运维服务，中间件\n    \n\n-   D：运维\n    \n\n-   自动部署\n    \n-   如何做到高可用\n    \n-   日志收集\n    \n-   ..\n    \n\n#### 硬件拓扑\n\n### ![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1663914133644-c6d17002-58ec-43f6-b637-9b21476f87d3.png)\n\n-   S：架构师，运维\n    \n\n-   E：硬件，运维软件，运维基础设施\n    \n\n-   D\n    \n\n-   运维\n    \n\n-   支撑扩容需求\n    \n-   硬件监控与报警\n    \n-   如何支撑容灾\n    \n-   ..\n    \n\n-   甲方\n    \n\n-   了解硬件成本\n    \n\n## 顺序图\n\n### 流程图\n\n数仓系统，基于数据流不同 zooming 的流程图\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1665206640327-c64cab9a-d51c-47ad-a06b-5fd6df4d9aa4.png)\n\n![img](https://md4zk.oss-cn-beijing.aliyuncs.com/uPic/1665206680201-bcb6899c-454f-4196-b8af-805480333d90.png)",
                    "title": "架构图"
                  },
                  {
                    "path": "汇报工作.md",
                    "content": "#docs/how-to-guides \n1. 为人忠谋。向谁汇报就替谁操心。\n2. 有限务虚。主要说实，夹杂务虚。\n3. 外行友好，把专业讲的对方明白。不说别人听不懂的词，不细节细节。\n4. 信息碾压，行业情况，同业什么情况，核心指标是什么。功课做足。\n\n> 高手绝招：等着对方问问题，3 个答案不要一次性给到，问一次答一次。显得深不可测。\n神龙见首不见尾。不要一次把料放完。\n\n## 汇报对象\n参考 [[1.方法论/STAR 结构|STAR]]\n向老板汇报：老板最想听 结果  行动  经验\n向同事分享：他们最想听  行动  经验\n向客户宣讲 ：他们最想听    结果  背景\n",
                    "title": "汇报工作"
                  },
                  {
                    "path": "疫情下的人权/疫情防控层层加码，可按照下面的方法举报.md",
                    "content": "\n#docs/how-to-guides \n\n11/24/2022\n\n\n\n如果你的城市还在层层加码防疫，乱管控乱防疫，那请仔细看好举报他们的办法：\n\n首先就是电话举报，直接打到北京去的电话，打到国家卫健委管理部门。010-68792256，010-68791370等。见图一。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/0b470e41.jpeg)\n\n图一\n\n具体违规没有，可以参照11月11日国务院发布的疫情防控20条新措施。图二是精简版，详细版头条里搜索。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/16d7db38.jpeg)\n\n图二\n\n如果电话打不进去，可能是举报者太多，那就在微信小程序里举报。\n\n打开微信，搜索国务院客户端，发现该小程序后点进去。如图三。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/8d1edc19.jpeg)\n\n图三\n\n然后点该小程序，在国务院客户端里最上端搜索栏里搜索，疫情防控服务专区。如图四。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/98c17999.jpeg)\n\n图四\n\n然后搜出来以后，是这样的画面。如图五。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/26885946.jpeg)\n\n图五\n\n在图五里，点疫情防控线索征集，就是绿色笔圈起来那里。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/824d03e0.jpeg)\n\n图六\n\n然后出来图六这样的画面，在最下方，红色圈起来的，我要留言那里，点进去，如图七\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/1c6eb505.jpeg)\n\n图七\n\n图七中选择人民群众反映问题通道。进入后有个声明书，需要在小框里面读完拉到底，然后点✓，点确定。就进去可以举报了。如图八。\n\n![image](https://keep.cdt.media/assets/images/d/a/da7e78a2/2e320583.jpeg)\n\n图八\n\n当然，最快的方式，还是电话举报。因为说话会更清楚有效的表达自己的事情。写字描述比较难，也慢。\n\n我再补充一点，举报后，两三天会有北京回访电话，问你处理好了没有。国家对他们乱作为还是很严肃处理的。也会保密你的个人信息不被泄露。\n\n权力越小的人，越是拿这小小的权力压死人。\n\n国家拍的就是苍蝇。\n\n",
                    "title": "疫情防控层层加码，可按照下面的方法举报"
                  },
                  {
                    "path": "看国外的 tictok.md",
                    "content": "#docs/how-to-guides   #GFW \n直接网页看即可\n [HALLOWEEN🎃家庭教師 | TikTok](https://www.tiktok.com/@katekyo_nene/video/7159537917864529154?_r=1&_t=8WslESTK557&is_from_webapp=v1&item_id=7159537917864529154)",
                    "title": "看国外的 tictok"
                  },
                  {
                    "path": "看谁先数到 21.md",
                    "content": "#docs/how-to-guides  #pua\n\n\n一个外国小伙在伦敦地铁搭讪妹子，和妹子玩谁先数到21谁就输的游戏，从1开始可以数1-3个数字，数到21的那个判输，妹子输了要答应kiss，小伙先后和两个妹子玩都轻松赢了。当时沉迷于情感大戏没有多想。直到有天和一位长发飘逸的数学系朋友玩起这个，玩完第二轮他都让我先数，之后我就没赢。看着他眼镜后面深邃而狡黠的眼睛，仔细一想，同样是九年义务教育，别人凭实力撩妹，我们单身是凭实力啊。  \n然后再看那个视频，小伙都是后发制人，而且每次若无其事数到4的倍数。\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220301233026-aeb17al.png)![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220301233035-hhwdls2.png)\n\n![image.png](https://md4zk.oss-cn-beijing.aliyuncs.com/img/image-20220301233103-k4xhbry.png)\n",
                    "title": "看谁先数到 21"
                  },
                  {
                    "path": "简历怎么写.md",
                    "content": "\n#docs/how-to-guides  #resume \n\n\n\n\n# 01. 简历是什么\n\n我们在 [上一篇文章](https://www.wmyskxz.com/2020/09/08/offer-yi-luo-kuang-qiu-zhi-zhi-qian-ni-bi-xu-zhi-dao-de-4-jian-shi/) 有过 **「简历是一份工作成果」** 的总结，确实，从某种意义上来说它就是你为 **新公司** 所做的 **第一件** 工作成果 *（成功推销自己）*。\n\n从更广泛的意义上来说，简历不仅仅是你叩开企业大门的 **敲门砖**，也是你 **职业生涯** 和 **个人** 的一个 **精要总结**。\n\n## 为什么需要简历\n\n今天的简历已经是招聘过程中 **不可或缺** 的一部分。\n\n它的 [起源](https://www.davron.net/history-of-the-resume/) 可以追溯到达芬奇和中世纪的熟练技术工人和工匠协会。因为 **有经验的专业人士** 总是需要一种方法来 **突显他们的能力**。\n\n![500 年前达芬奇求职信原件](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/v2-5e680856729ab0935d8290e45a94adad_1440w.png)\n\n随着纸张的发明，为个人的技能和能力做广告就变得更加容易。而如今的互联网上，只需要动动鼠标就能够提交一份简历。\n\n纵观历史，人们一直在寻找 **获得就业** 的途径。尽管经历了很大的变化，但简历已经成为了企业的 **第一要求**，没有简历，您甚至都无法开始竞争。\n\n## 简历的目的是什么\n\n大多数人认为，一份好的简历能让他们获得一份工作，**这是错误的**。\n\n在当今的市场中，很少有 **仅仅** 根据简历的内容就让公司雇佣你的情况，在真正雇佣你之前，公司都会对你这个人进行实际的考察  *（面试）*，他们希望证实您的简历的真实性并查看你是否具有他们所寻找的个性。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914003815430.png)\n\n所以，事实上，**是面试最终帮你找到了工作**，而 **简历** 的作用某种意义上则是通过层层筛选 **获取面试的机会** *（这就需要您很好地标准化地展示自己的经验和能力）*。\n\n*（注意👆说的「筛选」不仅仅是 HR，也可能是 [机器](https://www.jiqizhixin.com/articles/2020-08-10-8)——特别是招聘网站上，招聘人员可以根据关键词进行筛选）*\n\n# 02. 企业如何筛选简历\n\n上面👆说到简历的作用其实是帮助我们 **获取面试的机会**。\n\n那么什么样的简历有机会入选呢？不如我们直接从 **HR 的角度** 来学习一下，如何从每天大量的简历中找到适合岗位的候选人吧。\n\n## 基础了解\n\n**筛选简历的目的是，确定求职者与公司招聘职位的匹配程度**。记住，这里指的是 **匹配程度**，而不是选出最优秀的人才。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914003747917.png)\n\n这里的「匹配」不仅仅体现在工作能力上，**更多** 地体现在个人性格、三观、工作稳定性、职业追求和人生愿景上。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/v2-dc0f2e57f7f31cd437ea63a11daf6aba_1440w.png)\n\n### 充分认识和了解招聘岗位的职责、任职资格\n\n受时间和方法的限制，HR 一般只通过简历对候选人的 **任职资格** 做初步推断。\n\n基本上也就是对候选人的知识、经验、技能做一个最初步的总结要求。但在真正执行筛选这一步之前，需要先了解清楚岗位的职责、任职资格。\n\n认识和了解岗位的方式有三种。\n\n**一是岗位说明书**。公司的每个岗位都有明确的岗位说明书，主要包含两个部分：①职位描述 *（职位设置的目的、基本职责、组织结构图、业绩标准、工作权限等）*；②职位的任职资格要求 *（工作标准、胜任职位所需的知识、技能、能力、个性特征等）*；\n\n**二是用人部门负责人**。用人部门负责人是对招聘岗位最了解的人，他们清楚地知道招聘岗位需要什么类型的人才。\n\n**三是同岗位的工作人员**。同岗位的工作人员也是对工作流程和工作任务比较熟悉的人，招聘官可以通过这些工作人员，大致的了解他们这个岗位需要的技能、能力、知识等。\n\n以上三种方法最好相结合，这样才能更加全面、深入地了解岗位，进而能够深入了解用人部门对人才的需求。\n\n招聘官需要注意的是，认识和了解岗位的重点是 **明确岗位的任职要求**，如学历、年龄、专业等。这些任职的 **硬性要求**，也是筛选简历的关键。\n\n### 明确什么是合格的简历\n\n一份合格的简历，里面的 **信息一定是完整的**。\n\n一般情况下，简历的基本信息应该包含个人信息、教育背景、工作经历、求职意向、获奖情况、项目经历等。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914004532256.png)\n\n简历信息的完整性，能够体现一个人的 **求职态度**。试想一下，如果一个人连简历都不认真做，他会认真对待工作吗？显然不会。\n\n### 什么是不合格的简历\n\n有时候 HR 在招聘工作中可能会遇到这样的情形：\n\n> 遇到一个求职者，从学历、履历、经验各方面来看，都非常符合公司的用人标准。但是用人部门看不上，认为不合适。\n>\n> 更让你不能理解的是，求职者来公司面试了，双方交流得也非常愉快，求职者也有意向加入公司，但是用人部门的最终决定是不予录用，理由是：不适合公司目前的发展需求。\n\n这里的要点是：**不要忽略求职者的需求。**\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914003717156.png)\n\n招聘本身就是一个 **双向选择** 的过程，你在选择人才的时候，人才也在考察和选择着你。只有同时满足双方的需求，企业才有可能招到合适的人才。\n\n因此，在筛选简历的时候，招聘官不仅仅需要关注 **企业的需求**，更要根据求职者过往工作平台、薪资、履历、期望等挖掘 **求职者的潜在需求**。\n\n如果 **双方需求** 能够匹配，就可以通知匹配。否则，即使再优秀，也要果断放弃。\n\n## 筛选简历的技巧\n\n### 硬性指标不达标，Pass！\n\n许多岗位在设立之初就会专业能力的要求。\n\n比如程序员，一般要求有更高的学历或对口的专业，或者要有相关的从业经验；行政类、财务类工作多选择女生；有些企业，则只招本科及以上学历的求职者。\n\n对于求职者的性别、学历、专业、工作经验、工作时间等基本信息，**不符合硬性指标的简历就可以直接淘汰掉。**\n\n### 学会识别简历中的虚假信息\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914004918185.png)\n\n简历中常见的虚假信息有以下 4 种。\n\n**第一种，工作时间衔接前后矛盾**。例如，同一时间在两个企业工作，或者在校上学期间在一家企业全职。这就明显是求职者“作假”不用心了。\n\n**第二种，夸大公司规模**。明明只有十几个人的小公司却要夸大成几千人的大公司，以提高自己的含金量。要快速识别这种虚假信息，招聘官就要多收集信息，关注相关行业内中大型规模的企业。\n\n**第三种，不符合正常逻辑**。如果一个求职者在工作履历中写的是曾经任职主管、经理，而现在的任职意向却是一名行政，那么这种信息很大可能是虚假信息。\n\n**第四种，全能冠军**。比如明明只在一家企业担任过行政，对自己的能力描述却是各方面能力都具备。这种“全能冠军”的简历，一定是虚假的。\n\n### 一定认真查看模糊字眼\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914005003068.png)\n\n大部分企业在筛选简历的时候，对候选人的工作经历、工作表现以及学历的真实性尤为重视。\n\n而恰恰在这几个方面，求职者会用 **模糊的字眼描述**。\n\n他们之所以这么做，无非是想提高自己的含金量，让自己的简历能够顺利通过。但是这种不诚信的行为，是不值得提倡的，企业也绝不会允许这种不诚信的人加入。\n\n因此，招聘官在筛选简历的时候，一定要认真看那些模糊的字眼。\n\n**第一种，“工作经历”中的模糊字眼。**\n\n最常见的是工作的起止时间与实际不符。比如，求职者是 `2019` 年 `7` 月毕业，但实际参加工作是 `2019` 年 `12` 月，而建立中写的确是从 `7` 月开始工作，这无形增加了 `5` 个月的工作经历。\n\n或者是把时间较短的工作经历拼凑在一起。这样就看不出来一年换了三家公司的真实情况。\n\n面试官在看到此类信息时，一定要认真审查：\n\n1. 在原来公司工作的时间要明确，一定要精确到月份而不是年；\n2. 原来的公司要有全称；\n3. 在原来公司担任的职位以及职位描述；\n\n**第二种，“学历”中的模糊字眼。**\n\n比如，简历上写的毕业时间是 `2019` 年 `7` 月份，但是大学教育背景的起止时间是 `2017` 年 `9` 月— `2019` 年 `7` 月。按照一般本科来说，全日制本科要读 `4` 年。\n\n**第三种，“工作表现”中的模糊字眼。**\n\n很多求职者在填写这一栏的时候，会写“表现非常出色”“为企业做出了很大贡献”等。\n\n虽然这些主观信息不存在真假，但是这种盲目自夸、虚夸的信息从侧面反映出求职者有点自视甚高。\n\n一般情况下，认真、诚信的求职者写“工作表现”的时候会尽量量化自己的表现，比如获得了多少次奖励、得到了多少证书等。\n\n### 审查求职者的稳定性\n\n**跳槽职位的连贯性，远比名校背景更重要。**\n\n为了追求更好的发展，频繁跳槽对一些职场人士来说是司空见惯的事情。但是，招聘官一定要对跳槽职位的连续性重点关注，因为这对筛选简历而言，远比名校背景更重要。\n\n**学历代表的是过去，而职位的连贯性代表的是未来。**\n\n例如，求职者在上一家公司担任的职位是运营部经理，跳槽之后到下一家公司是高级经理或运营总监，那说明跳槽职位连贯性比较高，这类求职者在该领域的专业技能和知识都有保证；\n\n如果求职者在上一家公司担任的职位是运营部经理，跳槽到下一家公司的职位是销售，再跳槽到下一家公司的职位是财务，那说明跳槽职位的连贯性比较低，这类员工看上去拥有很多技能，但是每一个技能都不精通，而且对工作没有耐心。\n\n一般情况下，猎头顾问就会直接剔除这类简历。\n\n另外一方面，如果求职者的工作经验是 **横跨** 几个行业的，证明求职者对未来缺乏明确的工作规划和职业发展规划。\n\n### 拒绝一切花里胡哨\n\n有一些所谓的经典简历模板真的是堪称「经典」：\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913234008719.png)\n\n也有一些堪称「魔幻」：\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913234055095.png)\n\n简历应该是 **重点突出、内容清晰** 的 **有效信息**，而不是影响心情的「视觉噪音」或者「视觉垃圾」。\n\n# 03. 如何写一份高质量的简历\n\n一份高质量的简历本质上还是自己突出的 **核心竞争力**。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914003650355.png)\n\n在了解了企业是如何筛选简历之后，我们来学习一下如何针对性地撰写一份高质量的简历。\n\n## 第一步：两个重要的问题\n\n在我们开始撰写我们的简历之前，我们需要细致地梳理工作要求，并且询问自己两个重要的问题：\n\n### 1 我能胜任这个工作吗？\n\n有抱负当然是好事情，但是申请一个自己 **高不可攀** 的工作只会让自己失望。因此，**诚实地面对自己的技能和资质** 很重要。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914005214755.png)\n\n如果你符合其中 `3/4` 左右的工作要求，那么这份工作还是很值得 **尝试** 一下的。\n\n但如果目标公司寻找的是远高于自身条件的员工的话，你还是最好把眼光放低一点儿。\n\n### 2 这家公司到底在寻找什么样的人才？\n\n比如，我们在前程无忧上看到一条招聘信息，招新媒体运营主管，地点在上海。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200912174732703.png)\n\n我们先把 JD *（Job Description，职位描述）* 中反复出现的词语圈出来。\n\n发现 “策划/运营” 和 “数据分析” 是重要能力，而全篇里提到的软件技能只有 “H5”，说明这是关键技能。\n\n那么，如果你工作经验有优势，就用它证明你的策划和运营能力；如果你技能上有优势，就说清楚你的 H5 和数据分析是个什么水平。\n\n**重点是记下他们正在寻找的技能和资质**，这样你就可以确保自己的简历符合那些要求。\n\n## 第二步：基础信息\n\n尽管写简历并没有所谓的 “标准” 公式，但是阅读简历的人一定希望从你的简历中得到关于你的某些 **特定信息**。因此，你的简历 **至少** 得包含以下的内容：\n\n- 联系方式；\n- 工作经验；\n- 教育背景；\n- 工作之外的其他相关成就 *（如果你觉得自己的经历还不够丰富）*；\n- 关键词以及技能列表；\n\n### 联系方式\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913092023388.png)\n\n姓名、电话号码和电子邮箱地址是简历的最基本内容 *（通常也会放在最醒目的位置——简历开头）*，不然 HR 想要找到你可太难了。\n\n当然，你也可以增加一些链接到其他专业的社交媒体，比如个人博客、领英等。\n\n⚠️ 但是注意 **不要** 把 **当前的工作电话** 写进联系电话栏中。\n\n关于照片要不要贴，建议是：形象优秀的可以贴。*（互联网行业没有严格的要求）*\n\n关于简历上有没有照片的区别大吗这个问题，答案一定是肯定的。\n\nHR 每天要查看成百上千份简历，成百上千，密密麻麻的都是字啊！如果这个时候出现了一份带照片的简历，恰好来人面容清秀干净正直，多么让人眼前一亮感激涕零啊。\n\n如果一定要贴照片，最好是 PS 过的证件照。但也请一定避免以下的“自杀式”照片：\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913235903198.png)\n\n- 图片来源：「知乎问答」简历里有照片好还是没有好？ | @前程无忧51job招聘小助手 *（下方有链接）*\n\n### 工作经验\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913093346850.png)\n\n过去的工作及你能很好地预示你在今后工作中的表现，所以工作经历应该是占简历篇幅最大的部分，除非你没有相关的工作经历。\n\n这通常应该以 **倒叙** 排列，将最近的经历放在第一位。\n\n如果是刚毕业的应届生，没有工作经历，也可以把在校的项目经历写上。\n\n另外工作经历应该凸显的是在职的职责以及给公司带来了什么效益，**不需要详细写技术栈和项目细节**，例如：\n\n> 1. 作为组长负责设计和开发 **分布式网络爬虫系统**，优化爬虫策略和防屏蔽规则，提升网页抓取的效率和质量。\n> 2. 根据行业需求分析设计方案可行性，对项目代码进行测试优化，**协助持续集成与自动化部署**，提高系统可用性。\n> 3. 负责 EngineGo 爬虫系统技术文档的编写以及维护，定期 review 团队的代码，定期组织团队技术分享。\n\n另外也请 **避免无意义的描述**，这一点是说：适用于所有人的信息无用，以及量化的信息更具有价值。\n\n![一个例子](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913102044491.png)\n\n在 Github 的 [awesome-resume](https://github.com/resumejob/awesome-resume) 项目中，也有一些在写 **简介/工作经历/项目经验** 时常用的一些例句，大家可以拿来参考：（项目地址：https://github.com/resumejob/awesome-resume）\n\n1. 有良好的代码风格，通过添加注释提高代码可读性，注重代码质量，研读多个开源项目，学习改善代码的健壮性与扩展性。\n2. 有良好的代码编写习惯，具有良好的沟通、协作能力能力，有良好的职业道德和较强的工作责任感。\n3. 理解操作系统中 **进程、线程、死锁、虚拟化、文件系统** 等原理和简单实现。\n4. 有 **大型互联网分布式系统** 的架构设计和开发经验，拥抱新技术，有很强的学习能力。\n5. 有扎实的计算机理论基础，**良好的算法与数据结构基础**，了解计算机基本原理与常见机制。 \n6. .......\n\n> 工作经验写作 Tips：\n>\n> **1、简历并不是你的记录档案**。除了注意不要把原先工作的电话号码、地址或者任何联系方式写进简历外，任何对你能力体现无用的你都可以略去（如果面试官想知道你离职的原因，她自然会开口问）。\n>\n> **2、开源项目为职业生涯灌注力量**。着手一个开源软件（OSS）项目，无论这个项目是你自主开发的还是原本已有的，对你来说都是一份实实在在的工作经验。这既能显示你有编写代码的能力，又表明你能很好地和团队合作、与他人相处。而且，这些工作经历是雇主可以找到和验证的。\n>\n> **3、列出不同阶段的职位凸显进阶**。\n>\n> **4、把重点放在陈述的事实上，而不是花哨的词汇上**。有时候确实使用一些漂亮的主动动词会起到一定效果，但能在内容上多下功夫更为重要，更细致更丰满的描述才能更加打动人。*（比如：「在 `6` 个月之内使网站流量增加 `50%`」——同时列举你为此采取的行动）*\n>\n> **5、可量化的信息更有说服力**。例如 *「将每日网站流量增加 `10000` 次」* 并不能让读者形成一个明确的概念，而 *「将网站流量增加 `40%`」* 就做到了。此外，还应该将时间跨度也说明清楚。*「将网站流量增加 `40%`」* 并没有说明这个变化是花了多少时间做到的，加上一个时间跨度的说明就清楚多了。\n>\n> ![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914004053477.png)\n>\n> **6、强调对雇主的价值**。在为以前每个岗位添加要点条目时，需要强调你或独立完成或参与完成的工作成果，强调你为公司、为部门或者为了某个产品的提高作出了怎样的贡献。即使身处最普通的岗位，你也可能为公司的发展做了一些事。\n\n*（另外下方👇介绍的 STAR 法则也是优化简历的一把好手）*\n\n### 教育背景\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913103556360.png)\n\n教育背景的部分的基本内容就是要将你所完成的 **高等教育** 机构名称以及你所获得的学位分别列举出来 *（请注意我们说的是高等教育，意思就是高中就没必要写了）*。\n\n如果你是学霸，那么 **高绩点/高专业课分数/奖学金/比赛获奖** 这些都可以选重要的加上 *（例如 xxx竞赛一等奖、国家一等奖学金）*。\n\n跟 **岗位相关** 的事情也可以写上。比如你目标职位是 **平面设计师**，那么大学期间参加了 **XXX设计比赛**，没得奖都没关系，都可以写上，但是当过什么班干部之类跟岗位没什么关系的事情，意义就显得没那么大了。\n\n### 技能列表\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913112655864.png)\n\n一个典型的错误表现就是技能列表 **信息过多，缺乏重点** 的情况：\n\n![一个\"血淋淋\"的例子](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/v2-ecdd07214fc20b5faf78002f4668ccde_1440w.png)\n\n求职者希望尽可能多地展示自己的经验和能力，但结果却适得其反。*（大部分人阅读大段文字是跳读的，不信你看第 3 点和第 14 是一样的，不知道你有没有发现）*\n\n技能列表应该遵从 **简短清晰** 的原则，尽可能地让外行人也能快速定位技能。\n\n以下是比较推荐的排列方式：\n\n> - 后端框架：Spring/ SpringBoot/ Django/ Flask\n> - 前端框架：Vue/ React/ jQuery\n> - 数据库：Redis/ MySQL\n\n关于技能的 **熟练程度**，这确实是 **仁者见仁，智者见智** 的事情，首先很可能面试者不能正确评估自己的技能程度，其次 HR 对于程度词的理解不一样，所以也有建议说就 [不要写熟练程度](https://zhuanlan.zhihu.com/p/38431524) 了的建议，关于这一点我没有很好的建议。\n\n不过倒是很有必要地认识到，这一 Part 的作用有点类似于 **“关键词”**。\n\n*（特别提醒注意一下技能的拼写和完整程度，这有助于筛选简历时能够进入到搜索结果中）*\n\n### 其他成就\n\n比如你对开源社区作出过杰出贡献、拥有个人开源项目 *（能拿出手的）*、拥有个人博客等等，都可以作为加分项加入简历。\n\n## 第三步：修改简历\n\n现在你已经有一份基础的简历了，在把你的劳动成果发送出去等待招聘官审阅之前，你还要确保完成 **修改** 的步骤。\n\n### 避免粗心的错误\n\n通过前面的几个步骤，你已经完成了简历内容，还要修改一下你可能没注意的一些问题，像 **错别字、语法错误和格式错误** 等这些由于粗心造成的错误。\n\n不管你的成就多么令人印象深刻，如果你的简历充满了因粗心而造成的错误，你将很难说服任何一个招聘经理，并让他相信你在工作中不会这么粗心。\n\n另外 **拼写方面** 的细节也需要额外注意，iPhone 不要写成 IPone，macOS 不要写成 MacOS 之类的。\n\n### 确保简历读起来流畅\n\n下面👇是一些确保简历可读性的几种方法：\n\n**将简历缩短至一页**。以前我还蛮信奉“一页纸”简历的，但是看过一些简历之后，发现确实一页纸没办法满足所有人的需求，总之总体原则就是要精简。\n\n**要有页边距**。没有人愿意看满满一页都是字的简历，你需要给简历的内容保留一点“阅读空间感”*（每一段的内容同样适用）*。\n\n**不要在字体上玩儿创意**。使用常见的字体就可以了，可以用黑体字和斜体字标出关键信息，如公司或者岗位。但是不要太“过分”，当简历的阅读者弹出“无法找到xxx字体”时，可能情况就不那么酷了。\n\n**去掉口语化叙述**。一份优秀的个人简历，基本上都不会在文字中出现“我”，并且尽量都是，使用动词开篇的祈使句，例如：「使用 Scrapy 开发异步爬虫系统，构建 IP 代理池，优化爬虫策略和防屏蔽规则，提升 200% 网页抓取速度」。\n\n### 针对性的突出优势\n\n就像我们👆写简历之前问的「这家公司到底在寻找什么样的人才？」这个问题里面回答的，要根据招聘要求突出自己的优势和能力，尽可能的让自己与岗位 **匹配**。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914005432483.png)\n\n另外一点提醒是，求职者经常过分强调自己需要得到某一具体职位，但是招聘经理知道你想得到这个工作，他要招聘最适合这个岗位的人，而不是最需要这个工作的人。\n\n所以，你一定要 **强调自己的优势**，无须过多地解释你是多么热爱这个工作。\n\n## 优秀工具推荐\n\n### 在线写简历神器：超级简历\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913225419088.png)\n\n- 官方网址：https://www.wondercv.com/\n\n不仅仅拥有海量的 **简历模板**，并且还有自动一页纸（自动排版）、一键优化、引导示例等功能，结合我们👆提到的方法，非常轻松地就能够写出非常 **专业的简历**。\n\n### 简历优化神器：STAR 法则\n\n这应该是求职面试里，提及最多的一条规则了，甚至是面试官，在收集面试者与工作相关的具体信息和能力的时候，都离不开这个法则。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913231419934.png)简而言之，STAR 法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的逻辑模板。\n\n通过 STAR 法则，能够高效快速地让对方了解到，一件事情的来龙去脉，以及最终成果。\n\n![一个例子](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200913231745687.png)\n\n*（⚠️注意，STAR 能够保证大体方向不错，但也要活学活用，例如上图中写在简历中的可能就是最上面的一句话——不要让简历显得过分臃肿——但是展开了说可能就是下方 STAR 原则分析的内容）*\n\n# 04. 高质量简历 \"味道\"\n\n## 大神们的简历\n\n### 乔布斯\n\n乔布斯 `40` 年前的求职信在 `2018` 年的某拍卖行上，被拍出了 `17.4` 万美元的高价，不过这份简历似乎根本入不了当今的 HR 们的法眼：\n\n![HR 想打人系列](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914001006791.png)\n\n“Steve Jobs” 中的字母 “J” 没大写就算了，居然连应聘公司惠普的名字都写错了。\n\n最搞笑的是，日后把智能手机卖给全世界的乔布斯大神，在电话号码一栏写了 “无”。\n\n### 达·芬奇\n\n相比之下，达·芬奇在 `450` 年前写的简历就让他成功获得了米兰伯爵的垂青。\n\n达·芬奇是真心想要去米兰，所以对求职的认真度会 `100%` 体现在你的简历上，根本造不了假。\n\n**与乔布斯的 “随便写写” 相比，达·芬奇的态度是很直观的。**\n\n![500 年前达芬奇求职信原件](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/v2-5e680856729ab0935d8290e45a94adad_1440w.png)\n\n达·芬奇求职信来自于知乎答主 @warflcon 的翻译：\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914001432924.png)\n\n### 罗永浩\n\n无独有偶。近几年，锤子科技创始人罗永浩卖手机讲段子，几乎让人忘了 `2000` 年时，他还曾经是新东方学校的任课教师。\n\n当时罗永浩给北京新东方学校校长俞敏洪写了一封求职信，在两次试讲失败后，给了他第三次试讲的机会，终于成功。\n\n当时罗永浩写给俞敏洪的求职信也可圈可点：\n\n> 针对雇主的招聘需求，有的放矢；风趣跃然纸上，实力诠释“幽默感”；生动有个性，容易脱颖而出。\n\n![罗永浩求职信 via知乎答主@赵凯](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914001816413.png)\n\n### 从大神身上学到的经验\n\n**好的简历不是赢在字多，而是能够找准公司的需求，言简意赅地说明能力。**\n\n而简历的范本还可以追溯到战国时代，看看大诗人屈原是如何用文言文完爆职场的。\n\n![屈原求职信 via知乎答主@iYuanzh](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914001907560.png)\n\n能把简历写成楚辞，也算是一代风流名士。\n\n当然了，也不是所有大佬的简历都是正确的示范。\n\n## 一份优秀的简历\n\n一份优秀的简历看起来应该是这样的，**排版整洁，重点突出**：\n\n![来源超级简历的优秀简历](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200914002011111.png)\n\n脱颖而出靠的不是设计，不是颜色，也不是可视化图表，最能够打动 HR 和让他们眼前一亮的是，**干净有序的模块** 和 **扎实的描述**，每段经历都能看出来你确实做了很多事情，**有能力有价值**。\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/006APoFYly1g4pcf3yaw9g309g08zh9y.gif)\n\n# 总结\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/《Offer一箩筐》一份高质量撰写「简历」指南，望打扰！/image-20200908071823909.png)\n\n总的来说，你可以把简历当成一款产品来打磨，一切都是 **针对性** 地突出自己的优势，以此来获取面试机会以达到最终求职的目的。\n\n另外公司和求职者应该如同所有好的关系一样：**互相成就**。\n\n至少我们完成了建立这个友好战略合作关系的第一步：写一份高质量的简历。\n\n下一步我们将进一步揭开面试过程中的那些「套路」和「难啃」的面试问题，请关注 wmyskxz 公众号进一步关注《Offer一箩筐》的后续内容！另外 **公众号后台** 回复 **【简历模板】** *（不带`【】`）* 可以获取 **程序员专用简历模板** 哦！\n\n真诚地希望对大家有帮助！觉得有用的麻烦动动小手 **点赞/留言** 吧，创作不易，**切莫白嫖~**\n\n# 参考资料\n\n1. 《人人都有好工作：IT 行业求职面试必读》 - https://book.douban.com/subject/5998157/\n2. Why You Need a Resume - https://www.roguecc.edu/emp/Resources/resume.asp\n3. The World’s First Resume is 500-years Old and Still Can Teach You a Lesson or Two - https://business.linkedin.com/talent-solutions/blog/recruiting-humor-and-fun/2015/the-worlds-first-resume-is-500-years-old\n4. The History of the Resume - https://www.davron.net/history-of-the-resume/\n5. 《深度成长：有效调用你的每一分潜力》 - https://book.douban.com/subject/33393450/\n6. 「知乎问答」简历里有照片好还是没有好？ | @前程无忧51job招聘小助手 - https://www.zhihu.com/question/19761379\n7. 「知乎问答」HR 怎样筛选简历并安排面试比较高效 | @人事星球 - https://www.zhihu.com/question/26477466\n8. 「知乎问答」如何制作高水平简历 | @小红拖拉机 | @王释易 - https://www.zhihu.com/question/21187514/answer/137107187\n9. 程序员如何写一份更好的简历 - https://zhuanlan.zhihu.com/p/38431524\n10. 面试官到底想看什么样的简历？ - https://juejin.im/post/6844903879973273607\n11. 乔布斯的简历 17.4 万拍卖，HR 看了想打人.. - https://zhuanlan.zhihu.com/p/35865680\n\n> - 本文已收录至我的 Github 程序员成长系列 **【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava**\n> - **个人公众号** ：wmyskxz，**个人独立域名博客**：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！\n\n![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/qrcode.png)\n\nHi，这里是 **我没有三颗心脏**，一个兴趣爱好广泛的 **96** 年 **自由技术人**，在公众号 **wmyskxz** 分享 **「MoreThanCode」** 的 **知识/技术/成长/思考**，2020，与您在 **Be Better** 的路上共同成长！\n\n非常感谢各位人才能 **看到这里**，创作不易，文章有帮助可以点个 **「在看」** 或 **「分享」**，都是支持（**莫要白嫖**）！\n\nSomewhere not here，愿你我都能奔赴在各自想去的路上，我们下篇文章见！",
                    "title": "01. 简历是什么"
                  },
                  {
                    "path": "道德经在讲什么？.md",
                    "content": "\n#dao  #docs/whatis-why-explanation \n道德经是对[[易经]] 的另一翻表达",
                    "title": "道德经在讲什么？"
                  },
                  {
                    "path": "面试怎么答.md",
                    "content": " \n#interview  #docs/how-to-guides \nHi~ 这里是 **我没有三颗心脏**，一个兴趣爱好广泛的 **96** 年 **自由技术人**。\n\n都说九月十月是跳槽的高峰期 _（也有金九银十的说法）_，所以 **近期** 计划出一些 **面试求职** 相关的文章，这里是系列的第三篇「面试中的棘手问题」，硬核实力讲解 _(搭配可直接食用的例子)_ 如何回答面试中的那些难啃、套路的问题，也算是学习分享，真心的希望对大家有所帮助，如果 **觉得不错，请点赞/留言，莫要白嫖~**\n\n至此，关于求职面试相关问题已经解决了 **大方向** 的东西了，只剩下一些细枝末节的地方以及技术面试相关了，请继续关注 **wmyskxz**，后续会持续整理输出一些技术面试相关的内容~\n\n# [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#01-%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)01. 面试前的准备\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#1-%E5%87%86%E5%A4%87%E5%A5%BD%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D)1 准备好自我介绍\n\n提前准备自我介绍非常有必要，这几乎是每场面试的“开场白问题”。特别是受疫情影响的现在，在线面试更是绕不开这个问题。\n\n[![](https://camo.githubusercontent.com/24e146612117b7566cfdb9bb0ca237c4d7fea69da4e2a657432176670c97e422/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c7931667164693279766376676a3230366f30366f7438722e706e67)](https://camo.githubusercontent.com/24e146612117b7566cfdb9bb0ca237c4d7fea69da4e2a657432176670c97e422/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c7931667164693279766376676a3230366f30366f7438722e706e67)\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8F-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%89%E5%A4%A7%E9%9B%B7%E5%8C%BA)⚠️ 自我介绍三大雷区\n\n**1、介绍得又全又广，没有重点，就像在复述简历一样；**\n\n> ❌ **错误示例**：面试官好，我叫 XX，我是 1996 年出生，我在某某大学某某专业，我毕业之后从事过两份工作，第一份叫什么公司，我做什么样的职位，具体工作内容是什么什么样的，第二份又是什么样的，我的性格是什么，我的爱好是什么，以此类推。\n> \n> 📝 **点评**：听你背诵一遍简历没有任何意义，因为简历已经在面试人员的手上了。\n\n---\n\n**2、假、大、空，喊口号式自我介绍；**\n\n> ❌ **错误示例**：面试官好，我叫 XX，我是应届生，虽然我没有什么相关工作经验，但是我对于从事 Java 开发的工作非常感兴趣，我一定会努力工作的，请您给我一个机会。\n> \n> 📝 **点评**：HR 内心 OS（努力工作？那你为什么之前不努力做出一些东西呢？诸如此类...）\n\n---\n\n**3、与岗位毫无关联；**\n\n> 上面👆两种自我介绍都没有突出自己与所应聘岗位的 **匹配度**，这也是 HR 关注的一点。如果你能在自我介绍当中说出你与当前应聘岗位有什么样的 **匹配度**，那么 HR 就会眼前一亮✨。\n\n另外也要注意不要把自我介绍搞得像是 **生平介绍**，不要包含太多的细节，请确保在 `1`、`2` 分钟内能够说完。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D-4-%E6%8B%9B%E5%88%B6%E8%83%9C)❗️自我介绍 4 招制胜\n\n1.  简单介绍工作经验；\n2.  找到与岗位匹配优势；\n3.  应聘该岗位的理由；\n4.  应聘公司、行业的理由；_（可以删减）_\n\n---\n\n以下是一些演示，语言和内容都比较空泛、不太精炼，但 **重在思路**：\n\n> ✅ **简单示例：**\n> \n> 你好，我叫 XX，我是一位具有创新精神的软件工程师，拥有 `20` 年管理中小型公司开发过程各个方面的经验。我的上一份工作是在 XXX，负责 XXX。_（简单介绍工作经验）_\n> \n> 我们从市场调研阶段就开始设计吸引和留住客户的方案，我们 `2017` 年的木啊比偶是收入比 `2016` 年增长 `2%`，现在我们实现了 `3%` 的增长。_（找到与岗位匹配的优势）_\n> \n> 我很喜欢高级项目经理这个职位，因为我知道我有能力管理复杂的项目，我也愿意为贵公司做这项工作。_（应聘该岗位的理由）_\n\n> ✅ **完整示例：**（假设这是一个销售转岗互联网用户运营的童鞋）\n> \n> 你好，我叫 XX。我之前的工作做了三份销售的工作，都是在房地产做销售的，工作当中，我会涉及到市场的拓展、用户的沟通、促成交易，包括配合一些线上线下的活动。_（简单介绍工作经验）_\n> \n> 在之前的工作当中，因为我做市场拓展，所以我对房地产行业的竞品行业发展政策（之类的）都非常了解，我也会一些行业调研的方式和方法；同时因为我跟客户沟通，所以我对客户心理的把握、客户需求的了解；包括我还会做一些客户的调查，各种调查手段我也非常熟悉；因为有配合一些活动，所以我对活动这个方面也有一定经验。_（找到与岗位匹配的优势）_\n> \n> 其实我在活动策划、用户沟通、了解客户这种能力是比较强的，用户运营其实跟我之前的工作，有非常大的相关度，同时因为用户运营跟销售相比，我会觉得这个岗位的未来会更有发展前景一些，所以我其实现在算是一个转行的过程，但是我之前的能力并没有抛弃掉，还是有很大一个迁移度的，所以我选择这个岗位。_（应聘该岗位的理由）_\n> \n> 之前是做房地产行业的销售，贵公司所属的行业，也是房地产，所以我之前的经验和一些对客户的了解、对竞品的了解、对同行业务的了解，都是可以迁移过来的，同时房地产互联网，现在也是一个比较有发展的市场，所以我选择这个行业。_（选择该行业的理由）_\n> \n> 我入职之前，我对贵公司的产品、业务、公众号、社群等，都有很丰富的了解了，贵公司的价值观是什么样的，对客户的态度是什么样的，同时这个岗位他的工作内容很丰富，跟我之前的工作内容也高度契合，所以我相信，贵公司是一个特别能够让员工发展的，然后对客户负责人的价值观我也非常认同，同时这个岗位的工作内容也能够让我的能力有充分的发挥，相信也能为公司带来很高的价值。_（选择公司的理由）_\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B)总结一下\n\n1、不要太长，要有重点；\n\n2、不要喊口号，真正拿出你的技能和能力来；\n\n3、一定要去契合岗位；\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#2-%E5%87%86%E5%A4%87%E5%A5%BD%E6%97%B6%E9%97%B4)2 准备好时间\n\n请将面试当作生命中 **唯一重要** 的事情来对待，因为此时此刻，它就是唯一重要的。不要让自己在面试时还需要顾虑时间冲突，应该把时间都腾出来好让自己心无旁骛。\n\n[![](https://camo.githubusercontent.com/f3b915b92a3ac10f66fda9f9df920aac96fbe040bb59fb6c93b3ecfd6bc8fcb4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f393135306534653567793167396130626c6e6771376a3230356930326f6139752e706e67)](https://camo.githubusercontent.com/f3b915b92a3ac10f66fda9f9df920aac96fbe040bb59fb6c93b3ecfd6bc8fcb4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f393135306534653567793167396130626c6e6771376a3230356930326f6139752e706e67)\n\n这不仅仅是因为不断地看表是不礼貌的表现，更是为了让你能百分百 **集中精神** 应对面试。\n\n而且通常情况下，如果面试进行的时间较长，这是个好的征兆，因为这表示对方对你很感兴趣。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#3-%E6%98%8E%E7%A1%AE%E9%9D%A2%E8%AF%95%E7%9A%84%E7%9B%AE%E7%9A%84)3 明确面试的目的\n\n面试的首要任务很简单：**获得录用**，或是顺利进入下一个环节之后再获得录用。\n\n_（⚠️ 另外提个醒：请注意“获得录用”并不表示“弄清楚这份工作的一切细节”。参与面试目的并不在弄清自己能挣多少钱，福利怎么样，或是工位在哪儿。这些都是等到正式得到工作后才需要考虑的问题。）_\n\n的确，你可能不会当场得到这份工作，可一旦参与面试便要 **说服** 其他人你就是这份工作的 **最佳人选**。\n\n![68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3030354a344f55356c79316761747a72377172733767333037713037626b36652e676966](https://camo.githubusercontent.com/1d0dd4ffda220204a5fcea3f10e8e26e62947421bec81c3134e91bed6a51ef21/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3030354a344f55356c79316761747a72377172733767333037713037626b36652e676966)\n\n[](https://camo.githubusercontent.com/1d0dd4ffda220204a5fcea3f10e8e26e62947421bec81c3134e91bed6a51ef21/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3030354a344f55356c79316761747a72377172733767333037713037626b36652e676966)\n\n你希望自己的表现能给对方留下深刻的印象，好让他们在面试后几小时或几天后作出爽快的决定，给你这个工作机会。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#4-%E5%87%86%E5%A4%87%E5%A5%BD%E5%BF%83%E6%80%81)4 准备好心态\n\n➡️ 有很多人讨厌面试，觉得自己像是在一种 **接受审讯** 或者是 **被拷问** 的状态。你害怕犯错，害怕不知道如何提问或者因为打错了问题而丢失工作的机会。\n\n[![](https://camo.githubusercontent.com/356bbd0f146de2ad33eeae5a950e0bf379450106b762898e34d9152a247fe99d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303672335051426a773166617a787371376431706a333036343036346467332e706e67)](https://camo.githubusercontent.com/356bbd0f146de2ad33eeae5a950e0bf379450106b762898e34d9152a247fe99d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303672335051426a773166617a787371376431706a333036343036346467332e706e67)\n\n➡️ 还有一些人对面试 **漠然以对**，对他们来说那只不过是一个坐着礼貌地回答问题的地方，他们总是保持着 **随缘** 的态度。事情该怎么着就怎么着，所以根本没什么需要担心的，不是吗？\n\n[![](https://camo.githubusercontent.com/3d70350734dc81c86cf258a531466e1b1e164723a7f25543a04317b3e2584176/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3632353238646335677931666d67656677703777636a323072733072733467642e706e67)](https://camo.githubusercontent.com/3d70350734dc81c86cf258a531466e1b1e164723a7f25543a04317b3e2584176/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3632353238646335677931666d67656677703777636a323072733072733467642e706e67)\n\n上面👆两种态度都不对。\n\n请记住招聘人员是真心想招你 _（但是也要警惕想要骗取你身上某些资源的情况，据我了解，比如一些设计师就会有找工作被窃取创意的情况发生）_。她希望你就是那个能够帮助她解决问题的人，不然她也不会邀请你来参加这一次的面试。\n\n面试对招聘人员来说如同对你一样，会让人筋疲力尽。每一次面试都将占用她几小时的工作时间，而且招聘也是一个费钱的过程。没人会因为单纯觉得好玩而安排面试。\n\n**不管你心里怎么想，永远都要记住面试是一次与未来雇主的商务会面。**\n\n如同简历是面向新雇主的第一份工作成果一样，面试也是你与新雇主的第一次商务会面。\n\n这也是与你个人息息相关的，面试过程中你也在以应聘者的视角面试新雇主，了解那些对你来说最重要的信息。**面试的参与双方地位都是平等的。**\n\n另外面试是一个 **对话过程**。不管内心怎么想，你可不是被警察审讯的嫌疑犯，只是在单纯地一问一答。\n\n事实上，安静地坐在一边，只是老老实实地一问一答是导致面试失败的一大原因，因为这样你带给面试官的印象不是毫无己见就是胆怯得无法开口。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#5-%E6%8F%90%E5%89%8D%E5%87%BA%E9%97%A8)5 提前出门\n\n面试迟到会让你之前所有的准备都泡汤了。\n\n对于大多数面试官来说，迟到也就意味着应聘者没法跟上工作节奏。所以请保证自己能提前到达面试场地。\n\n[![](https://camo.githubusercontent.com/d3323a08c57010482dbfa99c833ad531714d3ad71f2258043284f6d4b8307227/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f37366230633865396c7931667777746361683537316a323037653035376a72632e706e67)](https://camo.githubusercontent.com/d3323a08c57010482dbfa99c833ad531714d3ad71f2258043284f6d4b8307227/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f37366230633865396c7931667777746361683537316a323037653035376a72632e706e67)\n\n在预估的花费时间之上再加 `20%` 至 `50%` 的 **缓冲时间**。如果旅途顺利，你可以带本书到停车场或是附近咖啡馆消磨多出的时间。当然，最好还是利用这段时间重温准备好的问题、查阅参考文件以及做好的备忘，让自己达到最充分的准备状态。\n\n# [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#02-%E5%87%86%E5%A4%87%E9%9D%A2%E5%AF%B9%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%A7)02. 准备面对棘手的问题吧~\n\n⚠️ _以下的这些问题大部分来自于《人人都有好工作：IT 行业求职面试必读》一书，另加上了自己整理的一些问题。_\n\n首先需要说明的是，下方的回答仅仅是提供一种思路参考，总体原则是 **突出自己的优势，贴合企业的要求**。\n\n[![](https://camo.githubusercontent.com/8ba537a14a69923103f8aa280ff3449e7ea5b8e49d1ac64cc5f3b15f765f5df3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f696d6167652d32303230303931363132333331363934302e706e67)](https://camo.githubusercontent.com/8ba537a14a69923103f8aa280ff3449e7ea5b8e49d1ac64cc5f3b15f765f5df3/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f696d6167652d32303230303931363132333331363934302e706e67)\n\n另外要 **真诚**，不要让人觉得像背书一样，最好的情况是能自己能录音听一听自己回答时的状态、语速有没有让人不适的地方。\n\n也要试着理解每一个 **问题背后隐藏的原因**。\n\n> 譬如招聘人员问你对于 Apache Tomcat 应用服务器的掌握情况，这并不表示他正在显摆《101个向求职者提问的热门技术词汇》的书籍中摘下的新词，这意味着他手头有一些与之相关的工作任务和问题需要你解决。\n> \n> 那么此时你除了如实回答问题之外，也许还可以问：“你们是在考虑改用 Tomcat 技术吗？”\n> \n> 如果公司不是做 Java 的，那么面试官的提问可能会有更多的原因。但关键依然是关于如何将你掌握的技术与他们需要解决的问题相结合的讨论。\n\n下面👇就一起来看看那些棘手的问题吧！\n\n[![](https://camo.githubusercontent.com/a82f9fb2a86f18902867d82a859002525d7f7e0d2f79f8d71a34313beb2710f0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303672335051426a773166633772766c676c61346a33306a6e306a6e6469312e706e67)](https://camo.githubusercontent.com/a82f9fb2a86f18902867d82a859002525d7f7e0d2f79f8d71a34313beb2710f0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303672335051426a773166633772766c676c61346a33306a6e306a6e6469312e706e67)\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%90%A7)1 谈谈你自己吧？\n\n这是一道经典的开放式问题，给你足够的空间 **阐述自己的优势**。\n\n![68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f366166383962633867773166387135306463667676673230337a303366676d712e676966](https://camo.githubusercontent.com/d1f8f47776acea47b592e9836c90a241273782eb055d9262a3b6a9f064f48aff/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f366166383962633867773166387135306463667676673230337a303366676d712e676966)\n\n[](https://camo.githubusercontent.com/d1f8f47776acea47b592e9836c90a241273782eb055d9262a3b6a9f064f48aff/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f366166383962633867773166387135306463667676673230337a303366676d712e676966)\n\n对方会突然间询问你是怎样的人，能为他带来什么 _（这跟自我介绍又有不同，主要是介绍自己的优势）_。所以这个答案必须事先考虑好。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B)回答示例\n\n❌ **糟糕的回答 1**：您想知道些什么？\n\n📝 **点评**：这个回答表现出你一无所知，或者是根本没有能力推断出面试官想要了解的信息。也从侧面表明了你在这份工作上并没有花功夫，很可能面试官就终止面试了。\n\n---\n\n❌ **糟糕的回答 2**：那么就从我小时候开始说吧···\n\n❌ **糟糕的回答 3**：我是个程序员。今年 `1` 月份开始我就失业了，在家里可没什么编程机会，所以目前还不完全算是。但我还是很希望得到这份工作，因为您也知道在没有收入的情况下背负这么多贷款是一件多么艰辛的事情，对吧？\n\n📝 **点评**：你应该花大概 `30s` 的时间把自己 **最闪光** 的地方陈述一遍，你的目标是给出一系列优势，而不是让听众觉得无聊和厌烦。而且尽量应该 **口语化** 一些的方式叙述出来。\n\n---\n\n✅ **恰当的回答**：现在算起来我做系统管理员已经有 `7` 个年头了。最开始我在一家只有 `10` 个人的公司中维护一台 Windows NT 服务器。后来我们在一台 Windows NT 的域上建了一个 Samba 服务器，管理 `150` 名用户，这些用户有的使用 Windows，有的使用 Linux。同时我也做一些编程工作，以及写 shell 脚本。我还曾经为 Nagios 远程监控服务写过插件，并且为 Bugzilla 提交了几个补丁。过去我一直从事的是市场营销行业，所以我觉得是时候丰富自己的阅历了。能在 Yoyodyne 工作对我来说是个不错的转变。\n\n📝 **点评**：尽量使用完整的句子，而不仅仅是摘录关键的要点。另外应该为某份工作或者某家公司量身定做。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E9%9D%A2%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%BA%E5%91%98%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9B%9E%E7%AD%94)面对不同的人员使用不同的回答\n\n💁‍♀️ **面对人力资源筛选人员**：用保险的方式回答。谈谈你这些年的工作经历以及都在哪些公司供职。聊一聊你的高水平技能（数据库、Linux方面），但不要过于细化（具体到 Oracle 和 Postgres, RedHat 和 Ubuntu）。当然在提到那些招聘广告中列举的具体技能要求时可以适当细化。\n\n👨‍💻 **面对你的未来同事**：尽可能细化你掌握的技术，还可以时不时地蹦几个时髦的技术词汇让你们之间的对话产生火花。\n\n👨‍💼 **面对非技术型管理层领导**：强调你的成就、完成的项目以及贡献出的商业价值。尽量避免使用那些时髦技术词汇。\n\n👨‍💻‍ **面对你的未来上司**：什么内容都提一点，强调一下团队合作精神以及软技能。\n\n---\n\n你的回答应该根据应聘职位以及公司的不同而调整。\n\n如果招聘广告中强调过某项专业技能要求，那就在你的回答中突出它。如果你有相同行业的从业经验，那么这也是你需要强调的地方。\n\n另外，面试官提问的方式也可能各有不同，也许会采取更直接的方式，比如：“你觉得自己比起别人有哪些方面的优势？”\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#2-%E4%BD%A0%E5%AF%B9%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3)2 你对我们公司有什么了解？\n\n这个问题可以快速的让面试官了解到应聘者为面试做了什么样的准备。\n\n[![](https://camo.githubusercontent.com/38bfd7fa0bd9900fe387ba4b24c381d01b43794d8bab9c53d35dac1d59cef2fd/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63386439623736366c79316666367268626b35326b6a323068733068736162672e706e67)](https://camo.githubusercontent.com/38bfd7fa0bd9900fe387ba4b24c381d01b43794d8bab9c53d35dac1d59cef2fd/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63386439623736366c79316666367268626b35326b6a323068733068736162672e706e67)\n\n应聘者对每个面试都是无差别对待的吗，还是他只对我们公司特别感兴趣？他已经做足了功课把公司调查清楚了吗？\n\n对于应聘者来说，这个话题也可以成为自我介绍的引子，并且你还能从中了解公司的需求。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-1)回答示例\n\n❌ **糟糕的回答**：那个，说实话不太了解。不过我觉得你们的网站做得不错！\n\n📝 **点评**：对公司毫无了解就去面试会在面试官心里默默掉很多分。\n\n---\n\n✅ **恰当的回答**：HoseCo 是一个专门生产工业用软管及配件的公司。公司 `1954` 年成立，在 `70` 年代时搬到目前的所在地。我想知道你们会为航空业提供材料吗？因为我曾经在波音公司的冷暖装置部门做过顾问，那对我来说是一段难忘的经历。另外，我发现你们网站使用的是 JSP 技术，但是在线产品目录似乎使用的又是 CGI。请问那是用 Perl 语言写的吗？而且我知道你们也在辛辛那提设立了第二分部，这也说明了公司运营情况不错。那么请问你们和俄亥俄分部之间是如何建立通信的呢？\n\n📝 **点评**：上述的回答不仅显示出了自己是有备而来，而且还证明了自己能用老板思维看待问题。因为你提到的个人背景正是能够为公司带来利益的。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#3-%E4%BD%A0%E5%AF%B9%E5%85%AC%E5%8F%B8%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E6%84%9F%E5%85%B4%E8%B6%A3)3 你对公司的什么地方感兴趣？\n\n在其他条件都对等的情况下，没有哪个招聘经理希望录用对工作或公司毫无兴趣的员工。而且关键是，你也不应该找一份自己提不起兴趣的工作。\n\n[![](https://camo.githubusercontent.com/6f915710f3b6d189bed8f0acea1e1e147f70d5c28f8e115d6090c4e5dbc725a7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303641506f46596c7931673969727a677165637867333064633064636a74332e706e67)](https://camo.githubusercontent.com/6f915710f3b6d189bed8f0acea1e1e147f70d5c28f8e115d6090c4e5dbc725a7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303641506f46596c7931673969727a677165637867333064633064636a74332e706e67)\n\n如果你对这个问题的答案根本毫无头绪，那么也许根本不应该申请这份工作。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-2)回答示例\n\n❌ **糟糕的回答 1**：这个，是因为离我家很近。\n\n📝 **点评**：这是一个理由也不要第一个说出来，因为即使公司离家的距离很重要，那也不应该让对方觉得这是你的首要关注点。永远都要记得把公司利益放在第一位。\n\n---\n\n❌ **糟糕的回答 2**：我看上了贵公司发的薪水。\n\n📝 **点评**：真诚很重要，但也不要太“实诚”。\n\n---\n\n✅ **恰当的回答**：我一直都很喜欢汽车，所以能为一家生产汽车零部件的公司工作对我来说是十分理想的选择。招聘广告上说公司使用的是 Ruby on Rails，这也正是我很愿意做的工作。因为过去我一直使用 Java Struts。另外，我在贵公司财务部门的好朋友苏西·德金斯也向我推荐这儿。她总是和我说起这个大家庭里大家相处得有多融洽，而且贵公司离我家也只有 `10` 分钟的路程。总而言之，这份工作对我来说十分理想。\n\n📝 **点评**：这个问题也是个机会，让你提起自己和公司之间的联系，或者说起公司中熟人。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#4-%E4%BD%A0%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88)4 你最大的优势是什么？\n\n面试刚开始时，重点话题都是关乎你是谁，你有什么样的经历一类的问题，比如第一个问题「谈谈你自己」的部分。\n\n而在面试后期，很可能话题将会转到如何 **评价自己** 这儿。\n\n[![](https://camo.githubusercontent.com/3154bb17f17dc73e6bd17c126da5cfef97f65e9f909ce1d60374a1cc10353265/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303641506f46596a7731666176333279796576626a3330687330687330746f2e706e67)](https://camo.githubusercontent.com/3154bb17f17dc73e6bd17c126da5cfef97f65e9f909ce1d60374a1cc10353265/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303641506f46596a7731666176333279796576626a3330687330687330746f2e706e67)\n\n无论哪部分，都应该挑选自己 **擅长** 的内容说，同时给出支持自己说法的例子。最好能提供软技巧和硬技能各一个。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-3)回答示例\n\n❌ **糟糕的回答 1**：我工作很努力。\n\n📝 **点评**：面试官当即给你一个白眼，每个人都这么说。\n\n---\n\n❌ **糟糕的回答 2**：我是一名优秀的程序员。\n\n📝 **点评**：话可能不错，但是没有提供细节和案例上的支持，等同于一句废话。\n\n---\n\n✅ **恰当的回答 1**：遇到危机时我都能保持冷静并很快集中精力，很少有事情会让我感到绝望。旁人都对我处理棘手问题的能力感到惊讶。您也知道，对于我们系统管理员来说，眨眼之间就可能面临一大堆麻烦。\n\n📝 **点评**：有细节上的说明，并且贴合自己的职位。\n\n---\n\n✅ **恰当的回答 2**：我对数据抽象化很有心得。建立数据库模式、编写接口这一类的事情对我来说就像是与生俱来的能力。这是工作中我最爱做的部分。\n\n📝 **点评**：不用对分辨哪一项才是自己最大的优势发愁。实际上你只要选择那些对公司最有益的优势展开就可以。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#5-%E4%BD%A0%E6%9C%80%E5%A4%A7%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88)5 你最大的缺点是什么？\n\n这似乎是大家最头疼的问题。面试官想让你亲口坦白自己究竟有哪些不适合这份工作的缺陷，当然事实上你根本不需要说自己不适合的地方。\n\n![68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c7931666771753564766b6272673230366f30376f3074372e676966](https://camo.githubusercontent.com/88d90fecd6cd1b7f72918c82c172ff5eb74957b5ab17b3d49e7e93125cc55935/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c7931666771753564766b6272673230366f30376f3074372e676966)\n\n[](https://camo.githubusercontent.com/88d90fecd6cd1b7f72918c82c172ff5eb74957b5ab17b3d49e7e93125cc55935/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c7931666771753564766b6272673230366f30376f3074372e676966)\n\n请确保自己不会被突如其来的问题吓到，从而坐在位子上苦思冥想哑口无言。\n\n➡️ 有很多求职的书籍都会建议使用一个技巧性的回答「我工作过于拼命」，或者是「当我发现大家不如我工作努力时会很失望」。\n\n这些回答的思路没有错，因为他们知道要把对自己不利的局面转向有利的方向。但是这样的回答 **存在两方面的问题**。\n\n**首先**，这很可能并非你的真实情况，也就是说你在撒谎；\n\n**其次**，更糟糕的是，它们完全是一通废话，而且面试官很清楚这一点。这样的回答可以明显看出求职者在刻意撒谎。\n\n正面地处理这个问题，是把它当做是「你希望自己在哪方面得到提高？你现在提高的情况如何？」这样的问题来对待。\n\n确保回答的语气体现了这些的确是你个人需要提高的部分，而不要表现得一切似乎都是别人的错。\n\n**选择技术方面的弱势，而非个人的失败之处或是人格上的缺陷。**\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-4)回答示例\n\n❌ **糟糕的回答 1**：当我发现大家不如我工作努力时会很失望。\n\n📝 **点评**：不仅是个无用的回答，而且提出的还是别人的错误。\n\n---\n\n❌ **糟糕的回答 2**：我是个完美主义者。\n\n📝 **点评**：不仅是个无用的回答，而且你能说出自己打算如何改进吗？另一句话，就是缺少细节和案例上的支持。\n\n---\n\n❌ **糟糕的回答 3**：我真的很讨厌测试代码。\n\n📝 **点评**：这对于一名程序员来说可是个巨大的失败。切忌讲述一个对于应聘职位来说是硬伤的缺点。\n\n---\n\n✅ **恰当的回答**：我对 JavaScript 和 Ajax 了解得还不够多。我目前从事过的编程工作都是偏向服务器方面的，但是显然，Ajax 技术会继续成为主流。前阵子我买了一本 PragmaticAjax，现在正在努力学习中。\n\n📝 **点评**：还是那一点建议，选择技术方面的弱势，而非个人的失败之处或是人格上的缺陷。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#6-%E6%88%91%E4%BB%AC%E5%87%AD%E4%BB%80%E4%B9%88%E9%9B%87%E4%BD%A0)6 我们凭什么雇你？\n\n如果这个问题在面试最后或是与更高层的第二轮面试一开始提出，那么意味着对方正在邀请你进行自我总结。\n\n[![](https://camo.githubusercontent.com/933aa381b935a3b7f2ca58eabe9abe6f657f2cffd3c3912ad9d8af677dc9675c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c793166716732763975356e7a6a3230393030356b6a726b2e706e67)](https://camo.githubusercontent.com/933aa381b935a3b7f2ca58eabe9abe6f657f2cffd3c3912ad9d8af677dc9675c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f39313530653465356c793166716732763975356e7a6a3230393030356b6a726b2e706e67)\n\n**说说一旦入职之后自己将会为公司采取哪些具体行动**，比如：“您刚才提到了公司面临的数据库规范化问题，这正是我可以提供帮助的地方。去年我曾经率领一个数据库管理员团队……”\n\n有些人会觉得这个问题是一种威胁。因为它给人的感觉就像是在问：“你究竟有什么好的，兄弟？”这感觉就好比将一个重担压在应聘者身上。\n\n千万别这么想。就把它当成是用略带攻击性语气的“谈谈你自己”，这样你的表现会自如很多。\n\n如果这个问题出现在面试开场，那么在回答完之后再加一句：“当然，这些并不是我能够为公司带来利益的全部，我希望了解更多公司和部门面临的挑战，这样我才能知道如何能发挥自己全部的力量。”\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#7-%E8%B0%88%E8%B0%88%E4%BD%A0%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E8%BF%9B%E5%B1%95%E4%B8%8D%E9%A1%BA%E5%88%A9%E7%9A%84%E9%A1%B9%E7%9B%AE)7 谈谈你经历过的进展不顺利的项目\n\n对于这样的问题不存在所谓的正确或错误答案。面试官希望从中了解你是如何处理问题以及如何面对逆境的。**案例** 在这儿非常重要。\n\n[![](https://camo.githubusercontent.com/7e9b9735c4ab3db42e731ac8c3cb336376d206504e37b6063169f16667df942c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303554474736766c7931673368626137676536656a33306a76306e397463312e706e67)](https://camo.githubusercontent.com/7e9b9735c4ab3db42e731ac8c3cb336376d206504e37b6063169f16667df942c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f30303554474736766c7931673368626137676536656a33306a76306e397463312e706e67)\n\n如果你被问道“你曾经遇到过某某事件吗？”那么就把这个问题转为“给我讲一个关于某某事件的故事。”\n\n从这个问题中能得出 **两方面** 的结论。\n\n**一方面**，面试官想看看你究竟是如何处理日常工作中遇到的不顺，**另一方面** 可以了解你是否是一个抱怨者，你是会坦诚自己的错误还是将责任推卸到别人身上 _（最好能从自身和他人两方面的角度来说明这个问题，但是千万不能埋怨他人）_。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-5)回答示例\n\n❌ **糟糕的回答 1**：哦，好的，该讲哪一个呢？我们网络团队总要处理一些非常紧急的状况，因为市场部净安排些计划时间表非常不合理的项目。这样一来我们能腾出的时间往往不合乎他们的期望，于是他们就不停地责怪我们，搞得我们像群傻瓜一样。他们自己没能力提前安排好计划又不是我们的错。\n\n📝 **点评**：接着这个问题的往往会是：“那么你从中学到了什么”或是：“那么你会从哪些方面着手来防止这样的情况发生？” _（看👇）_\n\n---\n\n❌ **糟糕的回答 2**：_（接👆）_ 没学到太多。我想我们只能和市场部的人讲，没法事事都按照他们的意愿进行。我真想给市场部主管上堂课，告诉他软件工程究竟是怎么进行的！\n\n📝 **点评**：每一句回答都在指责别人，而且使用的是侮辱性语言。面试官从中可以看出一旦这位应聘者入职之后她很可能也会不停地抱怨中伤团队其他人，那么就会对你说再见了！\n\n---\n\n✅ **恰当的回答**：_（与👆面对的同样的情况）_ 近来我们和市场部之间出现了一些摩擦。新来的市场部主管对网站有一些宏伟的方案，而这些方案的完成期限不容商议，是为了即将到来的贸易展的。第一次合作时，我们就没办法按照他的预想办好事，从而引发了很多不愉快。他对我们这个网络团队很失望，而我们又觉得他的要求非常不合理。很显然，这是因为我们之间的沟通还不够。\n\n📝 **点评**：这就是上面说的，最好能从自身和他人两方面的角度来说明这个问题，但是千万不能埋怨他人。\n\n---\n\n✅ **恰当的回答**：_（现在，在面试官还没开口接下去提问时就主动回答）_ 第一次的不愉快之后，我们就主动碰头总结了这件事情。我们很高兴能看到市场部有着这样的进取心，但同时我们也商量好保证之后的项目要求合情合理。老实说一开始还很难谈拢，但是当市场部主管意识到我们其实是站在他那边后，进展便开始顺利了。\n\n📝 **点评**：主动提出自己是如何处理问题以及如何面对逆境的，主动主动主动。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#7-%E8%B0%88%E8%B0%88%E4%BD%A0%E7%8A%AF%E8%BF%87%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%99%E8%AF%AF)7 谈谈你犯过的最大错误\n\n这个问题直指 **两方面** 的信息。**首先**，它能体现出应聘者如何处理“项目进展不顺”的 **指责**。**其次**，这也展示了应聘者的 **经验水平**。\n\n[![](https://camo.githubusercontent.com/15d4518eea32781c7c34d41392bda3465ac884a6410b14880fcac32b5477ec5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63656562363533656a7731666175773363377366306a323036723036716161672e6a7067)](https://camo.githubusercontent.com/15d4518eea32781c7c34d41392bda3465ac884a6410b14880fcac32b5477ec5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63656562363533656a7731666175773363377366306a323036723036716161672e6a7067)\n\n只有实实在在地工作过才会犯错，如果你从来没犯过错，那只能说明你并没有付出足够的努力。\n\n除非你所在的行业绝对不允许错误发生，譬如医疗以及航空业，犯错意味着有人丢掉性命。\n\n同时，错误也是学习与成长的过程。\n\n挑选一个可以证明你有能力为错误承担责任的例子，并且在回答中增加说明“你从中学到了什么”。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-6)回答示例\n\n❌ **糟糕的回答 1**：我不知道，我想我没犯过什么错。\n\n📝 **点评**：那也说明你没有什么实际的项目经验。\n\n---\n\n❌ **糟糕的回答 2**：我曾经有一次错误地将C盘格式化了，那简直糟透了。\n\n📝 **点评**：错确实是大错，但是你并没有说明你为错误承担责任的能力。\n\n---\n\n✅ **恰当的回答**：当时我们试图更换一个新的电子邮件系统，我使用 Perl 语言从 Notes 中读取数据，并写进 Exchange 里。周一早上，用户气愤地发现他们存档文件被错误地重新分类了。所有存档文件中的邮件都被移至单一的文件夹中，而那时候已经来不及重新运行指令了。打从那以后，我就发誓今后每一个数据转移项目都必须添加转移前的确认步骤，这样可以让我在指令实施之前重复确认以保证万无一失。\n\n📝 **点评**：还是上面的建议，挑选一个可以证明你有能力为错误承担责任的例子，并且在回答中增加说明 “你从中学到了什么”。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#8-%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%B0%86%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86)8 如果...你将怎么处理\n\n这样的问题通常建立在某个特定场景下，这个场景并没有显而易见的正确处理方式。\n\n这时候你采取的行动能体现出 **处理事务的灵活性** 以及 **解决问题的能力**。\n\n[![](https://camo.githubusercontent.com/ca8a42fac1661e7383f9d29f2447299cd1edf26014daa8fceafef34274f7a2f6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63656562363533656c793167356d75756b6f787a396a323064793037733379792e706e67)](https://camo.githubusercontent.com/ca8a42fac1661e7383f9d29f2447299cd1edf26014daa8fceafef34274f7a2f6/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f63656562363533656c793167356d75756b6f787a396a323064793037733379792e706e67)\n\n即使问题场景似乎与技术有关，但通常情况面试官让你做的却是非技术层面的判断。下面是可能出现的问题：\n\n> 📌 **可能场景 1**：假设你处在代码冻结阶段，距离某个软件的发行日子只剩下最后两天，这时候你发现由同事负责编写的代码中有一个小 bug。你知道这位同事之前也出现过代码质量问题，而且他也十分担心自己在公司的业绩评估。你可以轻松地修改这个 bug 而不用告诉任何人。但是现阶段，照理说任何改动都需要经过项目经理的批准。那么这时候你该如何处理？\n\n> 📌 **可能场景 2**：你所在的是一个小公司，某天公司总裁找到你，表示他对公司网站极度不满。他坚持用户注册表格中应该使用单选按钮而不是现在的下拉菜单。他要求你今天就改过来。从技术上来说，你可以轻松地按照总裁的要求修改，但这样就和部门现有的流程规定不符。哦对了，你的头儿正好在度假，不在公司。这时候你该如何处理？\n\n上面👆提到的两个例子都没有所谓的正确答案。面试官也许只是对你的思考过程感兴趣，那么请确保回答中包含了你的思路。\n\n这样的问题也是检验你和公司文化 **是否合拍** 的一种方式。你也许会发现公司总是严格按照规章制度办事，或永远都唯老总马首是瞻。\n\n如果你和公司文化有无法融合的地方，最好趁现在赶紧发掘。请干脆地回答问题而不要过于絮叨。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-7)回答示例\n\n✅ **恰当的回答**：我会照着总裁的意思做网站调整。但同时我也会对原有的版本做好代码备份，以防头儿回来之后有不同的意见。这的确是一个两难的境地。请问是不是部门过去遇到过这样的情况呢？\n\n📝 **点评**：你不需要询问经理正确答案是什么，因为很可能自己就能挖掘出来。他也许会说：“是的，我们负责销售的副总就曾经如此利用了自己的权威。现在每个下属都会找我做决定，不管我处在什么情况下。”\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#10-%E4%BD%A0%E6%9B%B4%E5%96%9C%E6%AC%A2%E5%9B%A2%E9%98%9F%E8%A1%8C%E5%8A%A8%E8%BF%98%E6%98%AF%E8%87%AA%E5%B7%B1%E5%8D%95%E5%B9%B2)10 你更喜欢团队行动还是自己单干\n\n独立完成工作与团队合作代表了一枚硬币的正反两面。\n\n[![](https://camo.githubusercontent.com/4e1f195183dc8217ce1680363a377e380e14cdaa9416ecb3d52e610b14e9fb73/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f303036486b624c6b6c79316765327631366d6d36676a3330356b30356b3073732e706e67)](https://camo.githubusercontent.com/4e1f195183dc8217ce1680363a377e380e14cdaa9416ecb3d52e610b14e9fb73/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f303036486b624c6b6c79316765327631366d6d36676a3330356b30356b3073732e706e67)\n\n经理总是希望团队中的每个成员都能够独立完成工作而非事事都需要他的指引。但从另一方面说，不愿意或不能够和他人共事的员工，或是无法听从经理指示的员工都是团队生产力极大的阻碍。\n\n对于经理来说，比必须手把手地指示员工干活还要浪费时间的，就是处理团队成员之间的矛盾问题了。\n\n**请注意回答这个问题的态度。**\n\n**千万别** 给人你只能在自己 **偏好的状态** 下 **才能工作** 的印象。而且对于大多数情况来说，答案都不应该只是简单的 A 或 B，应当给出合适的例子。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-8)回答示例\n\n❌ **糟糕的回答 1**：哦，饶了我吧，拜托还是让我自己单干吧。\n\n📝 **点评**：偏向性太强，并且语气有些“偏激”。\n\n---\n\n❌ **糟糕的回答 2**：我发现最佳的工作状态就是自己单干而不加入任何人的情况。\n\n📝 **点评**：答案不应该只是简单的 A 或 B，应当给出合适的例子。\n\n---\n\n✅ **恰当的回答**：一切都依项目情况而定。如果我编写的是一次性工具代码，那么一般来说还是由个人独立完成比较好，最多也就是再安排一个同事帮我把关，确保没有任何地方出错。当然，对于大型项目来说，都是需要一整个团队人员的支持，而且项目的每一个分支该以个人完成还是两人一组完成也都是依据任务的性质而定。我想我个人是更倾向于可以发挥出最佳效率的独立工作状态，但是大多数情况下，都是会要求整个团队之间合作的。\n\n📝 **点评**：A 或 B 的状态都给出了合适的例子，面试官表示想给一个暴风👍。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#11-%E4%BD%A0%E5%B8%8C%E6%9C%9B%E8%87%AA%E5%B7%B1-5-%E5%B9%B4%E4%B9%8B%E5%90%8E%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88)11 你希望自己 5 年之后在做什么？\n\n这样的规划类问题确实令面试者 **头疼**，这个问题有点儿类似于「职业规划」，我可能就是单纯地为了生存、温饱，但你非要问我的规划 _（类似于问生活的意义是什么）_。\n\n[![](https://camo.githubusercontent.com/d9a1328a1d155bf576b0c27759d1aee321c7adf1124627fed26971f3b8110872/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f303036384c66646567793167303868616b693779336a333138673138676e63622e706e67)](https://camo.githubusercontent.com/d9a1328a1d155bf576b0c27759d1aee321c7adf1124627fed26971f3b8110872/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f303036384c66646567793167303868616b693779336a333138673138676e63622e706e67)\n\n有很多招聘人员对于自己的规划也不一定清晰，所以心态要端正，他并不是为了要帮你做职业规划之类的，也对你的规划也不感兴趣，他只是关心你的 **稳定性** 、**匹配度** _（譬如是否考虑转岗）_ 以及 **能力** _（有没有真正想去沉淀之类的）_。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-9)回答示例\n\n❌ **糟糕的回答 1**：我没想法。\n\n📝 **点评**：那我也对你没什么想法。\n\n---\n\n❌ **糟糕的回答 2**：谁能说得准呢？这可是计算机行业，我现在说的任何回答都不会是正确的，因为技术发展日新月异。\n\n📝 **点评**：似乎对公司的前景、团队中的发展毫不关心，这样的回答会让面试官在心里留下一个大问号「这是我希望找到的人吗？」\n\n---\n\n✅ **恰当的回答 1**：就我目前的职业发展来看，我希望自己到时候能处在团队领导的位置，但是我还并不确定管理层的位置是否适合自己。从技术方面说，当然我很难给一个具体的回答，但是未来我主要感兴趣的两个大方向是社交网络以及大型数据库。一直以来我都对大型数据库兴趣盎然，另外像 Facebook 这样的社交网站的兴盛也让我觉得从事这方面的业务是不错的选择。请问 Yoyodyne 公司目前是否在做社交网络的内容？\n\n📝 **点评**：回答你所知的内容，而非猜测他们想听的。没有所谓的正确或错误的回答。如果你对领导位置没有兴趣，那么就别想着“我希望担任程序员团队的领导”或者其他可能会让你被贴上懒鬼标签的回答。而且，万一面试官根本不想找一个做领导位置的人呢？\n\n---\n\n✅ **恰当的回答 2**：我希望自己能做一些和今天所应征的职位不同的工作，当然还是在这家公司。我发现自己与其说是一个专才不如说是一个通才，这个特点让我一直不断地追求新技术，也希望每两三年都能迎接全新的挑战。\n\n📝 **点评**：即使只有很少甚至根本没有工作经历，你也依然得拥有放眼未来的视角。\n\n---\n\n✅ **恰当的回答 3**：因为这是我的第一份全职工作，所以很难讲未来的具体计划是什么。我希望到时候自己在这家公司已经完成一些出色的项目，有过一两级的晋升，并且在工作过程中对系统管理员方面的知识有更深入的了解。\n\n📝 **点评**：最重要的是，你必须在参加面试之前主动考虑清楚这个 `5` 年后的计划 _（其实这事儿挺虚的.. 很难有人能想清楚这事儿）_，因为如果申请的这份工作根本不符合你的 `5` 年计划，那么从事这份工作只会将你引向一条死路。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%83%B3%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC)12 为什么你想加入我们\n\n这根本不应该是个问题，如果你是有选择地参加面试的话。参加面试之前你就应该清楚这个问题的答案。\n\n[![](https://camo.githubusercontent.com/ccef8d7c721188b7c37520901ccfa6d3c6b9175f12ebd5dd6cb6bf6be5167c29/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f393135306534653567793166723861646f6e7770786a3230716f306563676e722e706e67)](https://camo.githubusercontent.com/ccef8d7c721188b7c37520901ccfa6d3c6b9175f12ebd5dd6cb6bf6be5167c29/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f393135306534653567793166723861646f6e7770786a3230716f306563676e722e706e67)\n\n**请确保** 首要理由是 **和公司有关**。陈述完这个理由之后，才可以聊聊关于你个人的考虑。\n\n和之前说的一样，公司利益永远应该是你的第一考虑。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-10)回答示例\n\n❌ **糟糕的回答 1**：不知道，只是觉得这份工作很酷。\n\n📝 **点评**：我也觉得拒绝你的我应该也蛮酷的吧👿。\n\n---\n\n❌ **糟糕的回答 2**：因为我一直都很喜欢编程。\n\n📝 **点评**：这并没有体现这家公司与其他公司之间的区别。\n\n---\n\n✅ **恰当的回答**：能够管理像贵公司那么大的网络系统是促进我个人技能提高的好机会，我相信自己能从中学到很多东西。另外，打从小时候我就对飞机非常喜爱，所以航空业也是我的理想行业。\n\n📝 **点评**：针对性地对公司进行回答，并贴合自己的应聘职位来叙述会是更恰当的选择。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E8%A6%81%E7%A6%BB%E5%BC%80%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%85%AC%E5%8F%B8)13 为什么你要离开原来的公司\n\n⚠️ 雷区警告。\n\n你将要说明的是自己对某个处境不愉快的原因，而 **不是抱怨**。无论如何，千万不能将不愉快都归咎于他人身上。\n\n[![](https://camo.githubusercontent.com/00f44ba1c91261198fd4925acd9a37952eba5a256ffc7662c12f5f264d8a8667/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f34313566383262396c7931667462787870363439766a32306b30306a753430782e706e67)](https://camo.githubusercontent.com/00f44ba1c91261198fd4925acd9a37952eba5a256ffc7662c12f5f264d8a8667/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f34313566383262396c7931667462787870363439766a32306b30306a753430782e706e67)\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B-11)回答示例\n\n❌ **糟糕的回答 1**：我的老板就是个傻x，而且那些团队伙伴根本就是一帮无能的白痴。\n\n📝 **点评**：哇哦，再见吧~\n\n---\n\n❌ **糟糕的回答 2**：那个，只能说老板和我有一些分歧。倒不是说他做人方面有问题，只是我们之间存在很多冲突。虽然我很不愿意这么说，但是他真的没招到什么好程序员。我很喜欢我的同事们，但是跟一帮成天无所事事的人一起工作的确也是件令人沮丧的事。\n\n📝 **点评**：温和的用词也无法掩盖你的抱怨行为。因为你依然在表达自己的不愉快都是由他人造成的。也就是说你是个不折不扣的抱怨者。\n\n---\n\n✅ **恰当的回答 1**：我觉得在 Yoyodyne 没什么发展前景。我们所做的所有工作项目，都是对于现有系统的维护，没什么新的项目计划。我喜欢每一天的工作都充满挑战。我曾经就这个问题和我的头儿讨论过，但是他也说自己对此无能为力。我在家自学了 Ruby，但是公司也没有适合我进步提高的空间。\n\n✅ **恰当的回答 2**：我需要找一份离家近的工作。当三年前我刚进那家公司时，一个半小时的上班路程对我来说也不算什么问题。但现在我发现路上花费大量的时间将和家庭生活起冲突，而且路上的花费也越来越高。当然，尽管距离并不是唯一的原因，但发现 Yoyodyne 公司有如此适合我的工作而且车程也只有 `15` 分钟，我真的很兴奋。\n\n✅ **恰当的回答 3**：我和之前公司的合同 `6` 月底就到期了。我也试图在公司中寻找过别的工作机会，但是现在似乎没有适合我的技能与背景的职位空缺。\n\n✅ **恰当的回答 4**：上一家公司的收入完全不符合我的技能水平和个人背景。我曾经看过许多关于收入的调查，也和一些公布的生活消费指标进行过比对。我喜欢之前的工作，但是上司跟我说公司的薪酬体系很难再做改变。_（但请准备好应对面试官的下一个问题：“那你一开始怎么会接受这份工作呢？”）_\n\n📝 **点评**：最后的例子倒是一个可以放心地讨论收入问题的样板，因为这只是在正面回答面试官的提问。但请注意千万别自行踏入下一个问题，询问面试官：“那么告诉我，这份工作的收入是多少？”\n\n在所有情况下，你的回答都应该只是 **陈述事实**，而不加以任何憎恨或责备的情绪。对于合同到期的情况，你也无需进行太多的解释：只是没有更合适的工作而已。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#14-%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E8%A6%81%E9%97%AE%E6%88%91%E7%9A%84%E5%90%97)14 你有什么问题要问我的吗？\n\n由于 **面试是双向** 的，所以你也需要准备一些问题询问面试官以及参与到面试中的其他相关人士，尽管他们并不会成为你的未来上司。\n\n[![](https://camo.githubusercontent.com/e2b32a872fe564dbaef6ebe30bf2b968b2d97a67efee9f3777bc0d13bf9cb1c5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3030366d39374b676c7931676136676f6f647933356a33306b75306b7271357a2e706e67)](https://camo.githubusercontent.com/e2b32a872fe564dbaef6ebe30bf2b968b2d97a67efee9f3777bc0d13bf9cb1c5/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f426c6f67496d61676530322f2545332538302538414f66666572254534254238253830254537254145254139254537254144253930254533253830253842325725453525414425393725453625383025424225453725424225393325453925394425413225453825414625393525453525413525393725453825423725414631342545392539372541452545322538302539342545322538302539342545342542382538442545372542422539392545342542452538422545352541442539302545372539412538342545362539352539392545372541382538422545392538332542442545362539382541462545382538302538442545362542352538312545362542302539332f3030366d39374b676c7931676136676f6f647933356a33306b75306b7271357a2e706e67)\n\n事实上，应聘者在提问环节的沉默只会引发面试官更多的疑问：他是不是根本不关心这份工作究竟会怎样？他是不是压根就对这份工作不感兴趣？也许对他来说这份工作只是通往其他目标的踏脚石？看起来他根本就懒得思考这份工作该如何开展？\n\n提问表示你对这个职位感兴趣，同时也意味着你不只是在广撒网地找工作而已。\n\n面试官为了把你请到面试中是花费了时间和精力的，所以一旦给他们留下印象以为你对自己申请的工作根本不感兴趣，那就糟了。\n\n**另外别准备那些对任意面试都通用的问题。**\n\n你需要反映出自己对于这家公司的兴趣、所进行过的调查以及加入的独立思考。\n\n譬如，你可以问：“对于那些可以在开源项目中得到的产品，你们在销售时会面临怎样的挑战呢？”或是：“既然大家都知道亚马逊网站，那么你们又是如何将书籍销售给校园市场的呢？”\n\n你当然可以询问一些关乎自身的问题，但是在提问的同时也别忘了展示自己时刻在考虑能为公司带来的利益。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8Fq1%E6%AF%8F%E5%A4%A9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)🙋‍♂️Q1：每天的工作流程是怎样的？\n\n如果你希望了解每天的工作对员工有哪些要求，那么就可以询问这个问题，比如有没有早会、例会、立会、饭点时间、休息时间之类的。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8Fq2%E4%B8%8A%E7%8F%AD%E6%97%B6%E9%97%B4%E6%9C%89%E4%B8%A5%E6%A0%BC%E8%A7%84%E5%AE%9A%E5%90%97%E5%8A%A0%E7%8F%AD%E9%A2%91%E7%8E%87%E9%AB%98%E5%90%97%E4%BC%9A%E5%9C%A8%E5%91%A8%E6%9C%AB%E5%AE%89%E6%8E%92%E5%8A%A0%E7%8F%AD%E5%90%97)🙋‍♂️Q2：上班时间有严格规定吗？加班频率高吗？会在周末安排加班吗？\n\n这个问题其实是比较敏感的，因为你肯定不希望自己被面试官当成是一个懒惰、自我的家伙。\n\n但是，想了解自己未来的工作有哪些要求的心情也是可以理解的。\n\n最好的方法就是单纯地倾听对方的回答并做好记录，而不对此作任何评论。对这份工作的不尽人意之处讨价还价是得到工作之后的事，而不是之前。\n\n千万记得你不是去给面试官出难题的，所以请避免类似下面的谈话。\n\n> 🙋‍♂️ **你**：请问一下加班的频率有多高？我每周三都会跟小伙伴们约球，而且有时候周六上午我还得接女儿去补习班。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8Fq3%E5%AE%89%E6%8E%92%E6%88%91%E5%81%9A%E5%93%AA%E7%B1%BB%E9%A1%B9%E7%9B%AE%E6%82%A8%E7%9C%8B%E4%B8%8A%E7%8F%AD%E7%AC%AC%E4%B8%80%E5%91%A8%E6%88%91%E8%AF%A5%E5%B9%B2%E4%BA%9B%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88%E5%91%A2%E7%AC%AC%E4%B8%80%E5%B9%B4%E5%91%A2)🙋‍♂️Q3：安排我做哪类项目？您看上班第一周我该干些什么？第一个月呢？第一年呢？\n\n你需要了解工作对你的要求有哪些，进而评判这是否符合自己的工作风格。\n\n如果面试经理没有给出答案，那么你可得自己敲警钟。请看下面这位招聘系统管理员的经理给出的回答。\n\n> 💁‍♀️ **招聘人员**：我现在还不确定。我知道我们的项目需要一些数据库日常操作方面的帮手，但是我还不确定具体是哪方面的工作。目前在做的是 Oracle 的项目，也可能是 DB2 的。\n\n如果招聘人员能够给出更多的信息，那么说明她对公司 IT 需求有着相当的了解，并且她还对未来的工作定制了计划。\n\n最重要的是，这意味着你上班第一天不用呆坐在位子上玩弄手指了。她也许是一位不错的工作伙伴。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8Fq4%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A2%9E%E7%9A%84%E8%81%8C%E4%BD%8D%E5%90%97%E8%BF%98%E6%98%AF%E8%AF%B4%E6%88%91%E6%98%AF%E6%9D%A5%E6%9B%BF%E6%8D%A2%E4%B8%8A%E4%B8%80%E4%BD%8D%E5%91%98%E5%B7%A5%E7%9A%84)🙋‍♂️Q4：这是一个新增的职位吗？还是说我是来替换上一位员工的？\n\n如果说职位是新增的，那就表示部门正在扩大规模，那么继续就扩大规模的程度进行提问。\n\n如果你是来替换上一位员工，那么就问问这位的情况，譬如：“跟我讲讲xxx吧，他都为公司做了什么？”\n\n这些问题的答案应该会给你一些思路，如果公司对上一位员工的评价很高，那么你就知道今后自己需要在工作中达到怎样的表现才行，如果评价不高，那么你也了解到自己该避免怎样的表现。\n\n请注意你可不允许询问xxx离开公司的内幕，而要给面试官一点余地，看他是否愿意告诉你。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8Fq5%E8%B7%9F%E6%88%91%E8%B0%88%E8%B0%88%E5%8D%B3%E5%B0%86%E5%8A%A0%E5%85%A5%E7%9A%84%E5%9B%A2%E9%98%9F%E5%90%A7)🙋‍♂️Q5：跟我谈谈即将加入的团队吧\n\n这个问题表现出你对于和他人相处的重视，而且能得到一些背景情况有助于你决定这个团队是否值得加入。\n\n如果招聘经理对于团队成员之间的交往只是了了作答，那么可以用这样的问题来深入提问：“大家都在一起吃午饭吗？”或是：“团队成员会在下班后一起出去玩吗？”\n\n从面试官那儿打听到的答案无所谓正确或错误，但你可能从上面这两个问题中得出自己侧重关心的信息。\n\n### [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%EF%B8%8F-%E5%85%B6%E4%BB%96%E4%BD%A0%E4%B9%9F%E8%AE%B8%E6%84%BF%E6%84%8F%E4%BA%86%E8%A7%A3%E7%9A%84%E9%97%AE%E9%A2%98)🙋‍♂️ 其他你也许愿意了解的问题\n\nGithub 上有一个 star 超过 `6k` 的 **反向面试** 项目，里面详细记录了 **技术面试** 最后反问面试官的话 _（事实上也不仅仅适用于技术面试）_，项目地址：[https://github.com/yifeikong/reverse-interview-zh](https://github.com/yifeikong/reverse-interview-zh)\n\n随便摘录一些吧：\n\n> ➡️ **职责：**\n> \n> -   On-call (电话值班)的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？\n> -   我的日常工作是什么？\n> -   团队里面初级和高级工程师的比例是多少？（有计划改变吗）\n> -   在你看来，这个工作做到什么程度算成功？\n> -   入职之后在哪个项目组，项目是新成立还是已有的？(zh)\n> \n> ➡️ **技术：**\n> \n> -   你们怎么测试代码？\n> -   有标准的开发环境吗？是强制的吗？\n> -   公司是否有技术分享交流活动？有的话，多久一次呢？(zh)\n> -   业务需求有没有文档记录？是如何记录的？(zh)\n> \n> ➡️ **团队：**\n> \n> -   晋升流程是怎样的？要求/预期是怎样沟通的？\n> -   我可以为开源项目做贡献吗？是否需要审批？\n> -   技术和管理两条职业路径是分开的吗？\n> -   有公司级别的学习资源吗？比如电子书订阅或者在线课程？\n> \n> ➡️ **And More....**\n\n但也请避免询问一些比较不那么有价值的一些问题：\n\n> -   贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）\n> -   贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）\n> -   贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）\n> -   ......\n\n# [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#03-%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E5%B9%B2%E8%B4%A7)03. 技术面试技巧干货\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#1-%E4%B8%BB%E5%8A%A8%E6%8F%90%E8%B5%B7%E6%9C%80%E8%83%BD%E5%B1%95%E7%A4%BA%E4%BD%A0%E6%8A%80%E8%83%BD%E7%9A%84%E8%AF%9D%E9%A2%98)1 主动提起最能展示你技能的话题\n\n别以为简历上列举的技能面试官都会主动提出来。\n\n要知道不管对你有多感兴趣，面试官也许根本记不住你的全部技能。实际上能留在她脑海中的只会是她个人觉得重要的内容，所以你可以提起其他方面的优势来引起她的注意。\n\n最佳的推销方式就是讲故事，可以讲一些也许并不适合在简历中详细列举的可用数据量化的例子。\n\n比如：\n\n> 💁‍♀️ **招聘人员**：你会使用 Perl 测试框架吗？\n> \n> ❌ **糟糕的回答**：当然，我们一直都在用这个。\n> \n> ✅ **恰当的回答**：是的，非常了解。从开始编写 CPAN 模块开始我就使用 Test::More 了，尽管当时只是用于测试自己写的模块。后来我编写了自己的测试插件 Test::Wango。现在我们会使用 Test::More 框架以及 TAP 协议来测试公司三分之一的内部应用程序，而且计划在年底之前将使用率升至 `100%`。\n> \n> 📝 **点评**：后面的回答显示了掌握知识的深度，并且打开了一扇深入讨论的大门。还有可能，这告诉了面试官一些他本身并不了解的内容。也许他从未听说过TAP，也根本不知道你不止能利用Test::More测试模块。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#2-%E4%BD%BF%E7%94%A8%E6%95%85%E4%BA%8B%E6%8E%A8%E9%94%80%E8%87%AA%E5%B7%B1)2 使用故事推销自己\n\n面试中最有可能出现的就是技术类问题，因为这些问题你最容易回答。\n\n无论你是否知道问题的答案，当被问及技术问题时，你不应该仅仅以简单的“是”或“不是”来作答，因为这样的答案并不是面试官所期待的。\n\n相反，应该多花一点时间讲故事，借机推销自己。\n\n比如：\n\n> 💁‍♀️ **招聘人员**：你会使用 Ruby 语言吗？\n> \n> ❌ **糟糕的回答**：是的，会一点。\n> \n> ✅ **恰当的回答**：会一点。当我还在 Peekax 研究公司工作时，我们有个小项目为 Web 框架选型。我当时负责研究 Rails，研究的过程中我也发现了 Ruby 语言的一些不尽人意之处。虽然我们最终还是选择了 J2EE，但是老实说我打心眼里希望能马上开展 Ruby 的工作。\n> \n> 📝 **点评**：从上面例子中可以看到具体详细的回答能避免歧义，而不加例证的简单答案容易产生误解。可能你所谓的 “会一点” Ruby 语言和面试官心目中的掌握程度有差别。\n\n## [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#3-%E5%BC%BA%E8%B0%83%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%89%BF%E6%8B%85%E7%9A%84%E4%BB%BB%E5%8A%A1)3 强调自己在工作中承担的任务\n\n在讲述过去的工作经历时，把重点放在你做过什么上。\n\n别对你实际做过的工作和起到的作用一句话带过。要知道你特别推销的是自己的才能，而不是当初的工作岗位。\n\n比如：\n\n> 💁‍♀️ **招聘人员**：你使用 Ruby 做过什么项目？\n> \n> ❌ **糟糕的回答**：我现在的工作是使用 Ruby On Rails 框架开发 `4` 种基础的内部 CRUD 应用程序，除此之外，团队还在 RubyForge 发布过一个数学函数包。\n> \n> ✅ **恰当的回答**：我之前所在的团队由3位开发人员组成，我们使用 Rails 框架开发了 `4` 个 CRUD 应用程序。公司原计划是想使用 .NET 框架，但是我最终还是说服上司同意我们尝试了 Ruby。同时，我还努力征得公司管理层的批准，在 RubyForge 上发布了其中一个函数库。这个函数库的名字叫做 Arithmegoo，目前已经拥有数百次的下载量了。\n> \n> 📝 **点评**：请注意强调自己在工作中承担的任务，使用这样的句式：“我做了什么。”即使只是团队中的一员，也不代表你只能成为碌碌无为的无名氏。因为你肯定做出过一些贡献。\n> \n> 另外也不要使用模糊的总结，要给出具体的实例。\n\n# [](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)参考资料\n\n1.  《人人都有好工作：IT 行业求职面试必读》 - [https://book.douban.com/subject/5998157/](https://book.douban.com/subject/5998157/)\n2.  做好面试自我介绍，你需要知道这几点 - [https://www.bilibili.com/video/BV1mJ411X776?from=search&seid=9234043315787537135](https://www.bilibili.com/video/BV1mJ411X776?from=search&seid=9234043315787537135)\n3.  如果面试官问你“你有什么问题问我嘛？”时，你该如何回答 | JavaGuide - [https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/面试官-你有什么问题要问我.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/%E9%9D%A2%E8%AF%95%E5%AE%98-%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E8%A6%81%E9%97%AE%E6%88%91.md)\n\n> -   本文已收录至我的 Github 程序员成长系列 **【More Than Java】，学习，不止 Code，欢迎 star：[https://github.com/wmyskxz/MoreThanJava](https://github.com/wmyskxz/MoreThanJava)**\n> -   **个人公众号** ：wmyskxz，**个人独立域名博客**：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！\n\n[![](https://camo.githubusercontent.com/0caa34d17ddf61d3d97d55202ff47668b6b9fe6a1afb16040a7cc05850241b49/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f696d672f696d672f636f6d6d6f6e2f7172636f64652e706e67)](https://camo.githubusercontent.com/0caa34d17ddf61d3d97d55202ff47668b6b9fe6a1afb16040a7cc05850241b49/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f776d79736b787a2f696d672f696d672f636f6d6d6f6e2f7172636f64652e706e67)\n\n（END）\n\n---\n\n历史好文推荐：\n\n1.  [《Offer一箩筐》一份高质量「简历」撰写指南，望打扰！！](https://www.wmyskxz.com/2020/09/14/offer-yi-luo-kuang-yi-fen-gao-zhi-liang-jian-li-zhuan-xie-zhi-nan-wang-da-rao/)\n2.  [《Offer一箩筐》求职之前你必须知道的 4 件事！！](https://www.wmyskxz.com/2020/09/08/offer-yi-luo-kuang-qiu-zhi-zhi-qian-ni-bi-xu-zhi-dao-de-4-jian-shi/)\n3.  [一文带你深扒ClassLoader内核，揭开它的神秘面纱！](https://www.wmyskxz.com/2020/08/28/yi-wen-dai-ni-shen-ba-classloader-nei-he-jie-kai-ta-de-shen-mi-mian-sha/)\n4.  [全网最通透的Java8版本特性讲解](https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/)\n5.  [And More...](https://www.wmyskxz.com/archives/)\n\nHi，这里是 **我没有三颗心脏**，一个兴趣爱好广泛的 **96** 年 **自由技术人**，在公众号 **wmyskxz** 分享 **「MoreThanCode」** 的 **知识/技术/成长/思考**，2020，与您在 **Be Better** 的路上共同成长！\n\n非常感谢各位人才能 **看到这里**，创作不易，文章有帮助可以点个 **「在看」** 或 **「分享」**，都是支持（**莫要白嫖**）！\n\nSomewhere not here，愿你我都能奔赴在各自想去的路上，我们下篇文章见！",
                    "title": "[](https://github.com/wmyskxz/MoreThanJava/blob/master/interview/%E3%80%8AOffer%E4%B8%80%E7%AE%A9%E7%AD%90%E3%80%8B2W%E5%AD%97%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF14%E9%97%AE%E2%80%94%E2%80%94%E4%B8%8D%E7%BB%99%E4%BE%8B%E5%AD%90%E7%9A%84%E6%95%99%E7%A8%8B%E9%83%BD%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%EF%BC%81%EF%BC%81.md#01-%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87)01. 面试前的准备"
                  }
                ],
                "title": "",
                "tagPath": "root/docs/docs/→ how-to-guides"
              }
            }
          }
        ]
      }
    ],
    "direction": "vertical"
  },
  "left": {
    "id": "918983a6ed7b7981",
    "type": "mobile-drawer",
    "children": [
      {
        "id": "fc3e940498712b85",
        "type": "leaf",
        "state": {
          "type": "file-explorer",
          "state": {
            "sortOrder": "alphabetical"
          }
        }
      },
      {
        "id": "189a743f63663ef6",
        "type": "leaf",
        "state": {
          "type": "search",
          "state": {
            "query": "big",
            "matchingCase": false,
            "explainSearch": false,
            "collapseAll": true,
            "extraContext": false,
            "sortOrder": "alphabetical"
          }
        }
      },
      {
        "id": "983f87a20d022399",
        "type": "leaf",
        "state": {
          "type": "tag",
          "state": {
            "sortOrder": "frequency",
            "useHierarchy": true
          }
        }
      },
      {
        "id": "6f849e94911a853d",
        "type": "leaf",
        "state": {
          "type": "recent-files",
          "state": {}
        }
      },
      {
        "id": "0e9e74785ab4c08c",
        "type": "leaf",
        "state": {
          "type": "starred",
          "state": {}
        }
      },
      {
        "id": "68ebb68b9fecab7c",
        "type": "leaf",
        "state": {
          "type": "tagfolder-view",
          "state": {}
        }
      }
    ],
    "currentTab": 0
  },
  "right": {
    "id": "218928be0dbd17d0",
    "type": "mobile-drawer",
    "children": [
      {
        "id": "90eb39c31fdfcd0f",
        "type": "leaf",
        "state": {
          "type": "backlink",
          "state": {
            "file": "2.经验与教训/我的/微量元素问题.md",
            "collapseAll": false,
            "extraContext": false,
            "sortOrder": "alphabetical",
            "showSearch": false,
            "searchQuery": "",
            "backlinkCollapsed": true,
            "unlinkedCollapsed": true
          }
        }
      },
      {
        "id": "068f8887fa70f1e6",
        "type": "leaf",
        "state": {
          "type": "outline",
          "state": {
            "file": "2.经验与教训/我的/微量元素问题.md"
          }
        }
      },
      {
        "id": "fbd1498f337b0e3b",
        "type": "leaf",
        "state": {
          "type": "outgoing-link",
          "state": {
            "file": "2.经验与教训/我的/微量元素问题.md",
            "linksCollapsed": false,
            "unlinkedCollapsed": true
          }
        }
      }
    ],
    "currentTab": 2
  },
  "active": "18c4caef5defb071",
  "lastOpenFiles": [
    "3.资料/打嗝原理.md",
    "2.经验与教训/我的/拍嗝的问题.md",
    "2.经验与教训/我的/微量元素问题.md",
    "2.经验与教训/我的/婴儿针对新冠提前准备.md",
    "2.经验与教训/我的/安全的睡眠环境.md",
    "2.经验与教训/我的/新生儿洗不洗澡的问题.md",
    "2.经验与教训/我的/换尿布问题.md",
    "3.资料/如何晒太阳.md",
    "2.经验与教训/我的/如何补充维生素 D.md",
    "2.经验与教训/我的/堵奶怎么办.md"
  ]
}