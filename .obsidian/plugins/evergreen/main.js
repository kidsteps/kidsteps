/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/main.ts
__export(exports, {
  default: () => EverGreenPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/main.ts
var uninstallPatchOpen;
var EverGreenPlugin = class extends import_obsidian.Plugin {
  async onload() {
    uninstallPatchOpen = around(import_obsidian.Workspace.prototype, {
      openLinkText(oldOpenLinkText) {
        return function(linktext, sourcePath, newLeaf, openViewState) {
          const name = linktext + (linktext.endsWith(".md") ? "" : ".md");
          let result;
          let found = false;
          let dirtyIndex = 0;
          const tabs = app.workspace.getLeavesOfType("markdown");
          for (let i = 0; i < tabs.length; i++) {
            let leaf = tabs[i];
            const viewState = leaf.getViewState();
            if (viewState.type === "markdown") {
              if (viewState.state?.file?.endsWith(sourcePath)) {
                dirtyIndex = i;
              }
            }
          }
          if (!found) {
            for (let i = dirtyIndex + 1; i < tabs.length; i++) {
              tabs[i].detach();
            }
          }
          result = oldOpenLinkText && oldOpenLinkText.apply(this, [
            linktext,
            sourcePath,
            !found,
            openViewState
          ]);
          return result;
        };
      }
    });
  }
  onunload() {
    uninstallPatchOpen();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL21haW4udHMiLCAiLi4vbm9kZV9tb2R1bGVzL21vbmtleS1hcm91bmQvbWpzL2luZGV4LmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQge09wZW5WaWV3U3RhdGUsIFBsdWdpbiwgV29ya3NwYWNlfSBmcm9tICdvYnNpZGlhbidcbmltcG9ydCB7YXJvdW5kfSBmcm9tICdtb25rZXktYXJvdW5kJ1xuXG5cbmxldCB1bmluc3RhbGxQYXRjaE9wZW46ICgpID0+IHZvaWRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlckdyZWVuUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgYXN5bmMgb25sb2FkKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHVuaW5zdGFsbFBhdGNoT3BlbiA9IGFyb3VuZChXb3Jrc3BhY2UucHJvdG90eXBlLCB7XG4gICAgICAvLyBNb25rZXktcGF0Y2ggdGhlIE9wZW5MaW5rVGV4dCBmdW5jdGlvblxuICAgICAgb3BlbkxpbmtUZXh0KG9sZE9wZW5MaW5rVGV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKFxuICAgICAgICAgIGxpbmt0ZXh0OiBzdHJpbmcsXG4gICAgICAgICAgc291cmNlUGF0aDogc3RyaW5nLFxuICAgICAgICAgIG5ld0xlYWY/OiBib29sZWFuLFxuICAgICAgICAgIG9wZW5WaWV3U3RhdGU/OiBPcGVuVmlld1N0YXRlLFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRyaWdnZXJcIilcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcGF0aCBlbmRzIHdpdGggJy5tZCdcbiAgICAgICAgICBjb25zdCBuYW1lID0gbGlua3RleHQgKyAobGlua3RleHQuZW5kc1dpdGgoJy5tZCcpID8gJycgOiAnLm1kJylcbiAgICAgICAgICBsZXQgcmVzdWx0XG4gICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBsZXQgZGlydHlJbmRleCA9IDBcbiAgICAgICAgICBjb25zdCB0YWJzID0gYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ21hcmtkb3duJylcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsZWFmID0gdGFic1tpXVxuICAgICAgICAgICAgY29uc3Qgdmlld1N0YXRlID0gbGVhZi5nZXRWaWV3U3RhdGUoKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmlld1N0YXRlLnR5cGUpXG4gICAgICAgICAgICBpZiAodmlld1N0YXRlLnR5cGUgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgICAgLy8gRm91bmQgYSBjb3JyZXNwb25kaW5nIHBhbmVcbiAgICAgICAgICAgICAgLy8gaWYgKHZpZXdTdGF0ZS5zdGF0ZT8uZmlsZT8uZW5kc1dpdGgobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgICAvLyBhcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhZilcbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAvLyBmb3VuZCBjdXJyZW50IGRpcnQgaW5kZXhcbiAgICAgICAgICAgICAgaWYgKHZpZXdTdGF0ZS5zdGF0ZT8uZmlsZT8uZW5kc1dpdGgoc291cmNlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUluZGV4ID0gaVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2xvc2UgYWxsIHJlbWFpbmluZyB0YWJzIGZyb20gZGlydHlJbmRleCBpZiBoaWVyYXJjaHkgbGluZSBjaGFuZ2VzXG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRpcnR5SW5kZXggKyAxOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0YWJzW2ldLmRldGFjaCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgbm8gcGFuZSBtYXRjaGVzIHRoZSBwYXRoLCBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICBvbGRPcGVuTGlua1RleHQgJiZcbiAgICAgICAgICAgIG9sZE9wZW5MaW5rVGV4dC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgIGxpbmt0ZXh0LFxuICAgICAgICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAhZm91bmQsXG4gICAgICAgICAgICAgIG9wZW5WaWV3U3RhdGUsXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgb251bmxvYWQoKTogdm9pZCB7XG4gICAgdW5pbnN0YWxsUGF0Y2hPcGVuKClcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcm91bmQob2JqLCBmYWN0b3JpZXMpIHtcbiAgICBjb25zdCByZW1vdmVycyA9IE9iamVjdC5rZXlzKGZhY3RvcmllcykubWFwKGtleSA9PiBhcm91bmQxKG9iaiwga2V5LCBmYWN0b3JpZXNba2V5XSkpO1xuICAgIHJldHVybiByZW1vdmVycy5sZW5ndGggPT09IDEgPyByZW1vdmVyc1swXSA6IGZ1bmN0aW9uICgpIHsgcmVtb3ZlcnMuZm9yRWFjaChyID0+IHIoKSk7IH07XG59XG5mdW5jdGlvbiBhcm91bmQxKG9iaiwgbWV0aG9kLCBjcmVhdGVXcmFwcGVyKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXSwgaGFkT3duID0gb2JqLmhhc093blByb3BlcnR5KG1ldGhvZCk7XG4gICAgbGV0IGN1cnJlbnQgPSBjcmVhdGVXcmFwcGVyKG9yaWdpbmFsKTtcbiAgICAvLyBMZXQgb3VyIHdyYXBwZXIgaW5oZXJpdCBzdGF0aWMgcHJvcHMgZnJvbSB0aGUgd3JhcHBpbmcgbWV0aG9kLFxuICAgIC8vIGFuZCB0aGUgd3JhcHBpbmcgbWV0aG9kLCBwcm9wcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICBpZiAob3JpZ2luYWwpXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjdXJyZW50LCBvcmlnaW5hbCk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHdyYXBwZXIsIGN1cnJlbnQpO1xuICAgIG9ialttZXRob2RdID0gd3JhcHBlcjtcbiAgICAvLyBSZXR1cm4gYSBjYWxsYmFjayB0byBhbGxvdyBzYWZlIHJlbW92YWxcbiAgICByZXR1cm4gcmVtb3ZlO1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGJlZW4gZGVhY3RpdmF0ZWQgYW5kIGFyZSBubyBsb25nZXIgd3JhcHBlZCwgcmVtb3ZlIG91cnNlbHZlc1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gb3JpZ2luYWwgJiYgb2JqW21ldGhvZF0gPT09IHdyYXBwZXIpXG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgcGF0Y2hlcywganVzdCBkbyBhIGRpcmVjdCByZW1vdmFsXG4gICAgICAgIGlmIChvYmpbbWV0aG9kXSA9PT0gd3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKGhhZE93bilcbiAgICAgICAgICAgICAgICBvYmpbbWV0aG9kXSA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gb3JpZ2luYWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEVsc2UgcGFzcyBmdXR1cmUgY2FsbHMgdGhyb3VnaCwgYW5kIHJlbW92ZSB3cmFwcGVyIGZyb20gdGhlIHByb3RvdHlwZSBjaGFpblxuICAgICAgICBjdXJyZW50ID0gb3JpZ2luYWw7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih3cmFwcGVyLCBvcmlnaW5hbCB8fCBGdW5jdGlvbik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZHVwZShrZXksIG9sZEZuLCBuZXdGbikge1xuICAgIGNoZWNrW2tleV0gPSBrZXk7XG4gICAgcmV0dXJuIGNoZWNrO1xuICAgIGZ1bmN0aW9uIGNoZWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChvbGRGbltrZXldID09PSBrZXkgPyBvbGRGbiA6IG5ld0ZuKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXIocHJvbWlzZSwgY2IpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNiLCBjYik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGFzeW5jRnVuY3Rpb24pIHtcbiAgICBsZXQgbGFzdFJ1biA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbGFzdFJ1biA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgYWZ0ZXIobGFzdFJ1biwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzeW5jRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncykudGhlbihyZXMsIHJlaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBwZXIuYWZ0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYXN0UnVuID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7IGFmdGVyKGxhc3RSdW4sIHJlcyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBK0M7OztBQ0F4QyxnQkFBZ0IsS0FBSyxXQUFXO0FBQ25DLFFBQU0sV0FBVyxPQUFPLEtBQUssV0FBVyxJQUFJLFNBQU8sUUFBUSxLQUFLLEtBQUssVUFBVTtBQUMvRSxTQUFPLFNBQVMsV0FBVyxJQUFJLFNBQVMsS0FBSyxXQUFZO0FBQUUsYUFBUyxRQUFRLE9BQUs7QUFBQTtBQUFBO0FBRXJGLGlCQUFpQixLQUFLLFFBQVEsZUFBZTtBQUN6QyxRQUFNLFdBQVcsSUFBSSxTQUFTLFNBQVMsSUFBSSxlQUFlO0FBQzFELE1BQUksVUFBVSxjQUFjO0FBRzVCLE1BQUk7QUFDQSxXQUFPLGVBQWUsU0FBUztBQUNuQyxTQUFPLGVBQWUsU0FBUztBQUMvQixNQUFJLFVBQVU7QUFFZCxTQUFPO0FBQ1Asc0JBQW9CLE1BQU07QUFFdEIsUUFBSSxZQUFZLFlBQVksSUFBSSxZQUFZO0FBQ3hDO0FBQ0osV0FBTyxRQUFRLE1BQU0sTUFBTTtBQUFBO0FBRS9CLG9CQUFrQjtBQUVkLFFBQUksSUFBSSxZQUFZLFNBQVM7QUFDekIsVUFBSTtBQUNBLFlBQUksVUFBVTtBQUFBO0FBRWQsZUFBTyxJQUFJO0FBQUE7QUFFbkIsUUFBSSxZQUFZO0FBQ1o7QUFFSixjQUFVO0FBQ1YsV0FBTyxlQUFlLFNBQVMsWUFBWTtBQUFBO0FBQUE7OztBRDdCbkQsSUFBSTtBQUVKLG9DQUE2Qyx1QkFBTztBQUFBLFFBQzVDLFNBQXdCO0FBQzVCLHlCQUFxQixPQUFPLDBCQUFVLFdBQVc7QUFBQSxNQUUvQyxhQUFhLGlCQUFpQjtBQUM1QixlQUFPLFNBQ0wsVUFDQSxZQUNBLFNBQ0EsZUFDQTtBQUdBLGdCQUFNLE9BQU8sV0FBWSxVQUFTLFNBQVMsU0FBUyxLQUFLO0FBQ3pELGNBQUk7QUFDSixjQUFJLFFBQVE7QUFDWixjQUFJLGFBQWE7QUFDakIsZ0JBQU0sT0FBTyxJQUFJLFVBQVUsZ0JBQWdCO0FBQzNDLG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO0FBQ3BDLGdCQUFJLE9BQU8sS0FBSztBQUNoQixrQkFBTSxZQUFZLEtBQUs7QUFFdkIsZ0JBQUksVUFBVSxTQUFTLFlBQVk7QUFPakMsa0JBQUksVUFBVSxPQUFPLE1BQU0sU0FBUyxhQUFhO0FBQy9DLDZCQUFhO0FBQUE7QUFBQTtBQUFBO0FBTW5CLGNBQUksQ0FBQyxPQUFPO0FBQ1YscUJBQVMsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNqRCxtQkFBSyxHQUFHO0FBQUE7QUFBQTtBQUtaLG1CQUNFLG1CQUNBLGdCQUFnQixNQUFNLE1BQU07QUFBQSxZQUMxQjtBQUFBLFlBQ0E7QUFBQSxZQUNBLENBQUM7QUFBQSxZQUNEO0FBQUE7QUFFSixpQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNZixXQUFpQjtBQUNmO0FBQUE7QUFBQTsiLAogICJuYW1lcyI6IFtdCn0K
