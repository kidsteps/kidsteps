/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZoteroAnnotations
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/constants.ts
var PLAINTEMPLATE = `
# {{title}}

## Metadata
- **CiteKey**: {{citationKey}}
- **Type**: {{itemType}}
- **Title**: {{title}} 
- **Author**: {{author}}  
- **Editor**: {{editor}}  
- **Translator**: {{translator}}
- **Publisher**: {{publisher}}
- **Location**: {{place}}
- **Series**: {{series}}
- **Series Number**: {{seriesNumber}}
- **Journal**: {{publicationTitle}}
- **Volume**: {{volume}}
- **Issue**: {{issue}}
- **Pages**: {{pages}}
- **Year**: {{year}} 
- **DOI**: {{DOI}}
- **ISSN**: {{ISSN}}
- **ISBN**: {{ISBN}}

## Abstract
{{abstractNote}}" +

## Files and Links
- **Url**: {{url}}
- **Uri**: {{uri}}
- **Eprint**: {{eprint}}
- **File**: {{file}}
- **Local Library**: [Zotero]({{localLibraryLink}})

## Tags
- **Keywords**: {{keywordsAll}}

## Notes

## Comments
{{UserNotes}}

## Annotations
{{PDFNotes}}
`;
var DEFAULT_SETTINGS = {
  bibPath: "",
  templateContent: PLAINTEMPLATE,
  templatePath: "",
  templateType: "Admonition",
  lastUpdateDate: new Date("1990-01-01T00:00:00"),
  updateNotes: "Only update existing notes",
  importPath: "",
  importFileName: "@{{citeKey}}",
  importAllAnnotationFiles: true,
  missingfield: "Leave placeholder",
  saveManualEdits: "Overwrite Entire Note",
  saveManualEditsStart: "",
  saveManualEditsEnd: "",
  openAfterImport: false,
  imagesImport: true,
  imagesCopy: false,
  imagesPath: "",
  imagesCommentPosition: "Above the image",
  formatMergeAbove: "+",
  formatCommentPrepend: "%",
  commentPrependDefault: false,
  TagBeginningConfig: "Tag: ",
  TagEndConfig: "",
  TagDividerConfig: "; ",
  formatH1: "#",
  formatH2: "##",
  formatH3: "###",
  formatH4: "####",
  formatH5: "#####",
  formatH6: "######",
  formatKeyword: "=",
  formatTask: "todo",
  isHighlightItalic: true,
  isHighlightBold: false,
  isHighlightHighlighted: false,
  isHighlightBullet: true,
  isHighlightBlockquote: false,
  isHighlightQuote: false,
  highlightCustomTextBefore: "",
  highlightCustomTextAfter: "",
  isCommentItalic: false,
  isCommentBold: true,
  isCommentHighlighted: false,
  isCommentBullet: false,
  isCommentBlockquote: true,
  isCommentQuote: false,
  commentCustomTextBefore: "",
  commentCustomTextAfter: "",
  isTagItalic: false,
  isTagBold: false,
  isTagHighlighted: false,
  isTagBullet: false,
  isTagBlockquote: false,
  isTagQuote: false,
  isTagHash: true,
  tagCustomTextBefore: "#",
  tagCustomTextAfter: "",
  tagCustomTextBeforeFirst: "",
  tagCustomTextAfterLast: "",
  isDoubleSpaced: true,
  highlightExportTemplate: "{{highlight}} {{comment}} {{tag}}",
  multipleFieldsDivider: ",",
  nameFormat: "{{firstName}} {{lastName}}",
  highlightCitationsFormat: "Author, year, page number",
  highlightCitationsLink: true,
  debugMode: false,
  zoteroStoragePathManual: "",
  missingfieldreplacement: "NA"
};
var TEMPLATE_REG = /\{\{[^}]+\}\}/g;
var TEMPLATE_BRACKET_REG = /\[\[\{\{[^}]+\}\}\]\]/g;

// src/modal.ts
var fs3 = __toESM(require("fs"));
var import_obsidian4 = require("obsidian");

// src/notes.ts
var import_obsidian3 = require("obsidian");
var fs2 = __toESM(require("fs"));

// src/annotations.ts
var fs = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var import_path = __toESM(require("path"));
var fragWithHTML = (html) => createFragment((frag) => frag.createDiv().innerHTML = html);
var errorlog = (data) => {
  console.error(__spreadValues({ plugin: "Zotero Annotations" }, data));
};
var resolvePath = function(rawPath) {
  const vaultRoot = this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter ? this.app.vault.adapter.getBasePath() : "/";
  return import_path.default.normalize(import_path.default.resolve(vaultRoot, rawPath));
};
function camelToNormalCase(str) {
  return str.replace(/([A-Z])/g, " $1").replace(/^./, function(str2) {
    return str2.toUpperCase();
  });
}
var getInitials = (string) => {
  let words = string.split(" "), initials = words[0].substring(0, 1).toUpperCase() + ".";
  if (words.length > 1) {
    initials += words[words.length - 1].substring(0, 1).toUpperCase() + ".";
  }
  return initials;
};
function truncate(str, n) {
  var str = str.replace(/(?:https?|ftp):\/\/[\n\S]+/g, "").replace(/[^\x00-\x7F]/g, "");
  return str.length > n ? str.slice(0, n - 1) + "..." : str;
}
function importTemplate(settings) {
  return __async(this, null, function* () {
    const template = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian.normalizePath)(settings.templatePath), "");
    if (template && template instanceof import_obsidian.TFile) {
      const data = yield this.app.vault.read(template);
      return data;
    } else {
      return PLAINTEMPLATE;
    }
  });
}
function replaceAllTemplates(entriesArray, note, selectedEntry) {
  let copy = note.slice();
  for (let z = 0; z < entriesArray.length; z++) {
    const KW = entriesArray[z];
    const KW_Brackets = "{{" + KW + "}}";
    copy = replaceTemplate(copy, KW_Brackets, `${selectedEntry[KW]}`);
  }
  return copy;
}
function escapeRegExp(stringAdd) {
  return stringAdd.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function replaceTemplate(stringAdd, find, replace) {
  return stringAdd.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
var makeWiki = (str) => "[[" + str + "]]";
var makeQuotes = (str) => '"' + str + '"';
var makeTags = (str) => "#" + str;
function removeQuoteFromStart(quote, annotation) {
  let copy = annotation.slice();
  while (copy.charAt(0) === quote)
    copy = copy.substring(1);
  return copy;
}
function removeQuoteFromEnd(quote, annotation) {
  let copy = annotation.slice();
  while (copy[copy.length - 1] === quote)
    copy = copy.substring(0, copy.length - 1);
  return copy;
}
function orderByDateModified(a, b) {
  if (a.dateModified > b.dateModified)
    return -1;
  if (a.dateModified < b.dateModified)
    return 1;
  return 0;
}
function replaceMissingFields(note, missingfield, missingfieldreplacement) {
  let copy = note.slice();
  if (missingfield === "Replace with custom text") {
    copy = copy.replace(TEMPLATE_BRACKET_REG, missingfieldreplacement).trim().replace(TEMPLATE_REG, missingfieldreplacement).trim();
  } else if (missingfield === "Remove (entire row)") {
    const lines = copy.split(/\r?\n/);
    for (let j = 0; j < lines.length; j++) {
      if (lines[j].match(TEMPLATE_REG)) {
        lines.splice(j, 1);
        j--;
      }
    }
    copy = lines.join("\n");
  }
  copy = copy.replace("## Abstract\n\n## Files and Links\n", "## Files and Links\n");
  copy = copy.replace("## Files and Links\n\n## Zotero Tags\n", "## Zotero Tags\n");
  copy = copy.replace("## Zotero Tags\n\n", "\n");
  return copy;
}
function getLocalFileLink(reference) {
  const len_attachments = reference.attachments.length;
  if (len_attachments == 0)
    return "{{localFile}}";
  const filesList = [];
  for (let index = 0; index < len_attachments; index++) {
    if (reference.attachments[index].itemType !== "attachment")
      continue;
    if (reference.attachments[index].path == void 0) {
      reference.attachments[index].path = "";
    }
    const selectedfile = "[" + reference.attachments[index].title + "](file:///" + encodeURI(reference.attachments[index].path.replaceAll(" ", " ")) + ")";
    filesList.push(selectedfile);
  }
  const filesListString = filesList.join("; ");
  return filesListString;
}
function getNoteTitle(selectedEntry, exportTitle) {
  exportTitle = exportTitle.replaceAll("{{citeKey}}", selectedEntry.citationKey).replaceAll("{{citationKey}}", selectedEntry.citationKey).replaceAll("{{title}}", selectedEntry.title).replaceAll("{{author}}", selectedEntry.authorKey).replaceAll("{{authors}}", selectedEntry.authorKey).replaceAll("{{authorInitials}}", selectedEntry.authorKeyInitials).replaceAll("{{authorsInitials}}", selectedEntry.authorKeyInitials).replaceAll("{{authorFullName}}", selectedEntry.authorKeyFullName).replaceAll("{{authorsFullName}}", selectedEntry.authorKeyFullName).replaceAll("{{year}}", selectedEntry.year).replaceAll("{{date}}", selectedEntry.year).replace(/[/\\?%*:|"<>]/g, "");
  return exportTitle;
}
function createNotePath(noteTitle, exportPath) {
  return resolvePath(`${exportPath}/${noteTitle}.md`);
}
function insertKeywordList(selectedEntry, arrayExtractedKeywords, metadata, divider) {
  selectedEntry.zoteroTags = [];
  if (selectedEntry.tags.length > 0) {
    for (let indexTag = 0; indexTag < selectedEntry.tags.length; indexTag++) {
      selectedEntry.zoteroTags.push(selectedEntry.tags[indexTag].tag);
    }
  }
  if (divider.slice(-1) !== " ")
    divider = divider + " ";
  const tagsZotero = selectedEntry.zoteroTags.sort();
  const tagsPDF = arrayExtractedKeywords.sort();
  const tagsCombined = tagsZotero.concat(tagsPDF).sort();
  if (tagsZotero.length > 0) {
    const tagsZoteroBracket = tagsZotero.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywordsZotero}}]]`, String(tagsZoteroBracket.join(divider)));
    const tagsZoteroQuotes = tagsZotero.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsZotero}}"`, String(tagsZoteroQuotes.join(divider)));
    const tagsZoteroTags = tagsZotero.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsZotero}}`, String(tagsZoteroTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsZotero}}`, String(tagsZotero.join(divider)));
  }
  if (tagsPDF.length > 0) {
    const tagsPDFBracket = tagsPDF.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywordsPDF}}]]`, String(tagsPDFBracket.join(divider)));
    const tagsPDFQuotes = tagsPDF.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsPDF}}"`, String(tagsPDFQuotes.join(divider)));
    const tagsPDFTags = tagsPDF.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsPDF}}`, String(tagsPDFTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsPDF}}`, String(tagsPDF.join(divider)));
  }
  if (tagsCombined.length > 0) {
    const tagsCombinedBracket = tagsCombined.map(makeWiki);
    metadata = replaceTemplate(metadata, `[[{{keywords}}]]`, String(tagsCombinedBracket.join(divider)));
    metadata = replaceTemplate(metadata, `[[{{keywordsAll}}]]`, String(tagsCombinedBracket.join(divider)));
    const tagsCombinedQuotes = tagsCombined.map(makeQuotes);
    metadata = replaceTemplate(metadata, `"{{keywordsAll}}"`, String(tagsCombinedQuotes.join(divider)));
    metadata = replaceTemplate(metadata, `"{{keywords}}"`, String(tagsCombinedQuotes.join(divider)));
    const tagsCombinedTags = tagsCombined.map(makeTags);
    metadata = replaceTemplate(metadata, `#{{keywordsAll}}`, String(tagsCombinedTags.join(divider)));
    metadata = replaceTemplate(metadata, `#{{keywords}}`, String(tagsCombinedTags.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywordsAll}}`, String(tagsCombined.join(divider)));
    metadata = replaceTemplate(metadata, `{{keywords}}`, String(tagsCombined.join(divider)));
  }
  if (selectedEntry.zoteroTags.length == 0) {
    metadata = metadata.replace("# Tags\n", "");
    metadata = metadata.replace("## Tags\n", "");
    metadata = metadata.replace("### Tags\n", "");
  }
  return metadata;
}
function getZoteroAppInfo(selectedEntry, settings) {
  if (selectedEntry.attachments[0] !== void 0) {
    let pathZoteroStorage = "";
    let zoteroBuildWindows = void 0;
    const zoteroStorageMac = new RegExp(/.+?(?=Zotero\/storage)Zotero\/storage\//gm);
    if (zoteroStorageMac.test(selectedEntry.attachments[0].path)) {
      pathZoteroStorage = String(selectedEntry.attachments[0].path.match(zoteroStorageMac));
      zoteroBuildWindows = false;
    }
    const zoteroStorageWindows = new RegExp(/.+?(?=Zotero\\storage\\)Zotero\\storage\\/gm);
    if (zoteroStorageWindows.test(selectedEntry.attachments[0].path)) {
      pathZoteroStorage = String(selectedEntry.attachments[0].path.match(zoteroStorageWindows));
      zoteroBuildWindows = true;
    }
    if (pathZoteroStorage.length == 0 && settings.zoteroStoragePathManual.length > 0) {
      pathZoteroStorage = settings.zoteroStoragePathManual;
      if (pathZoteroStorage.toLowerCase().endsWith("\\zotero"))
        pathZoteroStorage = pathZoteroStorage + "\\storage\\";
      if (pathZoteroStorage.toLowerCase().endsWith("\\zotero\\"))
        pathZoteroStorage = pathZoteroStorage + "storage\\";
      if (pathZoteroStorage.toLowerCase().endsWith("/zotero"))
        pathZoteroStorage = pathZoteroStorage + "/storage/";
      if (pathZoteroStorage.toLowerCase().endsWith("/zotero/"))
        pathZoteroStorage = pathZoteroStorage + "storage/";
    }
    const zoteroInfo = {
      pathZoteroStorage,
      zoteroBuildWindows
    };
    return zoteroInfo;
  }
}

// src/annotations.ts
function createFormatting(settings) {
  const {
    highlightCustomTextAfter,
    highlightCustomTextBefore,
    isCommentItalic,
    isCommentBold,
    isCommentHighlighted,
    isCommentBullet,
    isCommentBlockquote,
    isCommentQuote,
    commentCustomTextAfter,
    commentCustomTextBefore,
    isHighlightItalic,
    isHighlightBold,
    isHighlightHighlighted,
    isHighlightBullet,
    isHighlightBlockquote,
    isHighlightQuote,
    tagCustomTextAfter,
    tagCustomTextBefore,
    isTagItalic,
    isTagBold,
    isTagHighlighted,
    isTagBullet,
    isTagBlockquote,
    isTagQuote,
    isTagHash
  } = settings;
  const [
    highlightItalic,
    highlightBold,
    highlightHighlighted,
    highlightBullet,
    highlightBlockquote,
    highlightQuoteOpen,
    highlightQuoteClose
  ] = [
    isHighlightItalic ? "*" : "",
    isHighlightBold ? "**" : "",
    isHighlightHighlighted ? "==" : "",
    isHighlightBullet ? "- " : "",
    isHighlightBlockquote ? "> " : "",
    isHighlightQuote ? "\u201C" : "",
    isHighlightQuote ? "\u201D" : ""
  ];
  const highlightFormatBefore = highlightHighlighted + highlightBold + highlightItalic + highlightQuoteOpen;
  const highlightFormatAfter = highlightQuoteClose + highlightItalic + highlightBold + highlightHighlighted + highlightCustomTextAfter;
  let highlightPrepend = "";
  if (highlightBullet != "" || highlightBlockquote != "") {
    highlightPrepend = "\n" + highlightBullet + highlightBlockquote + highlightCustomTextBefore;
  }
  const commentItalic = isCommentItalic ? "*" : "";
  const commentBold = isCommentBold ? "**" : "";
  const commentHighlighted = isCommentHighlighted ? "==" : "";
  const commentBullet = isCommentBullet ? "- " : "";
  const commentBlockquote = isCommentBlockquote ? "> " : "";
  const commentQuoteOpen = isCommentQuote ? "\u201C" : "";
  const commentQuoteClose = isCommentQuote ? "\u201D" : "";
  const commentFormatBefore = commentHighlighted + commentBold + commentItalic + commentQuoteOpen;
  const commentFormatAfter = commentQuoteClose + commentItalic + commentBold + commentHighlighted + commentCustomTextAfter;
  let commentPrepend = "";
  if (commentBullet != "" || commentBlockquote != "") {
    commentPrepend = "\n" + commentBullet + commentBlockquote + commentCustomTextBefore;
  }
  const [
    tagHash,
    tagItalic,
    tagBold,
    tagHighlighted,
    tagBullet,
    tagBlockquote,
    tagQuoteOpen,
    tagQuoteClose
  ] = [
    isTagHash ? "#" : "",
    isTagItalic ? "*" : "",
    isTagBold ? "**" : "",
    isTagHighlighted ? "==" : "",
    isTagBullet ? "- " : "",
    isTagBlockquote ? "> " : "",
    isTagQuote ? "\u201C" : "",
    isTagQuote ? "\u201D" : ""
  ];
  const tagFormatBefore = tagHash + tagHighlighted + tagBold + tagItalic + tagQuoteOpen;
  const tagFormatAfter = tagQuoteClose + tagItalic + tagBold + tagHighlighted + tagCustomTextAfter;
  let tagPrepend = "";
  if (tagBullet != "" || tagBlockquote != "") {
    tagPrepend = "\n" + tagBullet + tagBlockquote + tagCustomTextBefore;
  } else {
    tagPrepend = tagBullet + tagBlockquote + tagCustomTextBefore;
  }
  return {
    highlightFormatBefore,
    highlightFormatAfter,
    highlightPrepend,
    commentFormatBefore,
    commentFormatAfter,
    commentPrepend,
    tagFormatBefore,
    tagFormatAfter,
    tagPrepend
  };
}
function formatAnnotationElements(noteElements, citeKey, settings, zoteroInfo) {
  const { isDoubleSpaced } = settings;
  const {
    commentFormatAfter,
    commentFormatBefore,
    commentPrepend,
    highlightFormatAfter,
    highlightFormatBefore,
    highlightPrepend,
    tagFormatBefore,
    tagFormatAfter,
    tagPrepend
  } = createFormatting(settings);
  const indexRowsToBeRemoved = [];
  const noteElementsArray = [];
  const keywordArray = [];
  const rowEditedArray = [];
  const imagesArray = [];
  noteElements = noteElements.filter((x) => x !== void 0);
  for (let i = 0; i < noteElements.length; i++) {
    let allAreEmpty = function(arr) {
      return arr.every((element) => element == "");
    };
    let lineElements = noteElements[i];
    if (lineElements.extractionSource === "zotero" || lineElements.extractionSource === "zotfile") {
      if (settings.highlightCitationsFormat === "Only page number" && lineElements.pageLabel !== void 0) {
        lineElements.citeKey = "" + lineElements.pageLabel;
      } else if (settings.highlightCitationsFormat === "Pandoc" && lineElements.pageLabel !== void 0) {
        lineElements.citeKey = "[@" + citeKey + ", Page: " + lineElements.pageLabel + "]";
      } else if (settings.highlightCitationsFormat === "Pandoc" && lineElements.pageLabel === void 0) {
        lineElements.citeKey = "[@" + citeKey + "]";
      } else if (settings.highlightCitationsFormat === "Empty" && lineElements.pageLabel !== void 0) {
        lineElements.citeKey = " ";
      }
    }
    if (settings.highlightCitationsLink === true && lineElements.zoteroBackLink.length > 0) {
      if (settings.highlightCitationsFormat !== "Pandoc") {
        lineElements.citeKey = "[" + lineElements.citeKey + "](" + lineElements.zoteroBackLink + ")";
        lineElements.zoteroBackLink = " [" + lineElements.pagePDF + "](" + lineElements.zoteroBackLink + ")";
      } else {
        lineElements.citeKey = lineElements.citeKey + " [" + lineElements.pagePDF + "](" + lineElements.zoteroBackLink + ")";
        lineElements.zoteroBackLink = " [" + lineElements.pagePDF + "](" + lineElements.zoteroBackLink + ")";
      }
    } else {
      lineElements.zoteroBackLink = "";
    }
    let colourTextBefore = lineElements.colourTextBefore;
    if (colourTextBefore == void 0) {
      colourTextBefore = "";
    }
    let colourTextAfter = lineElements.colourTextAfter;
    if (colourTextAfter == void 0) {
      colourTextAfter = "";
    }
    if (lineElements.highlightText === "Extracted Annotations") {
      lineElements.annotationType = "typeExtractedHeading";
    }
    if (lineElements.annotationType === "typeExtractedHeading") {
      lineElements.rowEdited = "**" + lineElements.rowOriginal.toUpperCase() + "**";
    }
    if (lineElements.highlightText != "") {
      lineElements.highlightFormatted = highlightPrepend + highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + " " + lineElements.citeKey + " ";
      lineElements.highlightFormattedNoPrepend = highlightFormatBefore + lineElements.highlightText + highlightFormatAfter + " " + lineElements.citeKey + " ";
    } else {
      lineElements.highlightFormatted = "";
      lineElements.highlightFormattedNoPrepend = "";
    }
    if (lineElements.commentText != "" && lineElements.highlightText != "") {
      lineElements.commentFormatted = commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter + " ";
      lineElements.commentFormattedNoPrepend = commentFormatBefore + lineElements.commentText + commentFormatAfter + " ";
    } else if (lineElements.commentText != "" && lineElements.highlightText == "") {
      lineElements.commentFormatted = commentPrepend + commentFormatBefore + lineElements.commentText + commentFormatAfter + " " + lineElements.zoteroBackLink + " ";
      lineElements.commentFormattedNoPrepend = commentFormatBefore + lineElements.commentText + commentFormatAfter + " " + lineElements.zoteroBackLink + " ";
    } else {
      lineElements.commentFormatted = "";
      lineElements.commentFormattedNoPrepend = "";
    }
    if (typeof lineElements.inlineTagsArray == "undefined") {
      lineElements.inlineTagsArray = [];
    }
    if (settings.isTagHash == true) {
      for (let index = 0; index < lineElements.inlineTagsArray.length; index++) {
        lineElements.inlineTagsArray[index] = lineElements.inlineTagsArray[index].replace(/ /g, "");
      }
    }
    const TempTag = lineElements.inlineTagsArray.map(
      (i2) => tagPrepend + tagFormatBefore + i2 + tagFormatAfter
    );
    for (let index = 0; index < TempTag.length; index++) {
      TempTag[index] = TempTag[index].replace("##", "#");
    }
    const TempTagNoPrepend = lineElements.inlineTagsArray.map(
      (i2) => tagFormatBefore + i2 + tagFormatAfter
    );
    for (let index = 0; index < TempTagNoPrepend.length; index++) {
      TempTagNoPrepend[index] = TempTagNoPrepend[index].replace(
        "##",
        "#"
      );
    }
    if (allAreEmpty(lineElements.inlineTagsArray) == false) {
      lineElements.inlineTagsFormatted = TempTag.join(" ");
      lineElements.inlineTagsFormattedNoPrepend = TempTagNoPrepend.join(" ");
    } else {
      lineElements.inlineTagsFormatted = "";
      lineElements.inlineTagsFormattedNoPrepend = "";
    }
    if (typeof lineElements.colourTemplate == "undefined") {
      lineElements.colourTemplate = settings.highlightExportTemplate;
    }
    if (lineElements.colourTemplate.length == 0) {
      lineElements.colourTemplate = "";
    }
    lineElements.colourTemplateFormatted = lineElements.colourTemplate.replace(
      "{{highlight}}",
      lineElements.highlightFormatted
    );
    lineElements.colourTemplateFormatted = lineElements.colourTemplateFormatted.replace(
      "{{comment}}",
      lineElements.commentFormatted
    );
    lineElements.colourTemplateFormatted = lineElements.colourTemplateFormatted.replace(
      "{{tag}}",
      lineElements.inlineTagsFormatted
    );
    lineElements.colourTemplateFormatted = lineElements.colourTemplateFormatted.replace(/^\s+/g, "");
    lineElements.colourTemplateNoPrepend = lineElements.colourTemplate.replace(
      "{{highlight}}",
      lineElements.highlightFormattedNoPrepend
    );
    lineElements.colourTemplateNoPrepend = lineElements.colourTemplateNoPrepend.replace(
      "{{comment}}",
      lineElements.commentFormattedNoPrepend
    );
    lineElements.colourTemplateNoPrepend = lineElements.colourTemplateNoPrepend.replace(
      "{{tag}}",
      lineElements.inlineTagsFormattedNoPrepend
    );
    lineElements.colourTemplateNoPrepend = lineElements.colourTemplateNoPrepend.replace(/^\s+/g, "");
    if (lineElements.annotationType === "noFormat") {
      lineElements.rowEdited = lineElements.colourTemplateFormatted;
    }
    if (lineElements.annotationType === "typeImage") {
      lineElements.rowEdited = "";
      let pathImageOld = "";
      let pathImageNew = "";
      if (settings.imagesImport) {
        pathImageOld = import_path2.default.format({
          dir: zoteroInfo.pathZoteroStorage + lineElements.imagePath,
          base: "image.png"
        });
        if (settings.zoteroStoragePathManual.length > 0) {
          pathImageOld = import_path2.default.format({
            dir: settings.zoteroStoragePathManual + lineElements.imagePath,
            base: "image.png"
          });
        }
        pathImageNew = import_path2.default.normalize(
          import_path2.default.format({
            dir: (0, import_obsidian2.normalizePath)(resolvePath(settings.imagesPath)),
            base: citeKey + "_" + lineElements.imagePath + ".png"
          })
        );
        if (zoteroInfo.zoteroBuildWindows == false) {
          pathImageNew = "/" + pathImageNew;
        }
        if (fs.existsSync(pathImageOld)) {
          if (settings.imagesCopy === false) {
            lineElements.rowEdited = "![image](file://" + encodeURI(pathImageOld) + ")" + lineElements.zoteroBackLink;
          } else {
            if (!fs.existsSync(pathImageNew)) {
              fs.copyFile(
                pathImageOld,
                pathImageNew,
                (err) => {
                  if (err)
                    throw err;
                }
              );
            }
            lineElements.rowEdited = `![[${citeKey}_${lineElements.imagePath}.png]] ${lineElements.citeKey}`;
          }
        } else {
          new import_obsidian2.Notice(
            `Cannot find image at "${pathImageOld}". Provide the correct zotero data directory location in the settings`
          );
        }
      }
      if (lineElements.commentText.length > 0) {
        if (settings.imagesCommentPosition == "Below the image") {
          lineElements.rowEdited = lineElements.rowEdited + "\n\n" + lineElements.commentFormatted + lineElements.inlineTagsFormatted;
        } else {
          lineElements.rowEdited = lineElements.commentFormatted + lineElements.inlineTagsFormatted + "\n\n" + lineElements.rowEdited;
        }
      }
    }
    if (lineElements.annotationType === "typeMergeAbove") {
      noteElements[i].rowEdited = noteElements[i - 1].rowEdited.replace(/\[.*\)/, "").replace(/\s+$/g, "") + " " + lineElements.highlightFormattedNoPrepend.replace(/^\s+/g, "") + lineElements.commentFormatted + lineElements.inlineTagsFormatted;
      indexRowsToBeRemoved.push(i - 1);
    }
    if (settings.commentPrependDefault === true && lineElements.highlightText !== "" && lineElements.commentText !== "") {
      lineElements.annotationType = "typeCommentPrepend";
    }
    if (lineElements.annotationType === "typeCommentPrepend") {
      lineElements.rowEdited = highlightPrepend + lineElements.commentFormattedNoPrepend + lineElements.highlightFormattedNoPrepend + lineElements.inlineTagsFormatted;
    }
    if (/typeH\d/.test(lineElements.annotationType)) {
      const lastChar = lineElements.annotationType[lineElements.annotationType.length - 1];
      const level = parseInt(lastChar);
      const hashes = "#".repeat(level);
      lineElements.rowEdited = `${hashes} ` + lineElements.highlightText + lineElements.commentText + lineElements.zoteroBackLink + lineElements.inlineTagsFormatted;
    }
    if (lineElements.annotationType == "typeTask") {
      lineElements.rowEdited = `- [ ] ` + lineElements.colourTemplateNoPrepend;
    }
    if (lineElements.annotationType === "typeKeyword") {
      keywordArray.push(lineElements.highlightText);
      lineElements.rowEdited = "";
      indexRowsToBeRemoved.push(i);
    }
    noteElementsArray.push(lineElements);
  }
  if (indexRowsToBeRemoved.length) {
    for (let index = indexRowsToBeRemoved.length - 1; index >= 0; index--) {
      noteElementsArray.splice(indexRowsToBeRemoved[index], 1);
    }
  }
  for (let index = 0; index < noteElementsArray.length; index++) {
    const selectedLine = noteElementsArray[index];
    rowEditedArray.push(selectedLine.rowEdited);
    if (selectedLine.annotationType === "typeImage") {
      imagesArray.push(selectedLine.rowEdited);
    }
  }
  if (isDoubleSpaced) {
    for (let index = rowEditedArray.length - 1; index >= 0; index--) {
      rowEditedArray.splice(index, 0, "");
    }
  }
  const resultsLineElements = {
    rowEditedArray,
    keywordArray,
    imagesArray,
    noteElements
  };
  return resultsLineElements;
}

// src/creators.ts
var getCreatorKey = (creators) => {
  const authorKey = [];
  const editorKey = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    const isFirstName = creator.hasOwnProperty("firstName");
    const isLastName = creator.hasOwnProperty("lastName");
    if (creator.creatorType === "author") {
      if (creator.hasOwnProperty("name"))
        authorKey.push(creator.name);
      else if (isLastName && isFirstName)
        authorKey.push(creator.lastName);
      else if (isLastName && !isFirstName)
        authorKey.push(creator.lastName);
      else if (!isLastName && isFirstName)
        authorKey.push(creator.firstName);
    } else if (creator.creatorType === "editor") {
      if (creator.hasOwnProperty("name"))
        editorKey.push(creator.name);
      else if (isLastName && isFirstName)
        editorKey.push(creator.lastName);
      else if (isLastName && !isFirstName)
        editorKey.push(creator.lastName);
      else if (!isLastName && isFirstName)
        editorKey.push(creator.firstName);
    }
  }
  if (authorKey.length == 1)
    authorKeyFixed = authorKey[0];
  if (authorKey.length == 2)
    authorKeyFixed = authorKey[0] + " and " + authorKey[1];
  if (authorKey.length == 3)
    authorKeyFixed = authorKey[0] + ", " + authorKey[1] + " and " + authorKey[2];
  if (authorKey.length > 3)
    authorKeyFixed = authorKey[0] + " et al.";
  if (authorKey.length > 0)
    return authorKeyFixed;
  if (editorKey.length == 1)
    editorKeyFixed = editorKey[0];
  if (editorKey.length == 2)
    editorKeyFixed = editorKey[0] + " and " + editorKey[1];
  if (editorKey.length == 3)
    editorKeyFixed = editorKey[0] + ", " + editorKey[1] + " and " + editorKey[2];
  if (authorKey.length > 3)
    editorKeyFixed = editorKey[0] + " et al.";
  if (editorKey.length > 0)
    return editorKeyFixed;
};
var getCreatorFullNames = (creators) => {
  const authorKey = [];
  const authorKeyReverse = [];
  const editorKey = [];
  const editorKeyReverse = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    const isFirstName = creator.hasOwnProperty("firstName");
    const isLastName = creator.hasOwnProperty("lastName");
    if (creator.creatorType === "author") {
      if (creator.hasOwnProperty("name")) {
        authorKey.push(creator.name);
      } else if (isLastName && isFirstName) {
        authorKey.push(creator.lastName + ", " + creator.firstName);
        authorKeyReverse.push(creator.firstName + " " + creator.lastName);
      } else if (isLastName && !isFirstName) {
        authorKey.push(creator.lastName);
      } else if (!isLastName && isFirstName) {
        authorKey.push(creator.firstName);
      }
    } else if (creator.creatorType === "editor") {
      if (creator.hasOwnProperty("name")) {
        editorKey.push(creator.name);
      } else if (isLastName && isFirstName) {
        editorKey.push(creator.lastName + ", " + creator.firstName);
        editorKeyReverse.push(creator.firstName + " " + creator.lastName);
      } else if (isLastName && !isFirstName) {
        editorKey.push(creator.lastName);
      } else if (!isLastName && isFirstName) {
        editorKey.push(creator.firstName);
      }
    }
  }
  if (authorKey.length == 1) {
    authorKeyFixed = authorKey[0];
  }
  if (authorKey.length == 2) {
    authorKeyFixed = authorKey[0] + " and " + authorKeyReverse[1];
  }
  if (authorKey.length >= 3) {
    authorKeyFixed = authorKey[0] + " et al.";
  }
  if (authorKey.length > 0) {
    return authorKeyFixed;
  }
  if (editorKey.length == 1) {
    editorKeyFixed = editorKey[0];
  }
  if (editorKey.length == 2) {
    editorKeyFixed = editorKey[0] + " and " + editorKeyReverse[1];
  }
  if (authorKey.length >= 3) {
    editorKeyFixed = editorKey[0] + " et al.";
  }
  if (editorKey.length > 0) {
    return editorKeyFixed;
  }
};
var getCreatorFullInitials = (creators) => {
  const authorKey = [];
  const editorKey = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    const isFirstName = creator.hasOwnProperty("firstName");
    const isLastName = creator.hasOwnProperty("lastName");
    if (creator.creatorType === "author") {
      if (creator.hasOwnProperty("name"))
        authorKey.push(creator.name);
      else if (isLastName && isFirstName)
        authorKey.push(creator.lastName + ", " + creator.firstName.substring(0, 1) + ".");
      else if (isLastName && !isFirstName)
        authorKey.push(creator.lastName);
      else if (!isLastName && isFirstName)
        authorKey.push(creator.firstName);
    } else if (creator.creatorType === "editor") {
      if (creator.hasOwnProperty("name"))
        editorKey.push(creator.name);
      else if (isLastName && isFirstName)
        editorKey.push(creator.lastName + ", " + creator.firstName.substring(0, 1) + ".");
      else if (isLastName && !isFirstName)
        editorKey.push(creator.lastName);
      else if (!isLastName && isFirstName)
        editorKey.push(creator.firstName);
    }
  }
  if (authorKey.length == 1)
    authorKeyFixed = authorKey[0];
  if (authorKey.length == 2)
    authorKeyFixed = authorKey[0] + " and " + authorKey[1];
  if (authorKey.length == 3)
    authorKeyFixed = authorKey[0] + ", " + authorKey[1] + " and " + authorKey[2];
  if (authorKey.length > 3)
    authorKeyFixed = authorKey[0] + " et al.";
  if (authorKey.length > 0)
    return authorKeyFixed;
  if (editorKey.length == 1)
    editorKeyFixed = editorKey[0];
  if (editorKey.length == 2)
    editorKeyFixed = editorKey[0] + " and " + editorKey[1];
  if (editorKey.length == 3)
    editorKeyFixed = editorKey[0] + ", " + editorKey[1] + " and " + editorKey[2];
  if (authorKey.length > 3)
    editorKeyFixed = editorKey[0] + " et al.";
  if (editorKey.length > 0)
    return editorKeyFixed;
};
var arrangeCreatorName = (creator, customName) => {
  const isFirstName = creator.hasOwnProperty("firstName");
  const isLastName = creator.hasOwnProperty("lastName");
  if (creator.hasOwnProperty("name")) {
    return creator.name.trim();
  } else if (isLastName && isFirstName) {
    return customName.replace("{{lastName}}", creator.lastName).replace("{{firstName}}", creator.firstName).replace("{{firstNameInitials}}", getInitials(creator.firstName)).trim();
  } else if (isLastName && !isFirstName) {
    return customName.replace("{{lastName}}", creator.lastName).replace("{{firstName}}", "").trim();
  } else if (!isLastName && isFirstName) {
    return customName.replace("{{lastName}}", "").replace("{{firstName}}", creator.firstName).trim();
  }
};
var insertCreatorList = (creators, typeCreator, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (creator.creatorType === typeCreator) {
      creatorList.push(arrangeCreatorName(creator, nameFormat));
    }
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ")
    divider = divider + " ";
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(note, `[[{{${typeCreator}}}]]`, creatorListBracket.join(divider));
    note = replaceTemplate(note, `"{{${typeCreator}}}"`, creatorListQuotes.join(divider));
    note = replaceTemplate(note, `{{${typeCreator}}}`, creatorList.join(divider));
    return note;
  }
};
var insertCreatorAllList = (creators, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    creatorList.push(arrangeCreatorName(creator, nameFormat));
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ")
    divider = divider + " ";
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(note, `[[{{creator}}]]`, creatorListBracket.join(divider));
    note = replaceTemplate(note, `"{{creator}}"`, creatorListQuotes.join(divider));
    note = replaceTemplate(note, `{{creator}}`, creatorList.join(divider));
    return note;
  }
};

// src/parser.ts
function getAnnotationType(annotationCommentFirstWord, annotationCommentAll, settings) {
  const {
    formatMergeAbove,
    formatCommentPrepend,
    formatH1,
    formatH2,
    formatH3,
    formatH4,
    formatH5,
    formatH6,
    formatKeyword,
    formatTask
  } = settings;
  annotationCommentFirstWord = annotationCommentFirstWord.toLowerCase();
  let annotationType = "noFormat";
  switch (annotationCommentFirstWord) {
    case formatMergeAbove.toLowerCase():
      annotationType = "typeMergeAbove";
      break;
    case formatCommentPrepend.toLowerCase():
      annotationType = "typeCommentPrepend";
      break;
    case formatH1.toLowerCase():
      annotationType = "typeH1";
      break;
    case formatH2.toLowerCase():
      annotationType = "typeH2";
      break;
    case formatH3.toLowerCase():
      annotationType = "typeH3";
      break;
    case formatH4.toLowerCase():
      annotationType = "typeH4";
      break;
    case formatH5.toLowerCase():
      annotationType = "typeH5";
      break;
    case formatH6.toLowerCase():
      annotationType = "typeH6";
      break;
    default:
      annotationType = "noFormat";
  }
  switch (annotationCommentAll) {
    case formatH1.toLowerCase():
      annotationType = "typeH1";
      break;
    case formatH2.toLowerCase():
      annotationType = "typeH2";
      break;
    case formatH3.toLowerCase():
      annotationType = "typeH3";
      break;
    case formatH4.toLowerCase():
      annotationType = "typeH4";
      break;
    case formatH5.toLowerCase():
      annotationType = "typeH5";
      break;
    case formatH6.toLowerCase():
      annotationType = "typeH6";
      break;
    case formatKeyword.toLowerCase():
      annotationType = "typeKeyword";
      break;
    case formatTask.toLowerCase():
      annotationType = "typeTask";
      break;
  }
  if (annotationCommentAll === formatMergeAbove)
    annotationType = "typeMergeAbove";
  if (annotationCommentFirstWord === formatKeyword.toLowerCase())
    annotationType = "typeKeyword";
  if (annotationCommentFirstWord === formatTask.toLowerCase())
    annotationType = "typeTask";
  return annotationType;
}
function getExtractionType(note) {
  let extractionType = "Other";
  if (note.includes("<span class="))
    extractionType = "Zotero";
  if (note.includes('<a href="zotero://open-pdf/library/'))
    extractionType = "Zotfile";
  if (note.includes("div data-schema-version"))
    extractionType = "UserNote";
  return extractionType;
}
function collectAnnotations(note, settings) {
  note = note.replaceAll("$&", "$ &");
  const extractionType = getExtractionType(note);
  let noteElementsSingle = [];
  if (extractionType === "Zotero") {
    noteElementsSingle = parseAnnotationLinesintoElementsZotero(note, settings);
  }
  if (extractionType === "Zotfile") {
    noteElementsSingle = parseAnnotationLinesintoElementsZotfile(note, settings);
  }
  if (extractionType === "UserNote" || extractionType === "Other") {
    noteElementsSingle = parseAnnotationLinesintoElementsUserNote(note);
  }
  return {
    noteElementsSingle,
    extractionType
  };
}
function extractAnnotation(selectedEntry, settings) {
  let extractedAnnotations = "";
  let extractedImages = "";
  let extractedUserNote = "";
  let keywordArray = [];
  let noteElements = [];
  let userNoteElements = [];
  let indexNote = 0;
  const zoteroInfo = getZoteroAppInfo(selectedEntry, settings);
  function concatNotes(note) {
    const noteElementsSingle = collectAnnotations(note, settings).noteElementsSingle;
    const extractionType = collectAnnotations(note, settings).extractionType;
    if (extractionType === "Zotero" || extractionType === "Zotfile") {
      noteElements = noteElements.concat(noteElementsSingle);
    } else if (extractionType === "UserNote" || extractionType === "Other") {
      userNoteElements = userNoteElements.concat(noteElementsSingle);
    }
  }
  if (selectedEntry.notes.length > 0) {
    if (settings.importAllAnnotationFiles) {
      for (indexNote = 0; indexNote < selectedEntry.notes.length; indexNote++) {
        let note = selectedEntry.notes[indexNote].note;
        concatNotes(note);
      }
    } else {
      let indexNote2 = selectedEntry.notes.length - 1;
      let note = selectedEntry.notes[indexNote2].note;
      concatNotes(note);
    }
    const resultsLineElements = formatAnnotationElements(
      noteElements,
      selectedEntry.citationKey,
      settings,
      zoteroInfo
    );
    keywordArray = resultsLineElements.keywordArray;
    extractedAnnotations = resultsLineElements.rowEditedArray.join("\n");
    extractedImages = resultsLineElements.imagesArray.join("\n");
    const extractedUserNoteArray = Array.from(
      Object.values(userNoteElements),
      (note) => note.rowEdited
    );
    extractedUserNote = extractedUserNoteArray.join("\n");
  }
  const extractedNote = {
    extractedAnnotations,
    extractedUserNote,
    extractedKeywords: keywordArray,
    extractedImages,
    noteElements
  };
  return extractedNote;
}
function parseMetadata(selectedEntry, settings, templateOriginal) {
  const template = templateOriginal;
  let note = template;
  note = insertCreatorList(
    selectedEntry.creators,
    "author",
    note,
    settings.multipleFieldsDivider,
    settings.nameFormat
  );
  note = insertCreatorList(
    selectedEntry.creators,
    "editor",
    note,
    settings.multipleFieldsDivider,
    settings.nameFormat
  );
  note = insertCreatorAllList(
    selectedEntry.creators,
    note,
    settings.multipleFieldsDivider,
    settings.nameFormat
  );
  if (selectedEntry.hasOwnProperty("date")) {
    selectedEntry.year = selectedEntry.date.match(/\d\d\d\d/gm) + "";
  }
  if (selectedEntry.hasOwnProperty("select")) {
    selectedEntry.localLibrary = "[Zotero](" + selectedEntry.select + ")";
    selectedEntry.localLibraryLink = selectedEntry.select;
  }
  selectedEntry.itemType = camelToNormalCase(selectedEntry.itemType);
  selectedEntry.citationInLine = `${getCreatorKey(selectedEntry.creators)} (${selectedEntry.year})`;
  selectedEntry.citationInLine = selectedEntry.citationInLine.replace("()", "");
  selectedEntry.citationInLineInitials = `${getCreatorFullInitials(selectedEntry.creators)} (${selectedEntry.year})`;
  selectedEntry.citationInLineInitials = selectedEntry.citationInLineInitials.replace("()", "");
  selectedEntry.citationInLineFullName = `${getCreatorFullNames(selectedEntry.creators)} (${selectedEntry.year})`;
  selectedEntry.citationInLineFullName = selectedEntry.citationInLineFullName.replace("()", "");
  if (selectedEntry.itemType == "Journal Article") {
    selectedEntry.citationShort = `${selectedEntry.citationInLine} '${selectedEntry.title}'`;
    selectedEntry.citationFull = `${selectedEntry.citationShort}, *${selectedEntry.publicationTitle}*, ${selectedEntry.volume}(${selectedEntry.issue}), pp. ${selectedEntry.pages}.`;
    selectedEntry.citationFull = selectedEntry.citationFull.replace("() ", "");
    selectedEntry.citationShort = selectedEntry.citationShort.replace("** ", "");
    selectedEntry.citationFull = selectedEntry.citationFull.replace("** ", "");
    selectedEntry.citationFull = selectedEntry.citationFull.replace("pp. ", "");
  }
  selectedEntry.file = getLocalFileLink(selectedEntry);
  const entriesArray = Object.keys(selectedEntry);
  note = replaceAllTemplates(entriesArray, note, selectedEntry);
  note = note.replace(/```/g, "HEREISAPLACEHOLDERFORBACKTICK");
  note = note.replace(/`/g, "'");
  note = note.replace(/HEREISAPLACEHOLDERFORBACKTICK/g, "```");
  return note;
}
function parseAnnotationLinesintoElementsZotfile(note, settings) {
  const lines = note.split(/<p>/gm);
  const noteElements = [];
  for (let indexLines = 0; indexLines < lines.length; indexLines++) {
    const selectedLineOriginal = lines[indexLines];
    const selectedLine = selectedLineOriginal.replace(/<\/?[^>]+(>|$)/g, "");
    if (selectedLine === "")
      continue;
    const lineElements = {
      highlightText: "",
      highlightColour: "",
      annotationType: "",
      citeKey: "",
      commentText: "",
      rowOriginal: selectedLine,
      rowEdited: selectedLine,
      indexNote: void 0,
      foundOld: void 0,
      positionOld: void 0,
      extractionSource: "zotfile",
      colourTextAfter: "",
      colourTextBefore: "",
      imagePath: "",
      pagePDF: 0,
      pageLabel: 0,
      attachmentURI: "",
      zoteroBackLink: "",
      annotationKey: ""
    };
    lineElements.citeKey = String(selectedLine.match(/\(([^)]+)\)+$/g));
    if (lineElements.citeKey == `null`) {
      lineElements.citeKey = String(
        selectedLine.match(/\(([^D+]+) \d+\S+\)/g)
      );
    }
    const posCiteKeyBegins = selectedLine.indexOf(lineElements.citeKey);
    let extractedText = "";
    if (posCiteKeyBegins !== -1) {
      extractedText = selectedLine.substring(0, posCiteKeyBegins - 1).trim();
      ["\u201C", '"', "`", "'"].forEach(
        (quote) => extractedText = removeQuoteFromStart(quote, extractedText)
      );
      ["\u201D", '"', "`", "'"].forEach(
        (quote) => extractedText = removeQuoteFromEnd(quote, extractedText)
      );
    }
    let searchRegex = /zotero:\/\/open-pdf\/library\/items\/\S+page=\d+/g;
    lineElements.zoteroBackLink = "";
    if (searchRegex.test(selectedLineOriginal)) {
      const zoteroBackLink = String(selectedLineOriginal.match(searchRegex));
      lineElements.zoteroBackLink = zoteroBackLink;
    }
    searchRegex = /(\d+)(?!.*\d)/g;
    if (searchRegex.test(selectedLineOriginal)) {
      const pageLabel = String(selectedLineOriginal.match(searchRegex));
      if (pageLabel == null) {
        lineElements.pageLabel = null;
      } else {
        lineElements.pageLabel = Number(pageLabel);
      }
    }
    const annotationCommentAll = "";
    if (lineElements.citeKey.includes("(note on page:")) {
      lineElements.commentText = extractedText;
      lineElements.citeKey = "";
    } else {
      lineElements.highlightText = extractedText;
    }
    let firstBlank = -1;
    let annotationCommentFirstWord = "";
    if (lineElements.commentText.length > 0) {
      firstBlank = lineElements.commentText.indexOf(" ");
      if (firstBlank === -1) {
        firstBlank = lineElements.commentText.length;
      }
      annotationCommentFirstWord = lineElements.commentText.substring(0, firstBlank);
    }
    lineElements.annotationType = getAnnotationType(
      annotationCommentFirstWord,
      lineElements.commentText,
      settings
    );
    if (firstBlank == -1) {
      firstBlank = annotationCommentAll.length;
    }
    lineElements.commentText = lineElements.annotationType === "noFormat" ? lineElements.commentText : lineElements.commentText.substring(
      firstBlank,
      lineElements.commentText.length
    ).trim();
    if (noteElements.length > 1) {
      if (lineElements.annotationType != "noFormat" && noteElements[noteElements.length - 1].annotationType === "noFormat" && noteElements[noteElements.length - 1].commentText === "") {
        noteElements[noteElements.length - 1].annotationType = lineElements.annotationType;
        noteElements[noteElements.length - 1].commentText = lineElements.commentText;
        continue;
      }
    }
    noteElements.push(lineElements);
  }
  return noteElements;
}
function parseAnnotationLinesintoElementsUserNote(note) {
  note = note.replace(/`/g, "'").replace(/, p. p. /g, ", p. ").trim();
  const lines = note.split(/<\/h1>|\n\n|<\/p>/gm);
  const noteElements = [];
  const lengthLines = Object.keys(lines).length;
  for (let indexLines = 0; indexLines < lengthLines; indexLines++) {
    const selectedLineOriginal = unescape(lines[indexLines]);
    let selectedLine = replaceTemplate(selectedLineOriginal, "`", "'");
    selectedLine = replaceTemplate(selectedLine, "&amp;", "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    const lineElements = {
      highlightText: "",
      highlightColour: "",
      annotationType: "",
      citeKey: "",
      commentText: "",
      rowOriginal: selectedLine,
      rowEdited: selectedLine,
      indexNote: void 0,
      foundOld: void 0,
      positionOld: void 0,
      extractionSource: "UserNote",
      colourTextBefore: "",
      colourTextAfter: "",
      imagePath: "",
      pagePDF: 0,
      pageLabel: 0,
      attachmentURI: "",
      zoteroBackLink: "",
      annotationKey: "",
      commentFormatted: "",
      commentFormattedNoPrepend: "",
      highlightFormatted: "",
      highlightFormattedNoPrepend: "",
      inlineTagsText: "",
      inlineTagsArray: [],
      inlineTagsFormatted: "",
      inlineTagsFormattedNoPrepend: "",
      colourTemplate: "",
      colourTemplateFormatted: "",
      colourTemplateNoPrepend: ""
    };
    lineElements.rowEdited = selectedLine;
    noteElements.push(lineElements);
  }
  return noteElements;
}
function parseAnnotationLinesintoElementsZotero(note, settings) {
  note = note.replace(/`/g, "'").replace(/, p. p. /g, ", p. ").trim();
  const lines = note.split(/<\/h1>|<\/p>|<h1>/gm);
  const noteElements = [];
  const lengthLines = Object.keys(lines).length;
  for (let indexLines = 1; indexLines < lengthLines; indexLines++) {
    const selectedLineOriginal = unescape(lines[indexLines]);
    let selectedLine = String(
      selectedLineOriginal.replace(/<\/?[^>]+(>|$)/g, "")
    );
    selectedLine = replaceTemplate(selectedLine, "`", "'");
    selectedLine = replaceTemplate(selectedLine, "&amp;", "&");
    const lineElements = {
      highlightText: "",
      highlightColour: "",
      annotationType: "",
      citeKey: "",
      commentText: "",
      inlineTagsText: "",
      inlineTagsArray: [],
      rowOriginal: selectedLine,
      rowEdited: selectedLine,
      indexNote: void 0,
      foundOld: void 0,
      positionOld: void 0,
      extractionSource: "zotero",
      colourTextBefore: "",
      colourTextAfter: "",
      imagePath: "",
      pagePDF: 0,
      pageLabel: 0,
      zoteroBackLink: "",
      attachmentURI: "",
      annotationKey: ""
    };
    lineElements.extractionSource = "zotero";
    if (/data-attachment-key=/gm.test(selectedLineOriginal)) {
      lineElements.annotationType = "typeImage";
      lineElements.imagePath = String(selectedLineOriginal.match(/key="([^"]*)"/g)[0]).replaceAll('"', "").replace("key=", "");
    }
    if (/"color":"#......"/gm.test(selectedLineOriginal)) {
      let highlightColour = String(selectedLineOriginal.match(/"color":"#......"/gm));
      if (highlightColour == null)
        highlightColour = "";
      highlightColour = highlightColour.replace('color":', "");
      highlightColour = highlightColour.replace('"', "");
      lineElements.highlightColour = highlightColour;
    }
    if (/"locator":"\d+"/gm.test(selectedLineOriginal)) {
      let pagePDF = String(selectedLineOriginal.match(/"locator":"\d+"/gm)[0]);
      if (pagePDF == null) {
        lineElements.pagePDF = null;
      } else {
        pagePDF = pagePDF.replace('"locator":', "");
        pagePDF = pagePDF.replaceAll('"', "");
        lineElements.pagePDF = Number(pagePDF);
      }
    }
    if (/"pageLabel":"\d+/g.test(selectedLineOriginal)) {
      let pageLabel = String(selectedLineOriginal.match(/"pageLabel":"\d+/g));
      if (pageLabel == null) {
        lineElements.pageLabel = null;
      } else {
        pageLabel = pageLabel.replace('"pageLabel":"', "");
        lineElements.pageLabel = Number(pageLabel);
      }
    }
    let searchRegex = /attachmentURI":"http:\/\/zotero\.org\/users\/\d+\/items\/\w+/gm;
    let replaceRegex = /attachmentURI":"http:\/\/zotero\.org\/users\/\d+\/items\//gm;
    let matchRegex;
    if (searchRegex.test(selectedLineOriginal)) {
      let attachmentURI = String(
        selectedLineOriginal.match(searchRegex)
      );
      if (attachmentURI === null) {
        lineElements.attachmentURI = null;
      } else {
        attachmentURI = attachmentURI.replace(replaceRegex, "");
        lineElements.attachmentURI = attachmentURI;
      }
    }
    searchRegex = /"attachmentURI":"http:\/\/zotero.org\/users\/local\/[a-zA-Z0-9]*\/items\/[a-zA-Z0-9]*/gm;
    replaceRegex = /"attachmentURI":"http:\/\/zotero.org\/users\/local\/[a-zA-Z0-9]*\/items\//gm;
    if (searchRegex.test(selectedLineOriginal)) {
      let attachmentURI = String(
        selectedLineOriginal.match(searchRegex)
      );
      if (attachmentURI === null) {
        lineElements.attachmentURI = null;
      } else {
        attachmentURI = attachmentURI.replace(replaceRegex, "");
        lineElements.attachmentURI = attachmentURI;
      }
    }
    searchRegex = /"uris":\["http:\/\/zotero\.org\/users\/\d+\/items\/\w+/gm;
    replaceRegex = /"uris":\["http:\/\/zotero\.org\/users\/\d+\/items\//g;
    matchRegex = /"uris":\["http:\/\/zotero\.org\/users\/\d+\/items\/\w+/g;
    if (searchRegex.test(selectedLineOriginal) && lineElements.attachmentURI == "") {
      let attachmentURI = String(selectedLineOriginal.match(matchRegex));
      if (attachmentURI === null) {
        lineElements.attachmentURI = null;
      } else {
        attachmentURI = attachmentURI.replace(replaceRegex, "");
        lineElements.attachmentURI = attachmentURI;
      }
    }
    searchRegex = /"annotationKey":"[a-zA-Z0-9]+/gm;
    replaceRegex = /"annotationKey":"/gm;
    if (searchRegex.test(selectedLineOriginal)) {
      let annotationKey = String(selectedLineOriginal.match(searchRegex));
      if (annotationKey === null) {
        lineElements.annotationKey = null;
      } else {
        annotationKey = annotationKey.replace(replaceRegex, "");
        lineElements.annotationKey = annotationKey;
      }
    }
    if (lineElements.attachmentURI !== null && lineElements.pagePDF !== null && lineElements.annotationKey !== null) {
      lineElements.zoteroBackLink = `zotero://open-pdf/library/items/${lineElements.attachmentURI}?page=${lineElements.pagePDF}&annotation=${lineElements.annotationKey}`;
    }
    searchRegex = /\(<span class="citation-item">.*<\/span>\)<\/span>/gm;
    if (searchRegex.test(selectedLineOriginal)) {
      lineElements.citeKey = String(selectedLineOriginal.match(searchRegex)).replace('(<span class="citation-item">', "").replace("</span>)</span>", "");
      lineElements.citeKey = `(${lineElements.citeKey})`;
    }
    const beginningCiteKey = selectedLine.indexOf(lineElements.citeKey);
    const endCiteKey = selectedLine.indexOf(lineElements.citeKey) + lineElements.citeKey.length;
    replaceRegex = new RegExp("((?<=\\p{Unified_Ideograph})\\s*(?=\\p{Unified_Ideograph}))", "gu");
    if (endCiteKey !== 0) {
      lineElements.highlightText = selectedLine.substring(0, beginningCiteKey - 1).trim();
      lineElements.highlightText = lineElements.highlightText.replace(replaceRegex, "");
      ["\u201C", '"', "`", "'"].forEach(
        (quote) => lineElements.highlightText = removeQuoteFromStart(quote, lineElements.highlightText)
      );
      ["\u201D", '"', "`", "'"].forEach(
        (quote) => lineElements.highlightText = removeQuoteFromEnd(quote, lineElements.highlightText)
      );
    }
    if (endCiteKey > 0) {
      const annotationCommentAll = selectedLine.substring(endCiteKey + 1).trim();
      let firstBlank = annotationCommentAll.indexOf(" ");
      const annotationCommentFirstWord = annotationCommentAll.substring(0, firstBlank);
      if (lineElements.annotationType !== "typeImage") {
        lineElements.annotationType = getAnnotationType(annotationCommentFirstWord, annotationCommentAll, settings);
      }
      lineElements.commentText = "";
      if (firstBlank == -1)
        firstBlank = annotationCommentAll.length;
      lineElements.commentText = lineElements.annotationType === "noFormat" || lineElements.annotationType === "typeImage" ? annotationCommentAll : annotationCommentAll.substring(firstBlank, annotationCommentAll.length).trim();
      if (lineElements.commentText.includes(settings.TagBeginningConfig)) {
        if (settings.TagEndConfig.length == 0) {
          lineElements.inlineTagsText = lineElements.commentText.slice(
            lineElements.commentText.indexOf(settings.TagBeginningConfig),
            lineElements.commentText.length
          );
        } else {
          lineElements.inlineTagsText = lineElements.commentText.slice(
            lineElements.commentText.indexOf(settings.TagBeginningConfig),
            lineElements.commentText.lastIndexOf(settings.TagEndConfig)
          );
        }
        lineElements.commentText = lineElements.commentText.replace(lineElements.inlineTagsText, "").trim();
      }
      if (typeof lineElements.inlineTagsText !== `undefined`) {
        lineElements.inlineTagsText = lineElements.inlineTagsText.replace(settings.TagBeginningConfig, "");
        if (settings.TagEndConfig.length != 0) {
          lineElements.inlineTagsText = lineElements.inlineTagsText.replace(settings.TagEndConfig, "");
        }
        lineElements.inlineTagsArray = lineElements.inlineTagsText.split(settings.TagDividerConfig);
      }
    } else {
      lineElements.rowEdited = selectedLine;
    }
    noteElements.push(lineElements);
  }
  return noteElements;
}

// src/notes.ts
function openNoteAfterImport(file, isOpen) {
  let leaf;
  leaf = this.app.workspace.getLeaf(false);
  if (isOpen)
    leaf.openFile(file);
}
function compareOldNewNote(existingNote, newNote, authorKey, settings) {
  const newLineRegex = RegExp(/\n/gm);
  const positionNewLine = [];
  let match = void 0;
  while (match = newLineRegex.exec(existingNote)) {
    positionNewLine.push(match.index);
  }
  const positionOldNote = [0];
  const newNoteInsertText = [];
  const newNoteInsertPosition = [];
  const newNoteArray = newNote.split("\n");
  for (let indexLines = 0; indexLines < newNoteArray.length; indexLines++) {
    let segmentWhole = "";
    let segmentFirstHalf = "";
    let segmentSecondHalf = "";
    let segmentFirstQuarter = "";
    let segmentSecondQuarter = "";
    let segmentThirdQuarter = "";
    let segmentFourthQuarter = "";
    const positionArray = [-1];
    let selectedNewLine = newNoteArray[indexLines];
    selectedNewLine = selectedNewLine.trim();
    selectedNewLine = selectedNewLine.replace(/^- /gm, "");
    selectedNewLine = selectedNewLine.replace(/^> /gm, "");
    selectedNewLine = selectedNewLine.replace(/^=/gm, "");
    selectedNewLine = selectedNewLine.replace(/^\**/gm, "");
    selectedNewLine = selectedNewLine.replace(/^\*/gm, "");
    selectedNewLine = selectedNewLine.replace(/^"/gm, "");
    const authorKey_Zotero = new RegExp("\\(" + authorKey + ", \\d+, p. \\d+\\)$");
    const authorKey_Zotfile = new RegExp("\\(" + authorKey + " \\d+:\\d+\\)$");
    selectedNewLine = selectedNewLine.replace(authorKey_Zotero, "");
    selectedNewLine = selectedNewLine.replace(authorKey_Zotfile, "");
    selectedNewLine = selectedNewLine.replace(/=$/gm, "");
    selectedNewLine = selectedNewLine.replace(/\**$/gm, "");
    selectedNewLine = selectedNewLine.replace(/\*$/gm, "");
    selectedNewLine = selectedNewLine.replace(/"$/gm, "");
    if (selectedNewLine == void 0)
      continue;
    const lengthExistingLine = selectedNewLine.length;
    if (lengthExistingLine === 0)
      continue;
    if (lengthExistingLine > 1 && lengthExistingLine < 30) {
      segmentWhole = selectedNewLine;
      positionArray.push(existingNote.indexOf(segmentWhole));
    } else if (lengthExistingLine >= 30 && lengthExistingLine < 150) {
      segmentFirstHalf = selectedNewLine.substring(0, lengthExistingLine / 2);
      positionArray.push(existingNote.indexOf(segmentFirstHalf));
      segmentSecondHalf = selectedNewLine.substring(lengthExistingLine / 2 + 1, lengthExistingLine);
      positionArray.push(existingNote.indexOf(segmentSecondHalf));
    } else if (lengthExistingLine >= 150) {
      segmentFirstQuarter = selectedNewLine.substring(0, lengthExistingLine / 4);
      positionArray.push(existingNote.indexOf(segmentFirstQuarter));
      segmentSecondQuarter = selectedNewLine.substring(lengthExistingLine / 4 + 1, lengthExistingLine / 2);
      positionArray.push(existingNote.indexOf(segmentSecondQuarter));
      segmentThirdQuarter = selectedNewLine.substring(lengthExistingLine / 2 + 1, 3 * lengthExistingLine / 4);
      positionArray.push(existingNote.indexOf(segmentThirdQuarter));
      segmentFourthQuarter = selectedNewLine.substring(3 * lengthExistingLine / 4 + 1, lengthExistingLine);
      positionArray.push(existingNote.indexOf(segmentFourthQuarter));
    }
    if (Math.max(...positionArray) > -1) {
      const positionOldNoteMax = Math.max(...positionArray);
      positionOldNote.push(positionOldNoteMax);
    }
    if (Math.max(...positionArray) === -1) {
      const positionOldNoteMax = Math.max(...positionOldNote);
      newNoteInsertText.push(newNoteArray[indexLines]);
      newNoteInsertPosition.push(
        positionNewLine.filter((pos) => pos > positionOldNoteMax)[0]
      );
    }
  }
  let doubleSpaceAdd = "";
  if (settings.isDoubleSpaced)
    doubleSpaceAdd = "\n";
  for (let indexNoteElements = newNoteInsertText.length - 1; indexNoteElements >= 0; indexNoteElements--) {
    const insertText = newNoteInsertText[indexNoteElements];
    const insertPosition = newNoteInsertPosition[indexNoteElements];
    existingNote = existingNote.slice(0, insertPosition) + doubleSpaceAdd + "\n" + insertText + existingNote.slice(insertPosition);
  }
  if (settings.saveManualEdits == "Save Entire Note")
    return existingNote;
  if (settings.saveManualEdits == "Select Section") {
    const startSave = settings.saveManualEditsStart;
    const endSave = settings.saveManualEditsEnd;
    let startSaveOld = 0;
    if (startSave !== "")
      startSaveOld = existingNote.indexOf(startSave);
    if (startSaveOld < 0)
      startSaveOld = 0;
    let endSaveOld = existingNote.length;
    if (endSave !== "")
      endSaveOld = existingNote.indexOf(endSave) + endSave.length;
    if (endSaveOld < 0)
      endSaveOld = existingNote.length;
    const existingNotePreserved = existingNote.substring(startSaveOld, endSaveOld);
    let startSaveNew = 0;
    if (startSave !== "")
      startSaveNew = newNote.indexOf(startSave);
    if (startSaveNew < 0)
      startSaveNew = 0;
    let endSaveNew = newNote.length;
    if (endSave !== "")
      endSaveNew = newNote.indexOf(endSave) + endSave.length;
    if (endSaveNew < 0)
      endSaveNew = newNote.length;
    const newNotePreservedBefore = newNote.substring(0, startSaveNew);
    const newNotePreservedAfter = newNote.substring(endSaveNew, newNote.length);
    const newNoteCombined = newNotePreservedBefore + existingNotePreserved + newNotePreservedAfter;
    return newNoteCombined;
  }
}
function createNote(selectedEntry, settings) {
  return __async(this, null, function* () {
    const authorKey = getCreatorKey(selectedEntry.creators);
    selectedEntry.authorKey = authorKey;
    selectedEntry.authorKeyInitials = getCreatorFullInitials(selectedEntry.creators);
    selectedEntry.authorKeyFullName = getCreatorFullNames(selectedEntry.creators);
    const templateNote = yield importTemplate(settings);
    let litnote = parseMetadata(selectedEntry, settings, templateNote);
    const noteTitle = getNoteTitle(selectedEntry, settings.importFileName);
    const notePath = createNotePath(noteTitle, settings.importPath);
    const resultAnnotations = extractAnnotation(selectedEntry, settings);
    litnote = litnote.replace("{{PDFNotes}}", resultAnnotations.extractedAnnotations);
    litnote = litnote.replace("{{UserNotes}}", resultAnnotations.extractedUserNote);
    litnote = litnote.replace("{{Images}}", resultAnnotations.extractedImages);
    let extractedKeywords = resultAnnotations.extractedKeywords;
    if (extractedKeywords == void 0) {
      extractedKeywords = [];
    }
    litnote = insertKeywordList(selectedEntry, extractedKeywords, litnote, settings.multipleFieldsDivider);
    const missingFieldSetting = settings.missingfield;
    litnote = replaceMissingFields(litnote, missingFieldSetting, settings.missingfieldreplacement);
    if (settings.saveManualEdits !== "Overwrite Entire Note" && fs2.existsSync(notePath)) {
      const existingNoteAll = String(fs2.readFileSync(notePath));
      litnote = compareOldNewNote(existingNoteAll, litnote, authorKey, settings);
    }
    fs2.writeFile(notePath, litnote, (err) => {
      if (err) {
        console.error(err);
        return;
      }
      new import_obsidian3.Notice(`Imported ${selectedEntry.citationKey}`);
    });
  });
}
function updateNotes(settings) {
  const jsonPath = resolvePath(settings.bibPath);
  if (!fs2.existsSync(jsonPath))
    new import_obsidian3.Notice("No BetterBibTex Json file found at " + jsonPath);
  const rawdata = fs2.readFileSync(jsonPath);
  const data = JSON.parse(rawdata.toString());
  const bibtexArray = [];
  const lastUpdate = new Date(settings.lastUpdateDate);
  for (let index = 0; index < data.items.length; index++) {
    const selectedEntry = data.items[index];
    const bibtexArrayItem = {};
    if (selectedEntry.hasOwnProperty("citationKey") == false)
      continue;
    bibtexArrayItem.citationKey = selectedEntry.citationKey;
    const noteDateModifiedArray = [];
    noteDateModifiedArray.push(selectedEntry.dateModified);
    for (let index2 = 0; index2 < selectedEntry.notes.length; index2++) {
      noteDateModifiedArray.push(selectedEntry.notes[index2].dateModified);
      noteDateModifiedArray.sort((firstElement, secondElement) => {
        if (firstElement > secondElement)
          return -1;
        if (firstElement < secondElement)
          return 1;
        return 0;
      });
    }
    const datemodified = new Date(noteDateModifiedArray[0]);
    if (datemodified < lastUpdate)
      continue;
    const noteTitle = getNoteTitle(selectedEntry, settings.importFileName);
    const notePath = createNotePath(noteTitle, settings.importPath);
    if (settings.updateNotes === "Only existing notes" && !fs2.existsSync(notePath))
      continue;
    createNote(selectedEntry, settings);
    bibtexArray.push(selectedEntry.citationKey);
  }
  new import_obsidian3.Notice("Updated " + bibtexArray.length + " entries");
  settings.lastUpdateDate = new Date();
}

// src/modal.ts
var fuzzySelectReference = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  focusInput() {
    document.getElementsByClassName("prompt-input")[0].focus();
  }
  onOpen() {
    return __async(this, null, function* () {
      if (import_obsidian4.Platform.isDesktopApp) {
        this.focusInput();
      }
      const jsonPath = resolvePath(this.plugin.settings.bibPath);
      if (!fs3.existsSync(jsonPath)) {
        new import_obsidian4.Notice("No BetterBibTeX JSON file found at " + jsonPath);
      }
      const rawdata = fs3.readFileSync(jsonPath);
      const data = JSON.parse(rawdata.toString());
      const bibtexArray = [];
      for (let index = 0; index < data.items.length; index++) {
        const selectedEntry = data.items[index];
        const bibtexArrayItem = {};
        if (selectedEntry.hasOwnProperty("citationKey") == false)
          continue;
        bibtexArrayItem.citationKey = selectedEntry.citationKey;
        const truncateTitle = truncate(selectedEntry.title, 120);
        selectedEntry.title = truncateTitle;
        bibtexArrayItem.title = selectedEntry.title;
        bibtexArrayItem.date = selectedEntry.date;
        if (selectedEntry.hasOwnProperty("date")) {
          selectedEntry.year = selectedEntry.date.match(/\d\d\d\d/gm);
          bibtexArrayItem.date = selectedEntry.year;
        }
        bibtexArrayItem.authorKey = getCreatorFullNames(selectedEntry.creators);
        bibtexArrayItem.dateModified = selectedEntry.dateModified;
        bibtexArrayItem.inlineReference = bibtexArrayItem.authorKey + bibtexArrayItem.date + bibtexArrayItem.title + bibtexArrayItem.citationKey;
        bibtexArray.push(bibtexArrayItem);
      }
      bibtexArray.sort(orderByDateModified);
      this.selectArray = bibtexArray;
      yield this.updateSuggestions();
      this.data = data;
    });
  }
  getItems() {
    return this.selectArray;
  }
  getItemText(referenceSelected) {
    return referenceSelected.inlineReference;
  }
  updateSuggestions() {
    return __async(this, null, function* () {
      yield __superGet(fuzzySelectReference.prototype, this, "updateSuggestions").call(this);
    });
  }
  renderSuggestion(match, el) {
    el.empty();
    const entry = match.item;
    const entryTitle = entry.title || "";
    const container = el.createEl("div", { cls: "zaModalResult" });
    const titleEl = container.createEl("span", {
      cls: "zaTitle"
    });
    const authorsCls = entry.authorKey ? "zaAuthors" : "zaAuthors zaAuthorsEmpty";
    const authorsEl = container.createEl("span", {
      cls: authorsCls
    });
    container.createEl("span", { cls: "zaCitekey", text: entry.citationKey });
    const allMatches = match.match.matches;
    const shiftMatches = (matches, start, end) => {
      return matches.map((match2) => {
        const [matchStart, matchEnd] = match2;
        return [
          matchStart - start,
          Math.min(matchEnd - start, end)
        ];
      }).filter((match2) => {
        const [matchStart, matchEnd] = match2;
        return matchStart >= 0;
      });
    };
    (0, import_obsidian4.renderMatches)(
      titleEl,
      entryTitle,
      shiftMatches(allMatches, 0, entryTitle.length)
    );
    if (entry.authorKey) {
      (0, import_obsidian4.renderMatches)(
        authorsEl,
        entry.authorKey,
        shiftMatches(allMatches, 0, entry.authorKey.length)
      );
    }
  }
  onChooseItem(referenceSelected, evt) {
    return __async(this, null, function* () {
      let citeKeyItem = [];
      citeKeyItem.push(referenceSelected.citationKey);
      for (let index = 0; index < citeKeyItem.length; index++) {
        const referenceItem = this.data.items.findIndex(
          (item) => item.citationKey === citeKeyItem[index]
        );
        const selectedEntry = this.data.items[referenceItem];
        createNote(selectedEntry, this.plugin.settings);
        const noteTitle = getNoteTitle(selectedEntry, this.plugin.settings.importFileName);
        const myFile = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian4.normalizePath)(noteTitle), "");
        openNoteAfterImport(myFile, this.plugin.settings.openAfterImport);
      }
    });
  }
};

// src/settings.ts
var import_obsidian6 = require("obsidian");

// src/lang/helpers.ts
var import_obsidian5 = require("obsidian");

// src/lang/locale/ar.ts
var ar_default = {};

// src/lang/locale/cz.ts
var cz_default = {};

// src/lang/locale/da.ts
var da_default = {};

// src/lang/locale/de.ts
var de_default = {};

// src/lang/locale/en.ts
var en_default = {
  JSON_FILE_PATH: "JSON File Path",
  JSON_FILE_PATH_DESC: "Add relative path from the vault folder to the <b><a href='https://retorque.re/zotero-better-bibtex/'>Better BibTeX</a> JSON</b> file generated for your Zotero library.",
  JSON_FILE_PATH_PLACEHOLDER: "path/to/zotero.json",
  IMPORT_NOTES_FOLDER: "Import Notes Folder",
  IMPORT_NOTES_FOLDER_DESC: "Add relative path from the vault folder to the folder where you want to import the notes.",
  IMPORT_NOTES_FOLDER_PLACEHOLDER: "path/to/folder",
  NOTE_FILE_NAME: "Note File Name",
  NOTE_FILE_NAME_DESC: "Add the name of the note file. You can use the following placeholders:<br><code>{{citeKey}}</code>, <code>{{title}}</code>, <code>{{author}}</code>,<code>{{authorInitials}}</code>, <code>{{authorFullName}}</code> <code>{{year}}</code>",
  NOTE_FILE_NAME_PLACEHOLDER: "{{citeKey}}",
  TEMPLATE_FILE: "Template File",
  TEMPLATE_FILE_DESC: "Add relative path from the vault folder to the template file <b>without</b> the file extension.<br> If left empty, the default template will be used.",
  TEMPLATE_FILE_PLACEHOLDER: "path/to/template",
  MISSING_FIELDS: "Missing fields",
  MISSING_FIELDS_DESC: "Rule to handle fields that are present in the template but missing in the Zotero library.",
  REPLACE_MISSING_FIELDS: "Custom text replacement for missing fields",
  FORMAT_CREATOR_NAMES: "Format Creator Names",
  FORMAT_CREATOR_NAMES_DESC: "Specify how the names of the authors/editors should be imported.<br>Accepted values are <code>{{firstName}}</code>, <code>{{lastName}}</code> and <code>{{firstNameInitials}}</code>",
  MULTIPLE_ENTRIES_DELIMITER: "Multiple Entries Delimiter",
  MULTIPLE_ENTRIES_DELIMITER_DESC: "Specify the character or expression that should separate multiple values.<br>Values such as  authors, editors, tags, collections, etc.",
  CREATE_BACKLINKS: "Attach Link to the PDF",
  CREATE_BACKLINKS_DESC: "Attach link with the extracted highlights or figures to the original page of the PDF.<br><b>Toggle ON:</b> Attach link to the highlighted page<br><b>Toggle OFF:</b> Omit the link to the highlighted page",
  FORMAT_BACKLINKS: "Format Zotero Backlinks",
  FORMAT_BACKLINKS_DESC: "Specify how the backlinks should be formatted, if <b>Attach Link to the PDF</b> option is turned on.",
  ORDER_OF_EXTRACTED_ELEMENT: "Order of Extracted Element",
  ORDER_OF_EXTRACTED_ELEMENT_DESC: "Specify the arrangement order of the elements <code>{{highlight}}</code> <code>{{comment}}</code>and <code>{{tag}}</code>",
  MULTIPLE_ANNOTATION_FILES: "Multiple Annotation Notes",
  MULTIPLE_ANNOTATION_FILES_DESC: "Specify whether to import all annotation files associated with a reference or the latest note.<br><b>Toggle ON:</b>  Import All annotation notes <br><b>Toggle OFF:</b> Import the latest annotation note",
  NOTE_UPDATE_PRESERVATION: "Note Update Preservation",
  NOTE_UPDATE_PRESERVATION_DESC: "Specify whether to preserve the existing notes or overwrite them with the imported notes.<br><b>Overwrite Entire Note:</b> No manual edits or notes from before is preserved.<br><b>Select Section:</b> Will preserve contents that are inside the choosen sections.",
  PRESERVATION_SECTION_START: "Preservation Section Start",
  PRESERVATION_SECTION_START_DESC: "Specify the start of the section that should be preserved.(e.g. <code>## Notes</code>)",
  PRESERVATION_SECTION_END: "Preservation Section End",
  PRESERVATION_SECTION_END_DESC: "Specify the end of the section that should be preserved.(e.g. <code>## Comments</code>)",
  OPEN_UPDATED_NOTE: "Open Updated Note",
  OPEN_UPDATED_NOTE_DESC: "Specify whether to open the updated note after the import process is complete.<br><b>Toggle ON:</b> Open the updated note <br><b>Toggle OFF:</b> Do not open the updated note",
  UPDATE_ALL_NOTES: "Update Existing or All Notes",
  UPDATE_ALL_NOTES_DESC: "Specify the rule for batch updating the notes.<br><b>Only existing notes:</b> Update only the notes that are already present in the vault.<br><b>Create when missing:</b> Update and create notes if annotation is available in the Zotero library.<br>",
  EMBED_IMAGES: "Embed highlighted Images",
  EMBED_IMAGES_DESC: "This option is available only for notes extracted using the Zotero native PDF reader.<br><b>Toggle ON:</b> Embed highlighted images in the note.<br><b>Toggle OFF:</b> Do not embed highlighted images in the note.",
  IMAGE_COPY: "Copy Images to Vault",
  IMAGE_COPY_DESC: "Specify whether to copy the zotero reader highlighted images to the Obsidian vault.<br><b>Toggle ON:</b> Copy highlighted images to the vault.<br><b>Toggle OFF:</b> Keep highlighted images in Zotero Library and embed from there.",
  IMAGE_COPY_PATH: "Image Copy Path",
  IMAGE_COPY_PATH_DESC: "Specify the relative path from the vault folder to the folder where the images should be copied.",
  POSITION_OF_IMAGE_COMMENT: "Position of Image Comment",
  POSITION_OF_IMAGE_COMMENT_DESC: "Specify the position of the image comment in the note.<br><b>Above the image:</b> Comment will be placed above the image.<br><b>Below the image:</b> Comment will be placed below the image.",
  ZOTERO_LOCAL_FOLDER: "Zotero Local Folder",
  ZOTERO_LOCAL_FOLDER_DESC: "Specify the path to the Zotero local storage folder. <br>This field is required only when this is different from the folder where the PDF files are stored.<br>To retrieve this information, open <code>Zotero -> Preferences -> Advanced -> Files and Folder </code>, and copy the <b>data directory location</b>, followed by the subdirectory <code>/storage</code>"
};

// src/lang/locale/en-gb.ts
var en_gb_default = {};

// src/lang/locale/es.ts
var es_default = {};

// src/lang/locale/fr.ts
var fr_default = {};

// src/lang/locale/hi.ts
var hi_default = {};

// src/lang/locale/id.ts
var id_default = {};

// src/lang/locale/it.ts
var it_default = {};

// src/lang/locale/ja.ts
var ja_default = {};

// src/lang/locale/ko.ts
var ko_default = {};

// src/lang/locale/nl.ts
var nl_default = {};

// src/lang/locale/no.ts
var no_default = {};

// src/lang/locale/pl.ts
var pl_default = {};

// src/lang/locale/pt.ts
var pt_default = {};

// src/lang/locale/pt-br.ts
var pt_br_default = {};

// src/lang/locale/ro.ts
var ro_default = {};

// src/lang/locale/ru.ts
var ru_default = {};

// src/lang/locale/tr.ts
var tr_default = {};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {};

// src/lang/locale/zh-tw.ts
var zh_tw_default = {};

// src/lang/helpers.ts
var localeMap = {
  ar: ar_default,
  cs: cz_default,
  da: da_default,
  de: de_default,
  en: en_default,
  "en-gb": en_gb_default,
  es: es_default,
  fr: fr_default,
  hi: hi_default,
  id: id_default,
  it: it_default,
  ja: ja_default,
  ko: ko_default,
  nl: nl_default,
  nn: no_default,
  pl: pl_default,
  pt: pt_default,
  "pt-br": pt_br_default,
  ro: ro_default,
  ru: ru_default,
  tr: tr_default,
  "zh-cn": zh_cn_default,
  "zh-tw": zh_tw_default
};
var locale = localeMap[import_obsidian5.moment.locale()];
function t(str) {
  if (!locale) {
    errorlog({
      where: "helpers.t",
      message: "Error: Zotero Annotations locale not found",
      locale: import_obsidian5.moment.locale()
    });
  }
  return locale && locale[str] || en_default[str];
}

// src/settings.ts
var SettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    containerEl.createEl("h2", { text: "General Settings" });
    new import_obsidian6.Setting(containerEl).setName(t("JSON_FILE_PATH")).setDesc(fragWithHTML(t("JSON_FILE_PATH_DESC"))).addText(
      (text) => text.setPlaceholder(t("JSON_FILE_PATH_PLACEHOLDER")).setValue(settings.bibPath).onChange((value) => __async(this, null, function* () {
        settings.bibPath = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("IMPORT_NOTES_FOLDER")).setDesc(fragWithHTML(t("IMPORT_NOTES_FOLDER_DESC"))).addText(
      (text) => text.setPlaceholder(t("IMPORT_NOTES_FOLDER_PLACEHOLDER")).setValue(settings.importPath).onChange((value) => __async(this, null, function* () {
        settings.importPath = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("NOTE_FILE_NAME")).setDesc(fragWithHTML(t("NOTE_FILE_NAME_DESC"))).addText(
      (text) => text.setPlaceholder(t("NOTE_FILE_NAME_PLACEHOLDER")).setValue(settings.importFileName).onChange((value) => __async(this, null, function* () {
        settings.importFileName = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("TEMPLATE_FILE")).setDesc(fragWithHTML(t("TEMPLATE_FILE_DESC"))).addText(
      (text) => text.setPlaceholder(t("TEMPLATE_FILE_PLACEHOLDER")).setValue(settings.templatePath).onChange((value) => __async(this, null, function* () {
        settings.templatePath = value;
        yield plugin.saveSettings();
      }))
    );
    containerEl.createEl("h2", { text: "Notes Import Settings" });
    new import_obsidian6.Setting(containerEl).setName(t("MISSING_FIELDS")).setDesc(fragWithHTML(t("MISSING_FIELDS_DESC"))).addDropdown((d) => {
      d.addOption("Leave placeholder", "Leave placeholder");
      d.addOption("Remove (entire row)", "Remove (entire row)");
      d.addOption(
        "Replace with custom text",
        "Replace with custom text"
      );
      d.setValue(settings.missingfield);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.missingfield = v;
          yield plugin.saveSettings();
          this.display();
        })
      );
    });
    if (settings.missingfield === "Replace with custom text") {
      new import_obsidian6.Setting(containerEl).setName(t("REPLACE_MISSING_FIELDS")).addText(
        (text) => text.setValue(settings.missingfieldreplacement).onChange((value) => __async(this, null, function* () {
          settings.missingfieldreplacement = value;
          yield plugin.saveSettings();
        }))
      );
    }
    new import_obsidian6.Setting(containerEl).setName(t("FORMAT_CREATOR_NAMES")).setDesc(fragWithHTML(t("FORMAT_CREATOR_NAMES_DESC"))).addText(
      (text) => text.setValue(settings.nameFormat).onChange((value) => __async(this, null, function* () {
        settings.nameFormat = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("MULTIPLE_ENTRIES_DELIMITER")).setDesc(fragWithHTML(t("MULTIPLE_ENTRIES_DELIMITER_DESC"))).addText(
      (text) => text.setPlaceholder(",").setValue(settings.multipleFieldsDivider).onChange((value) => __async(this, null, function* () {
        settings.multipleFieldsDivider = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("CREATE_BACKLINKS")).setDesc(fragWithHTML(t("CREATE_BACKLINKS_DESC"))).addToggle(
      (text) => text.setValue(settings.highlightCitationsLink).onChange((value) => __async(this, null, function* () {
        settings.highlightCitationsLink = value;
        yield plugin.saveSettings();
        this.display();
      }))
    );
    if (settings.highlightCitationsLink) {
      new import_obsidian6.Setting(containerEl).setName(t("FORMAT_BACKLINKS")).setDesc(fragWithHTML(t("FORMAT_BACKLINKS_DESC"))).addDropdown((d) => {
        d.addOption(
          "Author, year, page number",
          "Author, year, page number"
        );
        d.addOption("Only page number", "Only page number");
        d.addOption("Pandoc", "Pandoc");
        d.addOption("Empty", "Empty");
        d.setValue(settings.highlightCitationsFormat);
        d.onChange(
          (v) => __async(this, null, function* () {
            settings.highlightCitationsFormat = v;
            yield plugin.saveSettings();
          })
        );
      });
    }
    new import_obsidian6.Setting(containerEl).setName(t("ORDER_OF_EXTRACTED_ELEMENT")).setDesc(fragWithHTML(t("ORDER_OF_EXTRACTED_ELEMENT_DESC"))).addTextArea(
      (text) => text.setValue(settings.highlightExportTemplate).onChange((value) => __async(this, null, function* () {
        settings.highlightExportTemplate = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("MULTIPLE_ANNOTATION_FILES")).setDesc(fragWithHTML(t("MULTIPLE_ANNOTATION_FILES_DESC"))).addToggle(
      (t2) => t2.setValue(settings.importAllAnnotationFiles).onChange((value) => __async(this, null, function* () {
        settings.importAllAnnotationFiles = value;
        yield plugin.saveSettings();
        this.display();
      }))
    );
    containerEl.createEl("h2", { text: "Notes Update Settings" });
    new import_obsidian6.Setting(containerEl).setName(t("NOTE_UPDATE_PRESERVATION")).setDesc(fragWithHTML(t("NOTE_UPDATE_PRESERVATION_DESC"))).addDropdown((d) => {
      d.addOption("Select Section", "Select Section");
      d.addOption("Overwrite Entire Note", "Overwrite Entire Note");
      d.setValue(settings.saveManualEdits);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.saveManualEdits = v;
          yield plugin.saveSettings();
          this.display();
        })
      );
    });
    if (settings.saveManualEdits == "Select Section") {
      new import_obsidian6.Setting(containerEl).setName(t("PRESERVATION_SECTION_START")).setDesc(fragWithHTML(t("PRESERVATION_SECTION_START_DESC"))).addText(
        (text) => text.setValue(settings.saveManualEditsStart).onChange((value) => __async(this, null, function* () {
          settings.saveManualEditsStart = value;
          yield plugin.saveSettings();
        }))
      );
      if (settings.saveManualEdits) {
        new import_obsidian6.Setting(containerEl).setName(t("PRESERVATION_SECTION_END")).setDesc(fragWithHTML(t("PRESERVATION_SECTION_END_DESC"))).addText(
          (text) => text.setValue(settings.saveManualEditsEnd).onChange((value) => __async(this, null, function* () {
            settings.saveManualEditsEnd = value;
            yield plugin.saveSettings();
          }))
        );
      }
    }
    new import_obsidian6.Setting(containerEl).setName(t("OPEN_UPDATED_NOTE")).setDesc(fragWithHTML(t("OPEN_UPDATED_NOTE_DESC"))).addToggle(
      (t2) => t2.setValue(settings.openAfterImport).onChange((value) => __async(this, null, function* () {
        settings.openAfterImport = value;
        yield plugin.saveSettings();
        this.display();
      }))
    );
    new import_obsidian6.Setting(containerEl).setName(t("UPDATE_ALL_NOTES")).setDesc(fragWithHTML(t("UPDATE_ALL_NOTES_DESC"))).addDropdown((d) => {
      d.addOption("Only existing notes", "Only existing notes");
      d.addOption("Create when missing", "Create when missing");
      d.setValue(settings.updateNotes);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.updateNotes = v;
          yield plugin.saveSettings();
        })
      );
    });
    containerEl.createEl("h2", { text: "Images Settings" });
    new import_obsidian6.Setting(containerEl).setName(t("EMBED_IMAGES")).setDesc(fragWithHTML(t("EMBED_IMAGES_DESC"))).addToggle(
      (text) => text.setValue(settings.imagesImport).onChange((value) => __async(this, null, function* () {
        settings.imagesImport = value;
        yield plugin.saveSettings();
        this.display();
      }))
    );
    if (settings.imagesImport) {
      new import_obsidian6.Setting(containerEl).setName(t("POSITION_OF_IMAGE_COMMENT")).setDesc(fragWithHTML(t("POSITION_OF_IMAGE_COMMENT_DESC"))).addDropdown((d) => {
        d.addOption("Above the image", "Above the image");
        d.addOption("Below the image", "Below the image");
        d.setValue(settings.imagesCommentPosition);
        d.onChange(
          (v) => __async(this, null, function* () {
            settings.imagesCommentPosition = v;
            yield plugin.saveSettings();
            this.display();
          })
        );
      });
      new import_obsidian6.Setting(containerEl).setName(t("IMAGE_COPY")).setDesc(fragWithHTML(t("IMAGE_COPY_DESC"))).addToggle(
        (text) => text.setValue(settings.imagesCopy).onChange((value) => __async(this, null, function* () {
          settings.imagesCopy = value;
          yield plugin.saveSettings();
          this.display();
        }))
      );
      if (settings.imagesCopy) {
        new import_obsidian6.Setting(containerEl).setName(t("IMAGE_COPY_PATH")).setDesc(fragWithHTML(t("IMAGE_COPY_PATH_DESC"))).addText(
          (text) => text.setPlaceholder("/path/to/folder").setValue(settings.imagesPath).onChange((value) => __async(this, null, function* () {
            settings.imagesPath = value;
            yield plugin.saveSettings();
          }))
        );
      }
      new import_obsidian6.Setting(containerEl).setName(t("ZOTERO_LOCAL_FOLDER")).setDesc(fragWithHTML(t("ZOTERO_LOCAL_FOLDER_DESC"))).addText(
        (text) => text.setValue(settings.zoteroStoragePathManual).onChange((value) => __async(this, null, function* () {
          settings.zoteroStoragePathManual = value;
          yield plugin.saveSettings();
        }))
      );
    }
  }
};

// src/main.ts
var ZoteroAnnotations = class extends import_obsidian7.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new SettingsTab(this.app, this));
      this.addCommand({
        id: "zotero_annotations-select-reference-modal",
        name: "Create or Update Note",
        callback: () => {
          new fuzzySelectReference(this.app, this).open();
        }
      });
      this.addCommand({
        id: "zotero_annotations-update-library",
        name: "Update All Notes",
        callback: () => updateNotes(this.settings)
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign(
        {},
        DEFAULT_SETTINGS,
        yield this.loadData()
      );
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
